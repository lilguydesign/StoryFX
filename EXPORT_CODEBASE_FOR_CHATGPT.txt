EXPORT FOR CHATGPT ‚Äî TREE + CODE CONTENTS
VERSION: .019
ROOT: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx
GENERATED_AT: 2025-12-30 06:49:59
INCLUDE_SUBDIRS: True
MAX_DEPTH: 50
MAX_BYTES_PER_FILE: 500000
MAX_TOTAL_OUTPUT_BYTES: 12000000
MODIFIED_ONLY: False
INCLUDE_EXTS: ['.dart', '.js', '.ts', '.py', '.html', '.css', '.json', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.md', '.txt', '.prompt', '.sh', '.bat', '.ps1', '.sql']
EXCLUDE_EXTS: ['.csv', '.parquet', '.png', '.jpg', '.jpeg', '.webp', '.gif', '.svg', '.mp4', '.mov', '.avi', '.mp3', '.wav', '.exe', '.dll', '.so', '.dylib', '.zip', '.rar', '.7z']
EXCLUDED_SPECIAL: current script + output file + any name containing 'chatgpt'
============================================================================================================================================

############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx
RELATIVE: .
############################################################################################################################################
SUBDIRS:
  üìÅ assets/
  üìÅ bat/
  üìÅ config/
  üìÅ engine/
  üìÅ ui/

FILES:
  üìÑ .export_version.txt (2 bytes)
  üìÑ Lancer_Appium_StoryFX.bat (190 bytes)
  üìÑ Lancer_Scheduler.bat (275 bytes)
  üìÑ README.md (11 bytes)
  üìÑ Share_Ico.txt (108 bytes)
  üìÑ Start_StoryFX.bat (75 bytes)
  üêç __init__.py (0 bytes)
  üêç cleanup_ig_variant.py (1291 bytes)
  üêç cleanup_pages.py (1002 bytes)
  üìÑ kkk.txt (716 bytes)
  üìÑ locators.json (1844 bytes)
  üêç main.py (234 bytes)
  üêç print_tree.py (3494 bytes)
  üìÑ requirements.txt (135 bytes)
  üìÑ reset_adb_ports.bat (1927 bytes)
  üêç runner.py (7491 bytes)
  üêç scheduler.py (19834 bytes)
  üìÑ ui_state.json (198 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: .export_version.txt
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\.export_version.txt
============================================================================================================================================
19

============================================================================================================================================
FILE: __init__.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\__init__.py
============================================================================================================================================


============================================================================================================================================
FILE: cleanup_ig_variant.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\cleanup_ig_variant.py
============================================================================================================================================
# cleanup_ig_variant.py
# python cleanup_ig_variant.py

import json
from pathlib import Path

ROOT = Path(__file__).resolve().parent
CONFIG = ROOT / "config"

matrix_path = CONFIG / "matrix.json"
ui_state_path = ROOT / "ui_state.json"

def clean_matrix():
    if not matrix_path.exists():
        print("matrix.json introuvable.")
        return
    with matrix_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    rows = data.get("rows", [])
    for row in rows:
        row.pop("ig_variant", None)  # supprime la cl√© si pr√©sente

    with matrix_path.open("w", encoding="utf-8") as f:
        json.dump({"rows": rows}, f, ensure_ascii=False, indent=2)
    print("matrix.json nettoy√© (ig_variant supprim√©).")

def clean_ui_state():
    if not ui_state_path.exists():
        print("ui_state.json introuvable.")
        return
    with ui_state_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    if isinstance(data, dict):
        data.pop("ig_variant", None)

    with ui_state_path.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print("ui_state.json nettoy√© (ig_variant supprim√©).")

if __name__ == "__main__":
    clean_matrix()
    clean_ui_state()


============================================================================================================================================
FILE: cleanup_pages.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\cleanup_pages.py
============================================================================================================================================
# python cleanup_pages.py
import json
from pathlib import Path

ROOT = Path(__file__).resolve().parent
CONFIG = ROOT / "config"
matrix_path = CONFIG / "matrix.json"

def migrate_pages_cm_ci():
    if not matrix_path.exists():
        print("matrix.json introuvable.")
        return

    with matrix_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    rows = data.get("rows", [])
    changed = 0
    for row in rows:
        if row.get("platform") == "Facebook":
            if row.get("page") == "CM":
                row["page"] = "Cameroun"
                changed += 1
            elif row.get("page") == "CI":
                row["page"] = "C√¥te d'Ivoire"
                changed += 1

    with matrix_path.open("w", encoding="utf-8") as f:
        json.dump({"rows": rows}, f, ensure_ascii=False, indent=2)

    print(f"matrix.json : {changed} ligne(s) mises √† jour (CM/CI ‚Üí pays).")

if __name__ == "__main__":
    migrate_pages_cm_ci()


============================================================================================================================================
FILE: kkk.txt
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\kkk.txt
============================================================================================================================================
taskkill /F /IM StoryFX.exe 2>$null
Remove-Item -Recurse -Force .\dist\StoryFX -ErrorAction SilentlyContinue
Remove-Item -Recurse -Force .\build\StoryFX -ErrorAction SilentlyContinue

pyinstaller --noconfirm --clean `
  --name StoryFX `
  --windowed `
  --onedir `
  --hidden-import PySimpleGUI `
  --hidden-import psutil `
  --collect-all PySimpleGUI `
  --collect-all psutil `
  --collect-submodules ui `
  --collect-submodules engine `
  --add-data "ui;ui" `
  --add-data "engine;engine" `
  --add-data "config;config" `
  --add-data "assets;assets" `
  --add-data "runner.py;." `
  --add-data "scheduler.py;." `
  main.py

add duplication on matrix selection
auto refreh profile and matrix

============================================================================================================================================
FILE: Lancer_Appium_StoryFX.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\Lancer_Appium_StoryFX.bat
============================================================================================================================================
@echo off
title Appium StoryFX

set ANDROID_ADB_SERVER_PORT=5038
set PATH=C:\Tools\ADB_StoryFX;%PATH%

appium --allow-cors --relaxed-security --base-path /wd/hub --port 4723

pause


============================================================================================================================================
FILE: Lancer_Scheduler.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\Lancer_Scheduler.bat
============================================================================================================================================
@echo off
title StoryFX Scheduler
cd /d "%~dp0"

echo.
echo [StoryFX] Lancement du Scheduler...
echo.

REM -- Lancer scheduler.py dans une nouvelle fen√™tre ind√©pendante
start "StoryFX Scheduler" "%~dp0storyfx\.venv\Scripts\python.exe" "%~dp0storyfx\scheduler.py"


============================================================================================================================================
FILE: locators.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\locators.json
============================================================================================================================================
{
  "WhatsApp": {
    "share_entry": {
      "default": "//android.widget.TextView[@resource-id=\"com.android.intentresolver:id/text1\" and @text=\"WhatsApp¬†Business\"]"
    },
    "my_status": {
      "default": "//*[@resource-id='com.whatsapp.w4b:id/contactpicker_row_name' and contains(@text,'My status')]"
    },
    "send_button": {
      "default": "//android.widget.ImageButton[@content-desc='Send']"
    }
  },
  "Facebook": {
    "share_entry": {
      "default": "XPATH_FACEBOOK_SHARE_ICON",
      "S23_Master": "XPATH_FACEBOOK_SHARE_ICON",
      "S23_IG": "XPATH_FACEBOOK_SHARE_ICON",
      "S23_FB_CM": "XPATH_FACEBOOK_SHARE_ICON",
      "S23_FB_CI": "XPATH_FACEBOOK_SHARE_ICON",
      "S23_TikTok": "XPATH_FACEBOOK_SHARE_ICON",
      "A16": "XPATH_FACEBOOK_SHARE_ICON",
      "G2_A16": "XPATH_FACEBOOK_SHARE_ICON",
      "A17": "XPATH_FACEBOOK_SHARE_ICON"
    }
  },
  "Instagram": {
    "share_entry": {
      "default": "XPATH_INSTAGRAM_SHARE_ICON",
      "S23_Master": "XPATH_INSTAGRAM_SHARE_ICON",
      "S23_IG": "XPATH_INSTAGRAM_SHARE_ICON",
      "S23_FB_CM": "XPATH_INSTAGRAM_SHARE_ICON",
      "S23_FB_CI": "XPATH_INSTAGRAM_SHARE_ICON",
      "S23_TikTok": "XPATH_INSTAGRAM_SHARE_ICON",
      "A16": "XPATH_INSTAGRAM_SHARE_ICON",
      "G2_A16": "XPATH_INSTAGRAM_SHARE_ICON",
      "A17": "XPATH_INSTAGRAM_SHARE_ICON"
    }
  },
  "TikTok": {
    "share_entry": {
      "default": "XPATH_TIKTOK_SHARE_ICON",
      "S23_Master": "XPATH_TIKTOK_SHARE_ICON",
      "S23_IG": "XPATH_TIKTOK_SHARE_ICON",
      "S23_FB_CM": "XPATH_TIKTOK_SHARE_ICON",
      "S23_FB_CI": "XPATH_TIKTOK_SHARE_ICON",
      "S23_TikTok": "XPATH_TIKTOK_SHARE_ICON",
      "A16": "XPATH_TIKTOK_SHARE_ICON",
      "G2_A16": "XPATH_TIKTOK_SHARE_ICON",
      "A17": "XPATH_TIKTOK_SHARE_ICON"
    }
  }
}

============================================================================================================================================
FILE: main.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\main.py
============================================================================================================================================
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

# Lancer l'app UI
import ui.app  # si ui/app.py ex√©cute l'UI au moment de l'import


============================================================================================================================================
FILE: print_tree.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\print_tree.py
============================================================================================================================================
import sys
sys.stdout.reconfigure(encoding="utf-8")

import os
from collections import Counter, defaultdict

# ‚ùå Dossiers √† ignorer (environnements & bruit)
IGNORE_DIRS = {
    ".venv",
    "venv",
    "env",
    "__pycache__",
    ".git",
    ".idea",
    ".pytest_cache",
    "node_modules",
    "dist",
    "build",
}

# (optionnel) fichiers √† ignorer
IGNORE_FILES = {
    "pyvenv.cfg",
    "CACHEDIR.TAG",
}


def _ext_of(filename: str) -> str:
    """Retourne l'extension normalis√©e (ex: '.py') ou '(no_ext)'."""
    _, ext = os.path.splitext(filename)
    ext = ext.lower().strip()
    return ext if ext else "(no_ext)"


def print_tree(root: str, max_depth: int = 50):
    root = os.path.abspath(root)
    print(f"üìÅ {os.path.basename(root)}/")

    # --- Stats globales ---
    python_files: list[str] = []
    other_files: list[str] = []
    ext_counter: Counter[str] = Counter()
    total_files = 0
    total_dirs = 0

    for dirpath, dirnames, filenames in os.walk(root):
        # üî• filtrage des dossiers AVANT descente r√©cursive
        dirnames[:] = [d for d in dirnames if d not in IGNORE_DIRS]

        rel = os.path.relpath(dirpath, root)
        depth = 0 if rel == "." else rel.count(os.sep) + 1

        if depth > max_depth:
            dirnames[:] = []
            continue

        indent = "  " * depth

        # ne pas r√©-afficher la racine
        if depth > 0:
            print(f"{indent}üìÅ {os.path.basename(dirpath)}/")
            total_dirs += 1  # ‚úÖ on compte ce dossier (sous-dossier)
        else:
            # ‚úÖ racine compt√©e comme dossier aussi
            total_dirs += 1

        dirnames.sort()
        filenames.sort()

        for fn in filenames:
            if fn in IGNORE_FILES:
                continue

            fp = os.path.join(dirpath, fn)

            # Taille fichier (optionnel, comme avant)
            try:
                size = os.path.getsize(fp)
            except Exception:
                size = -1

            print(f"{indent}  üìÑ {fn} ({size} bytes)")

            # --- Stats fichiers ---
            total_files += 1
            rel_fp = os.path.relpath(fp, root)  # chemin relatif pour le rapport
            ext = _ext_of(fn)
            ext_counter[ext] += 1

            if ext == ".py":
                python_files.append(rel_fp)
            else:
                other_files.append(rel_fp)

    # --- Rapport final ---
    print("\n" + "=" * 60)
    print("üìå RAPPORT FINAL")
    print("=" * 60)

    print(f"üìÇ Total dossiers : {total_dirs}")
    print(f"üìÑ Total fichiers : {total_files}")

    print("\nüêç Fichiers Python (.py) :")
    if python_files:
        for p in python_files:
            print(f"  - {p}")
    else:
        print("  (aucun)")

    print("\nüß© Autres fichiers (non .py) :")
    if other_files:
        for p in other_files:
            print(f"  - {p}")
    else:
        print("  (aucun)")

    # Bonus : r√©sum√© par extension (tr√®s pratique)
    print("\nüìä R√©partition par extension :")
    for ext, cnt in sorted(ext_counter.items(), key=lambda x: (-x[1], x[0])):
        print(f"  - {ext}: {cnt}")

    print("=" * 60)


if __name__ == "__main__":
    # ‚úÖ Toujours le dossier o√π se trouve le script (ex: SendFX)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    print_tree(script_dir, max_depth=50)


============================================================================================================================================
FILE: README.md
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\README.md
============================================================================================================================================
# StoryFX



============================================================================================================================================
FILE: requirements.txt
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\requirements.txt
============================================================================================================================================
Appium-Python-Client==3.1.1
selenium==4.25.0
pillow==10.3.0
psutil==5.9.8
requests==2.32.3
colorama==0.4.6
PySimpleGUI==5.0.8.3


============================================================================================================================================
FILE: reset_adb_ports.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\reset_adb_ports.bat
============================================================================================================================================
@echo off
title RESET COMPLET ADB (5037 / 5038)

echo =====================================================
echo üî• RESET TOTAL DES PORTS ADB (Fix ADB 5037 / 5038)
echo =====================================================

echo.
echo üìå 1) Suppression variable ANDROID_ADB_SERVER_PORT
setx ANDROID_ADB_SERVER_PORT "" >nul
setx ANDROID_ADB_SERVER_PORT "" /M >nul

echo.
echo üìå 2) Purge compl√®te du registre (toutes les zones possibles)
reg delete "HKCU\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\.DEFAULT\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\S-1-5-18\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\S-1-5-19\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\S-1-5-20\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1

echo.
echo üìå 3) V√©rification que la variable est supprim√©e
set ANDROID_ADB_SERVER_PORT
echo (Elle doit √™tre ABSENTE)

echo.
echo üìå 4) Fermeture de TOUS les adb.exe actifs
taskkill /IM adb.exe /F >nul 2>&1

echo.
echo üìå 5) Nettoyage du PATH (ADB StoryFX ne doit PAS passer en premier)
setx PATH "%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SystemRoot%\System32\WindowsPowerShell\v1.0\;" /M >nul

echo.
echo üìå 6) Red√©marrage ADB Android Studio sur port 5037
"C:\Users\lilgu\AppData\Local\Android\Sdk\platform-tools\adb.exe" kill-server
"C:\Users\lilgu\AppData\Local\Android\Sdk\platform-tools\adb.exe" start-server

echo.
echo üìå 7) V√©rification du port actif :
netstat -ano | findstr :5037
netstat -ano | findstr :5038

echo.
echo =====================================================
echo ‚úÖ FINI : RED√âMARRE TON PC MAINTENANT
echo =====================================================
pause


============================================================================================================================================
FILE: runner.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\runner.py
============================================================================================================================================
# -*- coding: utf-8 -*-
"""
Runner CLI ‚Äî lance un engine (intro | multi | intro_multi)
Avec support complet :
- Facebook (pays + page_name)
- Instagram
- TikTok
- WhatsApp
"""

import json, time
import argparse
from pathlib import Path

from engine import engine_intro, engine_multi

from datetime import datetime
import os

def get_display_time() -> str:
    """Heure √† afficher dans les logs (rattrapage ou r√©elle)."""
    t = os.environ.get("STORYFX_TIME")
    if t:
        return t
    return datetime.now().strftime("%H:%M:%S")

def log_run_header(label):
    now = get_display_time()   # au lieu de datetime.now().strftime(...)
    print("")
    print(
        f"[StoryFX] [RUN] {now} | Device = {args.profile} | "
        f"engine = {args.engine} | platform = {args.platform} | step = {label}"
    )


# ---------- Utils ----------
def load_json(path: str | Path):
    p = Path(path)
    with p.open("r", encoding="utf-8") as f:
        return json.load(f)


def die(msg: str, code: int = 2):
    print(f"[runner] {msg}")
    raise SystemExit(code)

def run_with_retries(label, fn, max_attempts=5):
    """
    Ex√©cute fn() avec retries :
    - jusqu‚Äô√† max_attempts tentatives
    - d√©lais progressifs : 5s, 10s, 20s, 40s, 80s
    - NE RELANCE PAS l‚Äôexception √† la fin : retourne juste 1 en cas d‚Äô√©chec.
    """
    global args  # ‚¨ÖÔ∏è OBLIGATOIRE pour utiliser args.profile / args.engine / args.platform

    last_exc = None

    for attempt in range(1, max_attempts + 1):
        # --- LOG RUN HEADER ---
        from datetime import datetime

        logical_time = os.environ.get("STORYFX_TIME")
        if logical_time:
            now = logical_time
        else:
            now = datetime.now().strftime("%H:%M:%S")

        print("")
        print(f"[StoryFX] [RUN] {now} | Device = {args.profile} | engine = {args.engine} | platform = {args.platform}")

        print(f"[StoryFX] [{label}] tentative {attempt}/{max_attempts}...")

        try:
            rc = fn()
            if rc == 0:
                print(f"[StoryFX] [{label}] OK √† la tentative {attempt}.")
                return 0
            else:
                print(f"[StoryFX] [{label}] retour rc={rc} (tentative {attempt}).")
        except Exception as e:
            last_exc = e
            print(f"[StoryFX] [{label}] ERREUR √† la tentative {attempt}: {e!r}")

        # Si ce n‚Äôest pas la derni√®re tentative ‚Üí on attend (5, 10, 20, 40, 80)
        if attempt < max_attempts:
            delay = 5 * (2 ** (attempt - 1))  # 1‚Üí5s, 2‚Üí10s, 3‚Üí20s, 4‚Üí40s, 5‚Üí80s
            print(f"[StoryFX] [{label}] nouvelle tentative dans {delay} s...")
            time.sleep(delay)

    print(f"[StoryFX] [{label}] √©chec apr√®s {max_attempts} tentatives.")
    if last_exc:
        print(f"[StoryFX] [{label}] derni√®re exception : {last_exc!r}")

    # On NE relance pas l‚Äôexception ‚Üí le process se termine proprement avec code 1
    return 1

# ---------- CLI ----------
def build_argparser() -> argparse.ArgumentParser:
    ap = argparse.ArgumentParser()

    # profils.json
    ap.add_argument(
        "--profiles",
        default=str(Path(__file__).with_name("config").joinpath("profiles.json")),
        help="Chemin vers config/profiles.json",
    )
    ap.add_argument("--profile", required=True, help="Cl√© du profil")

    # Engines
    ap.add_argument(
        "--engine",
        choices=["intro", "multi", "intro_multi"],
        required=True,
        help="Engine √† utiliser",
    )

    ap.add_argument("--album", required=True, help="Album (intro)")
    ap.add_argument("--album2", help="Album (multi pour intro_multi)")
    ap.add_argument("--count", type=int, default=11, help="Count pour multi")

    # Plateforme + options
    ap.add_argument(
        "--platform",
        choices=["WhatsApp", "Facebook", "Instagram", "TikTok"],
        default="WhatsApp",
    )
    ap.add_argument("--page", help="[Facebook] Pays (ex : Cameroun, C√¥te d‚ÄôIvoire)")
    ap.add_argument("--page-name", dest="page_name", help="[Facebook] Nom de la page")

    # 2 syntaxes accept√©es pour page_name : --page-name et --page_name
    ap.add_argument(
        "--page_name",
        dest="page_name",
        type=str,
        help=argparse.SUPPRESS,
    )
    return ap


args = None

# ---------- Main ----------
def main():
    # print(f"[StoryFX] [{label}] tentative {attempt}/{max_attempts}...")

    global args
    args = build_argparser().parse_args()

    # --- Chargement du profil ---
    profiles = load_json(args.profiles)
    if "profiles" not in profiles:
        die("Le fichier profiles.json ne contient pas la cl√© 'profiles'.")

    if args.profile not in profiles["profiles"]:
        die(f"Profil introuvable : {args.profile}")

    base_profile = profiles["profiles"][args.profile]
    profile = dict(base_profile)
    profile["profile_name"] = args.profile  # m√©moriser le nom du profil

    # --- Construction platform_opts ---
    platform_opts = {
        "page": args.page,          # Pays
        "page_name": args.page_name # Nom de la page
    }
    rc = 1

    # ========== ENGINE INTRO ==========
    if args.engine == "intro":

        def call_intro():
            try:
                return engine_intro.run(
                    profile,
                    args.album,
                    platform=args.platform,
                    platform_opts=platform_opts,
                )
            except TypeError:
                # Compat anciennes signatures
                return engine_intro.run(profile, args.album)

        rc = run_with_retries("intro", call_intro, max_attempts=5)

    # ========== ENGINE MULTI ==========
    elif args.engine == "multi":

        def call_multi():
            try:
                return engine_multi.run(
                    profile,
                    args.album,
                    args.count,
                    platform=args.platform,
                    platform_opts=platform_opts,
                )
            except TypeError:
                # Compat anciennes signatures
                return engine_multi.run(profile, args.album, args.count)

        rc = run_with_retries("multi", call_multi, max_attempts=5)

    # ========== ENGINE INTRO + MULTI ==========
    elif args.engine == "intro_multi":

        album_intro = args.album
        album_multi = args.album2 or args.album

        def call_intro():
            try:
                return engine_intro.run(
                    profile,
                    album_intro,
                    platform=args.platform,
                    platform_opts=platform_opts,
                )
            except TypeError:
                return engine_intro.run(profile, album_intro)

        def call_multi():
            try:
                return engine_multi.run(
                    profile,
                    album_multi,
                    args.count,
                    platform=args.platform,
                    platform_opts=platform_opts,
                )
            except TypeError:
                return engine_multi.run(profile, album_multi, args.count)

        rc_intro = run_with_retries("intro", call_intro, max_attempts=5)
        if rc_intro != 0:
            rc = rc_intro
        else:
            rc_multi = run_with_retries("multi", call_multi, max_attempts=5)
            rc = rc_multi

    print(f"[runner] Termin√© avec code {rc}")
    raise SystemExit(rc)


if __name__ == "__main__":
    main()


============================================================================================================================================
FILE: scheduler.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\scheduler.py
============================================================================================================================================
# -*- coding: utf-8 -*-
"""
StoryFX Scheduler
-----------------
- Lit profiles.json, systems.json, matrix.json
- Applique l'offset de chaque profil aux heures de base
- D√©clenche runner.py avec:
    --profile, --engine, --album, [--count]
    --platform, [--page], [--page_name]
- Anti double-lancement: un job ne part qu'une fois par minute.

En plus:
- build_planning() : renvoie la liste compl√®te des programmations
  (utile pour l'onglet "Programmation" du front-end).
"""
import os
import json
import time
import sys
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
from typing import Iterator, Dict, Any, List, Tuple
from ui.ui_devices import ensure_appium_running

RATTRAPAGE_DONE = False
PROJECT_NAME = "StoryFX"  # anciennement WA-HUB

BASE_DIR = Path(__file__).resolve().parent
CONFIG_DIR = BASE_DIR / "config"
PROFILES_PATH = CONFIG_DIR / "profiles.json"
SYSTEMS_PATH = CONFIG_DIR / "systems.json"
MATRIX_PATH = CONFIG_DIR / "matrix.json"
ALBUMS_PATH   = CONFIG_DIR / "albums.json"   # üÜï
CLOCK_PATH   = CONFIG_DIR / "scheduler_clock.json"  # üÜï mode auto / manuel

# --- Gestion √©criture heure scheduler_clock.json ---
CLOCK_PATH = CONFIG_DIR / "scheduler_clock.json"

def write_clock_state(mode: str, hhmm: str | None = None):
    """
    Sauvegarde le mode de temps dans config/scheduler_clock.json.
    """
    data = {"mode": mode}
    if mode == "manual" and hhmm:
        data["time"] = hhmm

    try:
        CLOCK_PATH.parent.mkdir(parents=True, exist_ok=True)
        with CLOCK_PATH.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[Scheduler] Erreur write_clock_state : {e}")


# ---------- Utils JSON ----------

def load_json(path: Path) -> dict:
    """Charge un fichier JSON en UTF‚Äë8, ou {} si probl√®me."""
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"[{PROJECT_NAME}] ‚ö† Erreur lecture {path.name}: {e}")
        return {}


def hhmm_add_offset(hhmm: str, minutes: int) -> str:
    """Ajoute un d√©calage (en minutes) √† une heure HH:MM."""
    try:
        h, m = map(int, hhmm.split(":"))
        t = datetime(2000, 1, 1, h, m) + timedelta(minutes=minutes)
        return f"{t.hour:02d}:{t.minute:02d}"
    except Exception:
        # Fallback si format inattendu
        return hhmm


def run_cmd(cmd_list: List[str]) -> None:
    """Ex√©cute une commande syst√®me de mani√®re fiable (sans shell=True)."""
    try:
        subprocess.run(cmd_list, check=False)
    except Exception as e:
        print(f"[{PROJECT_NAME}] ‚ö† Erreur lors de l'ex√©cution de la commande : {e}")


def load_clock_state() -> dict:
    """
    Charge le mode de temps du scheduler.

    Format attendu dans config/scheduler_clock.json :

      {"mode": "auto"}
    ou
      {"mode": "manual", "time": "13:00"}   # heure virtuelle HH:MM en 24h

    Si le fichier n'existe pas ou est invalide ‚Üí mode auto.
    """
    if not CLOCK_PATH.exists():
        return {"mode": "auto"}

    try:
        with CLOCK_PATH.open("r", encoding="utf-8") as f:
            data = json.load(f)
        if not isinstance(data, dict):
            return {"mode": "auto"}

        mode = data.get("mode", "auto")
        if mode not in ("auto", "manual"):
            mode = "auto"

        hhmm = data.get("time")
        if not isinstance(hhmm, str):
            hhmm = None

        return {"mode": mode, "time": hhmm}
    except Exception:
        # En cas de souci, on repasse en auto
        return {"mode": "auto"}

def get_logical_minute() -> str:
    """
    Retourne la minute logique HH:MM utilis√©e par le scheduler.

    - mode auto   ‚Üí heure r√©elle du PC
    - mode manual ‚Üí horloge virtuelle qui d√©marre √† 'time'
                    puis avance d'1 minute pour chaque minute r√©elle.
    """
    # Initialisation des attributs "statiques" de la fonction
    if not hasattr(get_logical_minute, "_logical_time"):
        get_logical_minute._logical_time = None   # datetime virtuelle
        get_logical_minute._last_real = None      # derni√®re heure r√©elle lue
        get_logical_minute._last_state = None     # (mode, hhmm) pour d√©tecter les changements

    state = load_clock_state()
    mode = state.get("mode", "auto")
    hhmm = (state.get("time") or "").strip()

    # ----- MODE AUTO : on utilise l'heure du PC, et on reset l'horloge virtuelle -----
    if mode != "manual":
        get_logical_minute._logical_time = None
        get_logical_minute._last_real = None
        get_logical_minute._last_state = None
        return datetime.now().strftime("%H:%M")

    # ----- MODE MANUEL : horloge virtuelle -----
    key = (mode, hhmm)

    # (1) Premi√®re fois, ou bien l'utilisateur a chang√© l'heure manuelle :
    #     on r√©-initialise l'horloge virtuelle √† hh:mm
    if get_logical_minute._logical_time is None or get_logical_minute._last_state != key:
        try:
            h_str, m_str = hhmm.split(":")
            h = int(h_str)
            m = int(m_str)
            if not (0 <= h <= 23 and 0 <= m <= 59):
                raise ValueError
        except Exception:
            # si l'heure dans le JSON est cass√©e, on part sur l'heure PC
            now = datetime.now()
            h, m = now.hour, now.minute

        get_logical_minute._logical_time = datetime(2000, 1, 1, h, m)
        get_logical_minute._last_real = datetime.now()
        get_logical_minute._last_state = key

    else:
        # (2) On fait avancer l'horloge virtuelle selon le temps r√©el √©coul√©
        now_real = datetime.now()
        delta = now_real - get_logical_minute._last_real
        secs = int(delta.total_seconds())

        if secs >= 60:
            minutes = secs // 60
            get_logical_minute._logical_time += timedelta(minutes=minutes)
            get_logical_minute._last_real += timedelta(seconds=minutes * 60)

    t = get_logical_minute._logical_time
    return f"{t.hour:02d}:{t.minute:02d}"

# ---------- Chargement / planning ----------

def load_configs() -> Tuple[dict, dict, dict, dict]:
    """Charge profiles / systems / matrix √† partir du dossier config."""
    profiles = load_json(PROFILES_PATH)
    systems  = load_json(SYSTEMS_PATH)
    matrix   = load_json(MATRIX_PATH)
    albums   = load_json(ALBUMS_PATH)
    return profiles, systems, matrix, albums


def iter_jobs(profiles: dict, systems: dict, matrix: dict, albums: dict) -> Iterator[Dict[str, Any]]:
    """
    G√©n√®re toutes les programmations possibles.

    Un job contient maintenant :
      - album_intro : album d'intro (engine intro / intro+multi)
      - album_multi : album multi (engine multi / intro+multi)
      - count       : nombre d'images, d√©riv√© de albums.json quand c'est du multi
    """
    # On pr√©pare un dict {nom_album: config_album} pour aller vite
    albums_dict = {a.get("name"): a for a in albums.get("albums", [])}

    for dev_name, dev in profiles.get("profiles", {}).items():
        if not dev.get("enabled", True):
            continue  # üî• Skip ce device

        offset = int(dev.get("offset_minutes", 0))

        for row in matrix.get("rows", []):
            if row.get("device") != dev_name:
                continue

            sys_key = row["system"]
            sys_conf = systems.get("systems", {}).get(sys_key)
            if sys_conf is None:
                print(f"[{PROJECT_NAME}] ‚ö† Syst√®me '{sys_key}' introuvable dans systems.json.")
                continue

            # Compat : systems["systems"][key] peut √™tre soit une liste,
            # soit un dict {"times": [...]}
            if isinstance(sys_conf, dict):
                times = sys_conf.get("times", [])
            else:
                times = sys_conf

            engine = row.get("engine") or ""
            album_intro = row.get("album")  or ""
            album_multi = row.get("album2") or ""
            raw_count   = row.get("count", 0) or 0
            platform    = row.get("platform", "WhatsApp")
            page        = row.get("page")
            page_name   = row.get("page_name")


            # --- D√©terminer le count r√©el ---
            count = int(raw_count)
            # Pour multi et intro+multi, on essaie de prendre count_per_post de l'album multi
            if engine in ("multi", "intro+multi"):
                multi_name = album_multi or album_intro
                cfg = albums_dict.get(multi_name or "")
                if cfg:
                    c = cfg.get("count_per_post")
                    if c:
                        count = int(c)

            for base_time in times:
                t_effective = hhmm_add_offset(base_time, offset)
                yield {
                    "device": dev_name,
                    "system": sys_key,
                    "engine": engine,
                    "album_intro": album_intro,
                    "album_multi": album_multi,
                    "count": count,
                    "platform": platform,
                    "page": page,         # Pays
                    "page_name": page_name,  # Page
                    "base_time": base_time,
                    "offset_minutes": offset,
                    "time_effective": t_effective,
                }

def build_planning() -> List[List[str]]:
    """
    Construit un tableau lisible pour la GUI.
    Chaque ligne = [device, system, engine,
                    album_intro, album_multi,
                    platform, count, base_time,
                    offset, time_effective,
                    page, page_name, ig_variant]
    """
    profiles, systems, matrix, albums = load_configs()
    table: List[List[str]] = []

    for job in iter_jobs(profiles, systems, matrix, albums):
        table.append([
            job["device"],
            job["system"],
            job.get("engine") or "",
            job.get("album_intro") or "",
            job.get("album_multi") or "",
            job.get("platform") or "",
            str(job.get("count") or ""),
            job["base_time"],
            f"{job['offset_minutes']} min",
            job["time_effective"],
            job.get("page") or "",       # Pays
            job.get("page_name") or "",  # Nom de la page
        ])


    # Tri par heure effective puis device
    table.sort(key=lambda r: (r[9], r[0], r[1]))
    return table


def run_manual_catchup(state: dict) -> None:
    """
    Ex√©cute TOUTES les programmations entre:
        start_time ‚â§ job_time ‚â§ heure r√©elle (au moment du test)
    Et refait autant de passes que n√©cessaire jusqu'√† ne rater AUCUN job.
    """

    start_hhmm = state.get("time")
    if not start_hhmm:
        return

    start_min = int(start_hhmm.replace(":", ""))  # HHMM ‚Üí int

    profiles, systems, matrix, albums = load_configs()

    # Pr√©-tri global des jobs selon leur time_effective
    all_jobs = sorted(
        iter_jobs(profiles, systems, matrix, albums),
        key=lambda j: j["time_effective"],
    )

    print(f"[{PROJECT_NAME}] Rattrapage manuel initial‚Ä¶ point de d√©part = {start_hhmm}")

    already_run = set()  # √©viter double ex√©cution

    while True:
        now_hm = datetime.now().strftime("%H:%M")
        now_min = int(now_hm.replace(":", ""))

        print(f"[{PROJECT_NAME}] Fen√™tre rattrapage : {start_hhmm} ‚Üí {now_hm}")

        did_run_something = False

        for job in all_jobs:
            job_time = job["time_effective"]
            job_min = int(job_time.replace(":", ""))

            # Fen√™tre dynamique :
            if not (start_min <= job_min <= now_min):
                continue

            # D√©j√† ex√©cut√© ?
            key = (job["device"], job["system"], job_min)
            if key in already_run:
                continue

            # ---- LANCEMENT DU JOB ----
            # Construire commande runner
            engine_ui = job["engine"] or ""
            engine_cli = "intro_multi" if engine_ui == "intro+multi" else engine_ui

            cmd = [
                sys.executable or "python",
                str(BASE_DIR / "runner.py"),
                "--profiles", str(PROFILES_PATH),
                "--profile", job["device"],
                "--engine", engine_cli,
                "--platform", job["platform"],
            ]

            if engine_cli == "intro":
                cmd += ["--album", job["album_intro"]]
            elif engine_cli == "multi":
                cmd += ["--album", job["album_multi"], "--count", str(job["count"])]
            elif engine_cli == "intro_multi":
                cmd += [
                    "--album", job["album_intro"],
                    "--album2", job["album_multi"],
                    "--count", str(job["count"]),
                ]

            if job.get("page"):
                cmd += ["--page", job["page"]]
            if job.get("page_name"):
                cmd += ["--page_name", job["page_name"]]


            timestamp = job_time + ":00"
            os.environ["STORYFX_TIME"] = timestamp

            print(
                f"[{PROJECT_NAME}] {timestamp} ‚Üí Rattrapage : Lancement {job['device']} | "
                f"Sys={job['system']} | Plat={job['platform']} | Engine={engine_cli}"
            )
            print("   CMD:", " ".join(cmd))

            run_cmd(cmd)
            already_run.add(key)
            did_run_something = True

        # ---- FIN DE PASSE ----
        if not did_run_something:
            break   # plus rien √† rattraper ‚Üí 100% OK

        # On boucle encore une fois car de nouveaux jobs peuvent devenir √©ligibles
        print(f"[{PROJECT_NAME}] V√©rification jobs suppl√©mentaires‚Ä¶")

    # ---- SORTIE ----
    final_now = datetime.now().strftime("%H:%M")
    write_clock_state("auto", final_now)
    print(f"[{PROJECT_NAME}] Rattrapage termin√© d√©finitivement ‚Üí retour auto ({final_now})")

# --- Convertit HH:MM en minutes absolues + gestion du passage minuit ---
def to_minutes(hhmm: str) -> int:
    """Retourne un entier minutes, compatible cross-journ√©e.

    Exemple :
        - Maintenant = 00:48 (48)
        - Heure de d√©part = 15:00 ‚Üí doit devenir 15:00 de la veille ‚áí 15*60 - 24*60 = -540
    """
    h, m = map(int, hhmm.split(":"))
    return h * 60 + m


def normalize_span(start_min: int, real_min: int) -> Tuple[int, int]:
    """Corrige le passage minuit entre START et REAL.

    Exemple :
        start = 15:00 ‚Üí 900
        real = 00:48 ‚Üí 48
    ‚áí Le scheduler doit comprendre : start = 900 - 1440 = -540
    """
    if real_min < start_min:
        # passage dans la nuit ‚Üí d√©caler start au jour pr√©c√©dent
        start_min -= 1440
    return start_min, real_min

# ---------- Boucle scheduler (mode "service") ----------

def scheduler_loop() -> None:
    """
    Boucle infinie :
      - calcule l'heure courante logique (auto ou manuel)
      - parcourt les jobs et d√©clenche ceux dont l'heure correspond
      - g√®re le rattrapage
      - transmet l'heure logique au runner via STORYFX_TIME
    """

    global RATTRAPAGE_DONE
    RATTRAPAGE_DONE = False

    # üî• Nouvelle version PRO : d√©marrage Appium (ADB StoryFX + attente)
    print("[StoryFX] V√©rification Appium‚Ä¶")
    ensure_appium_running()
    print(f"[{PROJECT_NAME}] Scheduler pr√™t ‚úÖ")

    last_fired = set()


    while True:

        state = load_clock_state()
        mode = state.get("mode", "auto")

        # ---------------------------------------------------------
        # üî• 1) RATTRAPAGE INITIAL AU LANCEMENT DU SCHEDULER
        # ---------------------------------------------------------
        if mode == "manual" and not RATTRAPAGE_DONE:
            run_manual_catchup(state)
            RATTRAPAGE_DONE = True

        # Heure r√©elle
        now_real = datetime.now().strftime("%H:%M")

        # Heure logique (auto ou manuel)
        logical_hm = get_logical_minute()

        # Heure affich√©e envoy√©e au runner
        if mode == "manual" and logical_hm < now_real:
            display_time = logical_hm + ":00"
        else:
            display_time = datetime.now().strftime("%H:%M:%S")

            if mode == "manual" and not RATTRAPAGE_DONE:
                print(f"[{PROJECT_NAME}] Rattrapage termin√© ‚Üí retour √† l‚Äôheure r√©elle")
                RATTRAPAGE_DONE = True

        os.environ["STORYFX_TIME"] = display_time

        # Charger les donn√©es
        profiles, systems, matrix, albums = load_configs()

        # Conversion minutes (avec gestion minuit)
        logical_min = to_minutes(logical_hm)
        real_min = to_minutes(now_real)

        if mode == "manual":
            start_min = to_minutes(state["time"])
            start_min, real_min = normalize_span(start_min, real_min)

        # --- LANCEMENT DES JOBS ---
        for job in iter_jobs(profiles, systems, matrix, albums):

            job_hm = job["time_effective"]
            job_min = to_minutes(job_hm)

            # Gestion passage minuit job <-> start
            if mode == "manual" and job_min < start_min:
                job_min += 1440

            # --- LOGIQUE PRO du rattrapage ---
            if mode == "manual":

                # 1) JOB doit √™tre dans [start_min ‚Üí real_min]
                if not (start_min <= job_min <= real_min):
                    continue

                # 2) JOB lanc√© seulement quand logical == job
                if job_min != logical_min:
                    continue

            else:
                # MODE AUTO
                if job_hm != logical_hm:
                    continue

            # --- ANTI DOUBLE-LANCEMENT ---
            guard_key = (job_hm, job["device"], job["system"])
            if guard_key in last_fired:
                continue
            last_fired.add(guard_key)

            # --- EX√âCUTER LE JOB ---
            print(f"[{PROJECT_NAME}] {display_time} ‚Üí Lancement {job['device']} | Sys={job['system']} | Plat={job['platform']}")

            # --- AVANT de construire la commande ---
            engine_ui = job["engine"] or ""
            engine_cli = "intro_multi" if engine_ui == "intro+multi" else engine_ui

            cmd = [
                sys.executable, str(BASE_DIR / "runner.py"),
                "--profiles", str(PROFILES_PATH),
                "--profile", job["device"],
                "--engine", engine_cli,
                "--platform", job["platform"],
            ]

            if engine_cli == "intro":
                cmd += ["--album", job["album_intro"]]
            elif engine_cli == "multi":
                cmd += ["--album", job["album_multi"], "--count", str(job["count"])]
            elif engine_cli == "intro_multi":
                cmd += [
                    "--album", job["album_intro"],
                    "--album2", job["album_multi"],
                    "--count", str(job["count"]),
                ]

            # --- EX√âCUTER LE JOB ---
            ensure_appium_running()  # ‚Üê ajoute ceci ici

            print(
                f"[{PROJECT_NAME}] {display_time} ‚Üí Lancement {job['device']} | Sys={job['system']} | Plat={job['platform']}")

            run_cmd(cmd)

        # --- FIN RATTRAPAGE : BASCULE EN MODE AUTO ---
        if mode == "manual" and logical_min >= real_min:
            print(f"[{PROJECT_NAME}] Rattrapage termin√© d√©finitivement ‚Üí retour auto")
            write_clock_state("auto", now_real)
            RATTRAPAGE_DONE = True

        time.sleep(1)

# ---------- Entr√©es CLI ----------

def main() -> None:
    """
    Mode console :
      python scheduler.py
    ‚Üí lance la boucle infinie.
    """
    try:
        scheduler_loop()
    except KeyboardInterrupt:
        print(f"\n[{PROJECT_NAME}] Scheduler arr√™t√© manuellement.")


if __name__ == "__main__":
    main()


============================================================================================================================================
FILE: Share_Ico.txt
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\Share_Ico.txt
============================================================================================================================================
//android.widget.TextView[@resource-id="com.android.intentresolver:id/text1" and @text="WhatsApp¬†Business"]

============================================================================================================================================
FILE: Start_StoryFX.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\Start_StoryFX.bat
============================================================================================================================================
@echo off
cd /d "%~dp0"
call .\.venv\Scripts\activate
python ui\app.py


============================================================================================================================================
FILE: ui_state.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui_state.json
============================================================================================================================================
{
  "profile": "S23_TikTok",
  "engine": "intro+multi",
  "album_intro": "La Promotion Finit",
  "album_multi": "T√©moignages JK",
  "platform": "WhatsApp",
  "page": "",
  "page_name": ""
}


############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\assets
RELATIVE: assets
############################################################################################################################################
SUBDIRS: (none)

FILES:
  üêç create_error_sound.py (637 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: create_error_sound.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\assets\create_error_sound.py
============================================================================================================================================
import wave
import struct
import math
import os

sample_rate = 44100
duration = 0.6
frequency = 880.0
amplitude = 0.5

num_samples = int(sample_rate * duration)

output_path = "storyfx_error_alert.wav"

with wave.open(output_path, "w") as wav_file:
    wav_file.setnchannels(1)
    wav_file.setsampwidth(2)
    wav_file.setframerate(sample_rate)

    for i in range(num_samples):
        t = i / sample_rate
        value = int(amplitude * 32767.0 * math.sin(2 * math.pi * frequency * t))
        wav_file.writeframesraw(struct.pack("<h", value))

print("OK ! Fichier g√©n√©r√© :", os.path.abspath(output_path))



############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat
RELATIVE: bat
############################################################################################################################################
SUBDIRS: (none)

FILES:
  üìÑ Lancer_StoryFX.bat (224 bytes)
  üìÑ Stop_StoryFX.bat (353 bytes)
  üìÑ adb_storyfx.bat (169 bytes)
  üìÑ adb_usb.bat (239 bytes)
  üìÑ start_storyfx_environment.bat (575 bytes)
  üìÑ start_storyfx_environment_old.bat (2388 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: adb_storyfx.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat\adb_storyfx.bat
============================================================================================================================================
@echo off
taskkill /IM adb.exe /F

"C:\Tools\ADB_StoryFX\adb.exe" kill-server
"C:\Tools\ADB_StoryFX\adb.exe" start-server

echo ADB StoryFX (5038) actif !
pause


============================================================================================================================================
FILE: adb_usb.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat\adb_usb.bat
============================================================================================================================================
@echo off
taskkill /IM adb.exe /F

"C:\Program Files (x86)\Android\android-sdk\platform-tools\adb.exe" kill-server
"C:\Program Files (x86)\Android\android-sdk\platform-tools\adb.exe" start-server

echo ADB USB (5037) actif !
pause


============================================================================================================================================
FILE: Lancer_StoryFX.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat\Lancer_StoryFX.bat
============================================================================================================================================
@echo off
title StoryFX - Interface
cd /d "%~dp0"

echo.
echo [StoryFX] D√©marrage de l'interface...
echo.

REM -- Lancer app.py depuis le venv StoryFX
"%~dp0storyfx\.venv\Scripts\python.exe" "%~dp0storyfx\app.py"


============================================================================================================================================
FILE: start_storyfx_environment.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat\start_storyfx_environment.bat
============================================================================================================================================
@echo off
echo ============================================
echo   RESET ENVIRONNEMENT STORYFX (ADB + APPIUM)
echo ============================================

echo [1] Kill ADB + Node...
taskkill /IM adb.exe /F >nul 2>&1
taskkill /IM node.exe /F >nul 2>&1

echo [2] Start ADB StoryFX (port 5038)...
"C:\Tools\ADB_StoryFX\adb.exe" kill-server
"C:\Tools\ADB_StoryFX\adb.exe" start-server

echo [3] Start Appium Server...
start "" appium --allow-cors --relaxed-security --base-path /wd/hub --port 4723

timeout /t 2 >nul

echo [4] Environment ready!
pause


============================================================================================================================================
FILE: start_storyfx_environment_old.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat\start_storyfx_environment_old.bat
============================================================================================================================================
@echo off
chcp 65001 >nul

echo ===============================================================
echo üî• STORYFX - RESET & AUTO-CONFIG ENVIRONNEMENT (ADB + APPIUM)
echo ===============================================================

echo.
echo [1] üîÑ Suppression variable ANDROID_ADB_SERVER_PORT (user + system)
setx ANDROID_ADB_SERVER_PORT "" >nul
setx ANDROID_ADB_SERVER_PORT "" /M >nul

echo [1b] üîÑ Suppression dans le registre (toutes localisations Windows)
reg delete "HKCU\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKLM\SYSTEM\ControlSet001\Control\Session Manager\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\.DEFAULT\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\S-1-5-18\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\S-1-5-19\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1
reg delete "HKU\S-1-5-20\Environment" /v ANDROID_ADB_SERVER_PORT /f >nul 2>&1

echo.
echo [2] üî™ Kill ADB + Node + Appium serveurs
taskkill /IM adb.exe /F >nul 2>&1
taskkill /IM node.exe /F >nul 2>&1

echo.
echo [3] üöÄ Red√©marrage ADB Android Studio (PORT 5037)
"C:\Users\lilgu\AppData\Local\Android\Sdk\platform-tools\adb.exe" kill-server
"C:\Users\lilgu\AppData\Local\Android\Sdk\platform-tools\adb.exe" start-server

echo.
echo    - V√©rification du port ADB Android Studio :
netstat -ano | findstr :5037

echo.
echo [4] üöÄ Activation ADB StoryFX (PORT 5038)
set ANDROID_ADB_SERVER_PORT=5038
"C:\Tools\ADB_StoryFX\adb.exe" kill-server
"C:\Tools\ADB_StoryFX\adb.exe" start-server

echo.
echo    - V√©rification du port StoryFX :
netstat -ano | findstr :5038

echo.
echo [5] üöÄ Lancement APPIUM configur√© pour utiliser ADB StoryFX
start "" appium --allow-cors --relaxed-security --base-path /wd/hub --port 4723 --adb-port 5038

echo.
echo [6] ‚è≥ Attente du d√©marrage APPIUM (2 sec)...
timeout /t 2 >nul

echo.
echo    - V√©rification du port Appium :
netstat -ano | findstr :4723

echo.
echo ===============================================================
echo ‚úÖ ENVIRONNEMENT STORYFX PR√äT (ADB 5037 + ADB 5038 + APPIUM 4723)
echo ===============================================================

pause


============================================================================================================================================
FILE: Stop_StoryFX.bat
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\bat\Stop_StoryFX.bat
============================================================================================================================================
@echo off
title StoryFX - Arret complet

echo [StoryFX] Fermeture complete...
echo.

taskkill /IM python.exe /F
taskkill /IM pythonw.exe /F
taskkill /IM adb.exe /F

echo.
echo [StoryFX] Tous les processus ont ete arretes.
echo.
pause


A16
adb disconnect
adb -s R58Y9054K7X tcpip 5557
adb shell ip route
adb connect 192.168.1.88:5557


############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config
RELATIVE: config
############################################################################################################################################
SUBDIRS: (none)

FILES:
  üìÑ albums.json (1045 bytes)
  üìÑ matrix.json (18411 bytes)
  üìÑ pages.json (155 bytes)
  üìÑ profiles.json (4096 bytes)
  üìÑ scheduler_clock.json (44 bytes)
  üìÑ systems.json (539 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: albums.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config\albums.json
============================================================================================================================================
{
  "albums": [
    {
      "name": "Before After",
      "kind": "multi",
      "album_size": 11,
      "count_per_post": 3
    },
    {
      "name": "La Promotion Finit",
      "kind": "intro",
      "album_size": 1,
      "count_per_post": 1
    },
    {
      "name": "Motivations Stories",
      "kind": "multi",
      "album_size": 220,
      "count_per_post": 9
    },
    {
      "name": "Advices Stories",
      "kind": "multi",
      "album_size": 115,
      "count_per_post": 5
    },
    {
      "name": "Duba√Ø Vid√©os Mar 2024",
      "kind": "multi",
      "album_size": 223,
      "count_per_post": 9
    },
    {
      "name": "Never Give Up",
      "kind": "intro",
      "album_size": 1,
      "count_per_post": 1
    },
    {
      "name": "T√©moignages JK",
      "kind": "multi",
      "album_size": 499,
      "count_per_post": 12
    },
    {
      "name": "Duba√Ø Render Mar 2024",
      "kind": "multi",
      "album_size": 387,
      "count_per_post": 11
    }
  ]
}

============================================================================================================================================
FILE: matrix.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config\matrix.json
============================================================================================================================================
{
  "rows": [
    {
      "device": "S23_TikTok",
      "platform": "TikTok",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "S23_TikTok",
      "platform": "TikTok",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "S23_TikTok",
      "platform": "TikTok",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "S23_TikTok",
      "platform": "TikTok",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "count": 11
    },
    {
      "device": "S23_TikTok",
      "platform": "TikTok",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "S23_TikTok",
      "platform": "TikTok",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "S23_TikTok",
      "system": "Before_After",
      "engine": "multi",
      "album": "",
      "album2": "Before After",
      "platform": "TikTok",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3
    },
    {
      "device": "JK650_S23",
      "platform": "WhatsApp",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "JK650_S23",
      "platform": "WhatsApp",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "JK650_S23",
      "platform": "WhatsApp",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "JK650_S23",
      "platform": "WhatsApp",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "count": 11
    },
    {
      "device": "JK650_S23",
      "platform": "WhatsApp",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "JK650_S23",
      "platform": "WhatsApp",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "JK650_S23",
      "system": "Before_After",
      "engine": "multi",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3,
      "album": "",
      "album2": "Before After"
    },
    {
      "device": "S23_IG",
      "platform": "Instagram",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "S23_IG",
      "platform": "Instagram",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "S23_IG",
      "platform": "Instagram",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "S23_IG",
      "platform": "Instagram",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "count": 11
    },
    {
      "device": "S23_IG",
      "platform": "Instagram",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "S23_IG",
      "platform": "Instagram",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "S23_IG",
      "system": "Before_After",
      "engine": "multi",
      "album": "",
      "album2": "Before After",
      "platform": "Instagram",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3
    },
    {
      "device": "S23_FB_CM",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "platform": "Facebook",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album_size": 0,
      "count": 12
    },
    {
      "device": "S23_FB_CM",
      "platform": "Facebook",
      "system": "Motivations_Stories",
      "engine": "multi",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "S23_FB_CM",
      "platform": "Facebook",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "S23_FB_CM",
      "platform": "Facebook",
      "system": "Images_Dubai",
      "engine": "multi",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "count": 11
    },
    {
      "device": "S23_FB_CM",
      "platform": "Facebook",
      "system": "Video_Dubai",
      "engine": "multi",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "S23_FB_CM",
      "platform": "Facebook",
      "system": "Advices_Stories",
      "engine": "multi",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "S23_FB_CM",
      "system": "Before_After",
      "engine": "multi",
      "album": "",
      "album2": "Before After",
      "platform": "Facebook",
      "page": "Cameroun",
      "page_name": "Jerry Kamgang",
      "album_size": 11,
      "count": 3
    },
    {
      "device": "S23_FB_CI",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "platform": "Facebook",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d‚ÄôIvoire",
      "album_size": 0,
      "count": 12
    },
    {
      "device": "S23_FB_CI",
      "platform": "Facebook",
      "system": "Motivations_Stories",
      "engine": "multi",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d‚ÄôIvoire",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "S23_FB_CI",
      "platform": "Facebook",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d‚ÄôIvoire",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "S23_FB_CI",
      "platform": "Facebook",
      "system": "Images_Dubai",
      "engine": "multi",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d‚ÄôIvoire",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "count": 11
    },
    {
      "device": "S23_FB_CI",
      "platform": "Facebook",
      "system": "Video_Dubai",
      "engine": "multi",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d‚ÄôIvoire",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "S23_FB_CI",
      "platform": "Facebook",
      "system": "Advices_Stories",
      "engine": "multi",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d‚ÄôIvoire",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "S23_FB_CI",
      "system": "Before_After",
      "engine": "multi",
      "album": "",
      "album2": "Before After",
      "platform": "Facebook",
      "page": "C√¥te d'Ivoire",
      "page_name": "Jerry Kamgang C√¥te d'Ivoire",
      "album_size": 11,
      "count": 3
    },
    {
      "device": "JK675_A16_2",
      "platform": "WhatsApp",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "JK675_A16_2",
      "platform": "WhatsApp",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "JK675_A16_2",
      "platform": "WhatsApp",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "JK675_A16_2",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 0,
      "count": 11
    },
    {
      "device": "JK675_A16_2",
      "platform": "WhatsApp",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "JK675_A16_2",
      "platform": "WhatsApp",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "JK675_A16_2",
      "system": "Before_After",
      "engine": "multi",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3,
      "album": "",
      "album2": "Before After"
    },
    {
      "device": "JK692_A17",
      "platform": "WhatsApp",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "JK692_A17",
      "platform": "WhatsApp",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9
    },
    {
      "device": "JK692_A17",
      "platform": "WhatsApp",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12
    },
    {
      "device": "JK692_A17",
      "platform": "WhatsApp",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "count": 11
    },
    {
      "device": "JK692_A17",
      "platform": "WhatsApp",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9
    },
    {
      "device": "JK692_A17",
      "platform": "WhatsApp",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5
    },
    {
      "device": "JK692_A17",
      "system": "Before_After",
      "engine": "multi",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3,
      "album": "",
      "album2": "Before After"
    },
    {
      "device": "JK677_A16",
      "platform": "WhatsApp",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK677_A16",
      "platform": "WhatsApp",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK677_A16",
      "platform": "WhatsApp",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK677_A16",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 0,
      "count": 11
    },
    {
      "device": "JK677_A16",
      "platform": "WhatsApp",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK677_A16",
      "platform": "WhatsApp",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK677_A16",
      "system": "Before_After",
      "engine": "multi",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3,
      "album": "",
      "album2": "Before After"
    },
    {
      "device": "JK657_S23+",
      "platform": "WhatsApp",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK657_S23+",
      "platform": "WhatsApp",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK657_S23+",
      "platform": "WhatsApp",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK657_S23+",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 0,
      "count": 11
    },
    {
      "device": "JK657_S23+",
      "platform": "WhatsApp",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK657_S23+",
      "platform": "WhatsApp",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK657_S23+",
      "system": "Before_After",
      "engine": "multi",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3,
      "album": "",
      "album2": "Before After"
    },
    {
      "device": "JK682_S20",
      "platform": "WhatsApp",
      "system": "Hurry+Images",
      "engine": "intro+multi",
      "album": "La Promotion Finit",
      "album2": "T√©moignages JK",
      "count": 12,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK682_S20",
      "platform": "WhatsApp",
      "system": "Motivations_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Motivations Stories",
      "count": 9,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK682_S20",
      "platform": "WhatsApp",
      "system": "Never_Give_Up+Images",
      "engine": "intro+multi",
      "album": "Never Give Up",
      "album2": "T√©moignages JK",
      "count": 12,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK682_S20",
      "system": "Images_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Render Mar 2024",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 0,
      "count": 11
    },
    {
      "device": "JK682_S20",
      "platform": "WhatsApp",
      "system": "Video_Dubai",
      "engine": "multi",
      "album": "",
      "album2": "Duba√Ø Vid√©os Mar 2024",
      "count": 9,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK682_S20",
      "platform": "WhatsApp",
      "system": "Advices_Stories",
      "engine": "multi",
      "album": "",
      "album2": "Advices Stories",
      "count": 5,
      "page": "",
      "page_name": "",
      "album_size": 0
    },
    {
      "device": "JK682_S20",
      "system": "Before_After",
      "engine": "multi",
      "platform": "WhatsApp",
      "page": "",
      "page_name": "",
      "album_size": 11,
      "count": 3,
      "album": "",
      "album2": "Before After"
    }
  ]
}

============================================================================================================================================
FILE: pages.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config\pages.json
============================================================================================================================================
{
  "pages": [
    {"country": "Cameroun", "name": "Jerry Kamgang"},
    {"country": "C√¥te d'Ivoire", "name": "Jerry Kamgang C√¥te d'Ivoire"}
  ]
}


============================================================================================================================================
FILE: profiles.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config\profiles.json
============================================================================================================================================
{
  "profiles": {
    "S23_IG": {
      "label": "S23 IG",
      "adb_serial": "RFCW20VEB4J",
      "tcpip_ip": "192.168.10.56",
      "tcpip_port": 5555,
      "device_id": "192.168.10.56:5555",
      "platform_version": "16",
      "offset_minutes": 12,
      "enabled": true,
      "appium_overrides": {},
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    },
    "S23_FB_CM": {
      "device_id": "192.168.10.56:5555",
      "platform_version": "16",
      "offset_minutes": 6,
      "tcpip_ip": "192.168.10.56",
      "tcpip_port": 5555,
      "adb_serial": "RFCW20VEB4J",
      "enabled": true
    },
    "S23_FB_CI": {
      "device_id": "192.168.10.56:5555",
      "platform_version": "16",
      "offset_minutes": 18,
      "tcpip_ip": "192.168.10.56",
      "tcpip_port": 5555,
      "adb_serial": "RFCW20VEB4J",
      "enabled": true
    },
    "S23_TikTok": {
      "device_id": "192.168.10.56:5555",
      "platform_version": "16",
      "offset_minutes": 0,
      "tcpip_ip": "192.168.10.56",
      "tcpip_port": 5555,
      "adb_serial": "RFCW20VEB4J",
      "enabled": true
    },
    "JK682_S20": {
      "enabled": true,
      "device_id": "192.168.10.69:5560",
      "platform_version": "13",
      "offset_minutes": 54,
      "adb_serial": "RF8N91GSGYW",
      "tcpip_ip": "192.168.10.69",
      "tcpip_port": 5560,
      "appium_overrides": {
        "uiautomator2ServerInstallTimeout": 180000,
        "uiautomator2ServerLaunchTimeout": 180000,
        "adbExecTimeout": 250000,
        "newCommandTimeout": 300
      },
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    },
    "JK650_S23": {
      "device_id": "192.168.10.118:5556",
      "platform_version": "16",
      "offset_minutes": 42,
      "adb_serial": "R5CX9421YKL",
      "tcpip_ip": "192.168.10.118",
      "tcpip_port": 5556,
      "enabled": true,
      "appium_overrides": {},
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    },
    "JK657_S23+": {
      "device_id": "192.168.10.56:5555",
      "platform_version": "16",
      "offset_minutes": 48,
      "adb_serial": "RFCW20VEB4J",
      "tcpip_ip": "192.168.10.56",
      "tcpip_port": 5555,
      "enabled": true,
      "appium_overrides": {},
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    },
    "JK675_A16_2": {
      "label": "A16.2",
      "adb_serial": "R58Y9054K7X",
      "tcpip_ip": "192.168.10.98",
      "tcpip_port": 5559,
      "device_id": "192.168.10.98:5559",
      "platform_version": "15",
      "offset_minutes": 24,
      "enabled": true,
      "appium_overrides": {},
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    },
    "JK677_A16": {
      "device_id": "192.168.10.213:5557",
      "platform_version": "15",
      "offset_minutes": 30,
      "adb_serial": "R58Y91061VR",
      "tcpip_ip": "192.168.10.213",
      "tcpip_port": 5557,
      "enabled": true,
      "appium_overrides": {},
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    },
    "JK692_A17": {
      "device_id": "192.168.10.35:5558",
      "platform_version": "15",
      "offset_minutes": 36,
      "adb_serial": "R58YA0VYPNV",
      "tcpip_ip": "192.168.10.35",
      "tcpip_port": 5558,
      "enabled": true,
      "appium_overrides": {},
      "gallery": {
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity"
      }
    }
  }
}

============================================================================================================================================
FILE: scheduler_clock.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config\scheduler_clock.json
============================================================================================================================================
{
  "mode": "manual",
  "time": "05:00"
}

============================================================================================================================================
FILE: systems.json
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\config\systems.json
============================================================================================================================================
{
  "systems": {
    "Hurry+Images": [
      "01:00",
      "13:00",
      "23:00"
    ],
    "Motivations_Stories": [
      "03:00",
      "11:00",
      "20:00"
    ],
    "Never_Give_Up+Images": [
      "05:00",
      "15:00"
    ],
    "Images_Dubai": [
      "07:00",
      "17:00"
    ],
    "Video_Dubai": [
      "09:00",
      "19:00"
    ],
    "Advices_Stories": [
      "10:00",
      "21:00"
    ],
    "Before_After": [
      "06:00",
      "12:00",
      "16:00",
      "22:00"
    ]
  }
}


############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\engine
RELATIVE: engine
############################################################################################################################################
SUBDIRS: (none)

FILES:
  üêç __init__.py (450 bytes)
  üêç core.py (35286 bytes)
  üêç engine_intro.py (4561 bytes)
  üêç engine_multi.py (10253 bytes)
  üêç platforms.py (24909 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: __init__.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\engine\__init__.py
============================================================================================================================================
# StoryFx/engine/__init__.py
# -*- coding: utf-8 -*-

from .core import (
    log,
    ensure_adb_connected,
    make_driver,
    open_album,
    long_press_first_thumb,
    tap_share_button,
    unlock_screen_if_needed,
    reset_gallery_home,
    start_gallery,
)

from .engine_intro import run as run_intro
from .engine_multi import run as run_multi

from .platforms import (
    pre_platform_setup,
    share_to_platform,
)


============================================================================================================================================
FILE: core.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\engine\core.py
============================================================================================================================================
# -*- coding: utf-8 -*-
"""
Core helpers partag√©s par les engines StoryFX.
Centralise ADB / Appium + actions r√©utilisables dans la Galerie.
"""
from ui.ui_devices import ensure_appium_running
import time
import subprocess
import traceback
import json                    # ‚úÖ AJOUTER CETTE LIGNE
from typing import Optional
import sys
import os
from datetime import datetime

import re

import winsound

from appium import webdriver
from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.common.action_chains import ActionChains

from appium.webdriver.common.appiumby import AppiumBy
from appium.webdriver.extensions.android.nativekey import AndroidKey



from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from appium.webdriver.common.touch_action import TouchAction
from pathlib import Path  # en haut du fichier si pas d√©j√† import√©
try:
    from appium.options.android import UiAutomator2Options
except Exception:
    UiAutomator2Options = None

ADB_PATH = r"C:\Tools\ADB_StoryFX\adb.exe"
ADB_ENV = os.environ.copy()
ADB_ENV["ANDROID_ADB_SERVER_PORT"] = "5038"


def clear_popups_and_go_home(driver):
    """Nettoie les popups (USSD/MMI, rappels‚Ä¶) puis revient √† l'accueil."""

    # 1) Essayer de cliquer sur un bouton 'OK' / 'Dismiss' si pr√©sent
    try:
        candidates = driver.find_elements(
            AppiumBy.ANDROID_UIAUTOMATOR,
            'new UiSelector().textContains("OK")'
        )
        if candidates:
            candidates[0].click()
    except Exception:
        pass

    # 2) Envoyer plusieurs BACK pour √™tre s√ªr de fermer tous les overlays
    for _ in range(3):
        try:
            driver.press_keycode(AndroidKey.BACK)
        except Exception:
            try:
                driver.back()
            except Exception:
                break
        time.sleep(0.2)

    # 3) HOME pour revenir √† la page d'accueil
    try:
        driver.press_keycode(AndroidKey.HOME)
    except Exception:
        pass


def open_gallery(driver):
    """Ouvre la galerie Samsung en partant de l'accueil."""
    driver.activate_app("com.sec.android.gallery3d")

def adb_swipe_unlock(device_id: str):
    """
    D√©verrouille l'√©cran via ADB pour les lockscreens du type 'Swipe to open'.
    - R√©veille l'√©cran
    - R√©cup√®re la r√©solution (wm size)
    - Fait un swipe bas -> haut au centre de l'√©cran
    """
    device_id = (device_id or "").strip()
    if not device_id:
        return

    try:
        log(f"[Screen][ADB] Tentative de swipe unlock sur {device_id}...")

        # 1) R√©veiller l'√©cran (KEYCODE_WAKEUP = 224)
        try:
            subprocess.run(
                [ADB_PATH, "-s", device_id, "shell", "input", "keyevent", "224"],
                check=False,
                env=ADB_ENV,
            )
        except Exception as exc:
            log(f"[Screen][ADB][WARN] keyevent 224 a √©chou√© : {exc!r}")

        time.sleep(0.8)

        # 2) R√©cup√©rer la taille de l'√©cran
        try:
            proc = subprocess.run(
                [ADB_PATH, "-s", device_id, "shell", "wm", "size"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                env=ADB_ENV,
            )
            out = proc.stdout or ""
            m = re.search(r"Physical size:\s*(\d+)x(\d+)", out)
            if m:
                w = int(m.group(1))
                h = int(m.group(2))
                x = w // 2
                start_y = int(h * 0.85)
                end_y   = int(h * 0.25)
            else:
                # fallback g√©n√©rique
                x, start_y, end_y = 500, 1600, 400
                log(f"[Screen][ADB][WARN] wm size introuvable, fallback swipe ({x},{start_y}->{x},{end_y})")
        except Exception as exc:
            log(f"[Screen][ADB][WARN] Impossible de lire wm size : {exc!r}")
            x, start_y, end_y = 500, 1600, 400

        # 3) Swipe bas ‚Üí haut
        try:
            subprocess.run(
                [
                    ADB_PATH, "-s", device_id,
                    "shell", "input", "swipe",
                    str(x), str(start_y), str(x), str(end_y), "800"
                ],
                check=False,
                env=ADB_ENV,
            )
            time.sleep(0.8)
            log("[Screen][ADB] Swipe unlock envoy√©.")
        except Exception as exc:
            log(f"[Screen][ADB][WARN] Erreur pendant input swipe : {exc!r}")

    except Exception as exc:
        log(f"[Screen][ADB][WARN] Erreur globale adb_swipe_unlock : {exc!r}")


def is_storyfx_serial(serial: str) -> bool:
    """
    Retourne True si le device doit √™tre utilis√© par StoryFX.

    R√®gles :
    - doit contenir ":" (ip:port, ex: 192.168.1.123:5555)
    - NE doit PAS contenir "emulator"
    - NE doit PAS contenir "5554"
    """
    if not serial:
        return False

    s = serial.strip().lower()

    if "emulator" in s:
        return False
    if "5554" in s:
        return False

    return ":" in s

# ------------------------------------------------------------------ #
# LOG / ADB
# ------------------------------------------------------------------ #
def log(msg: str) -> None:
    """Affiche un log simple (ASCII) pour √©viter les probl√®mes d'encodage."""
    # Si le scheduler nous fournit une heure de rattrapage, on l'utilise
    ts_env = os.environ.get("STORYFX_TIME")
    if ts_env:
        ts = ts_env
    else:
        ts = datetime.now().strftime("%H:%M:%S")

    print(f"[StoryFX] {ts} | {msg}", flush=True)



def adb_devices_text():
    """
    Ex√©cute adb devices et filtre l'√©mulateur.
    """
    try:
        out = subprocess.check_output(
            [ADB_PATH, "devices"],
            env=ADB_ENV,
            stderr=subprocess.STDOUT,
            text=True
        )
    except Exception as exc:
        return f"[ADB ERROR] {exc}"

    # On supprime toutes les lignes emulator-5554
    filtered = []
    for line in out.splitlines():
        if "emulator" in line.lower():
            continue
        if "5554" in line:
            continue
        filtered.append(line)

    return "\n".join(filtered) + "\n"


def adb_devices_filtered_text() -> str:
    """
    Retourne la liste adb devices filtr√©e pour StoryFX :
    - on ne garde que les serials valides (voir is_storyfx_serial)
    - on ignore les lignes "emulator-5554", USB, etc.
    """
    raw = adb_devices_text()
    lines = []

    for line in raw.splitlines():
        line = line.strip()
        if not line or line.startswith("List of devices attached"):
            continue

        parts = line.split()
        serial = parts[0] if parts else ""

        if not is_storyfx_serial(serial):
            # on ignore les √©mulateurs / usb / serials bizarres
            continue

        lines.append(line)

    if not lines:
        return "List of StoryFX devices:\n  (aucun device valide)\n"

    return "List of StoryFX devices:\n" + "\n".join(f"  {l}" for l in lines) + "\n"

def ensure_adb_connected(device_id: str) -> bool:
    """
    Force ADB √† n'avoir qu'UN SEUL device r√©seau actif :
      - adb disconnect  (tous les devices ip:port)
      - adb connect <device_id>  (ex: 192.168.1.123:5555)

    Si device_id ne contient pas ":", on reste sur l'ancien comportement
    (cas d'un serial USB brut).
    """
    device_id = (device_id or "").strip()


    # Si le device_id lui-m√™me ne respecte pas les r√®gles, on le rejette
    if not is_storyfx_serial(device_id):
        log(f"[WARN] Device id '{device_id}' rejet√© (non ip:port ou emulator/5554).")
        return False

    # Cas classique StoryFX : device_id = "ip:port"
    if ":" in device_id:
        log(f"ADB reset : d√©connexion de tous les devices puis connexion sur {device_id} ...")

        # 1) on vide toutes les connexions r√©seau
        try:
            subprocess.run([ADB_PATH, "disconnect"], check=False, env=ADB_ENV)
        except Exception as exc:
            log(f"[WARN] adb disconnect a √©chou√© : {exc!r}")

        time.sleep(0.5)

        # 2) on connecte UNIQUEMENT le device cible
        try:
            subprocess.run([ADB_PATH, "connect", device_id], check=False, env=ADB_ENV)
        except Exception as exc:
            log(f"[WARN] adb connect {device_id} a √©chou√© : {exc!r}")

        time.sleep(1.0)

        # üî• on log maintenant la version filtr√©e
        filtered = adb_devices_filtered_text()
        log(filtered.strip())

        # et on v√©rifie uniquement dans la liste filtr√©e
        if device_id in filtered:
            log(f"ADB connection OK sur {device_id}")

            # üî• D√©verrouillage ADB pour les lockscreens type "Swipe to open"
            adb_swipe_unlock(device_id)

            return True

        log(f"[WARN] ADB device {device_id} non connect√© apr√®s reset.")
        return False

    # Cas plus rare : device_id est un serial USB (sans ip:port)
    out = adb_devices_text()
    if device_id and device_id in out:
        log(f"ADB already connected (USB) : {device_id}")
        return True

    log(f"Device id '{device_id}' is not of form ip:port, cannot auto-connect.")
    return False

# ------------------------------------------------------------------ #
# APPIUM DRIVER
# ------------------------------------------------------------------ #
def unmute_and_volume_80():
    """
    D√©sactive le mute et met le volume syst√®me √† ~80% sous Windows
    via NirCmd. Ne plante jamais m√™me si NirCmd n'existe pas.
    """
    try:
        if sys.platform.startswith("win"):
            # ‚ö†Ô∏è Mets ici ton vrai chemin vers nircmd.exe
            nircmd_path = r"C:\Tools\nircmd\nircmd.exe"

            # Unmute
            subprocess.run(
                [nircmd_path, "mutesysvolume", "0"],
                check=False,
                creationflags=subprocess.CREATE_NO_WINDOW
            )

            # Volume ~80% (65535 * 0.8 ‚âà 52428)
            subprocess.run(
                [nircmd_path, "setsysvolume", "52428"],
                check=False,
                creationflags=subprocess.CREATE_NO_WINDOW
            )

    except Exception:
        # On ne veut pas planter si on ne peut pas changer le volume
        pass


def play_critical_sound():
    """
    Joue un son d'erreur personnalis√© (WAV) sous Windows,
    ou un simple beep sur les autres OS.
    """
    try:
        if sys.platform.startswith("win"):
            import winsound
            from pathlib import Path

            # Chemin vers StoryFx/assets/storyfx_error_alert.wav
            base_dir = Path(__file__).resolve().parent.parent  # .../StoryFx/engine -> parent = StoryFx
            wav_path = base_dir / "assets" / "storyfx_error_alert.wav"

            if wav_path.exists():
                winsound.PlaySound(str(wav_path), winsound.SND_FILENAME | winsound.SND_ASYNC)
            else:
                # fallback : son syst√®me Windows
                winsound.PlaySound("SystemHand", winsound.SND_ALIAS | winsound.SND_ASYNC)
        else:
            # Beep console (Linux / macOS)
            print("\a", end="", flush=True)

    except Exception:
        # Ne jamais planter √† cause du son
        pass



def make_driver(device_id: str, platform_version: Optional[str] = None, profile: dict | None = None):
    caps = {
        "platformName": "Android",
        "deviceName": device_id,
        "automationName": "UiAutomator2",
        "noReset": True,
        "autoGrantPermissions": True,
        "newCommandTimeout": 180,
        "appPackage": "com.sec.android.gallery3d",
        "appActivity": "com.sec.android.gallery3d.app.GalleryActivity",
    }

    # ‚úÖ Personnalisation par profil (FRONT) pour la Galerie
    gal = (profile or {}).get("gallery", {}) or {}
    if isinstance(gal, dict):
        pkg = (gal.get("appPackage") or "").strip()
        act = (gal.get("appActivity") or "").strip()
        if pkg:
            caps["appPackage"] = pkg
        if act:
            caps["appActivity"] = act

    if platform_version:
        caps["platformVersion"] = str(platform_version)

    # ‚úÖ Overides par profil (venant du FRONT via profiles.json)
    overrides = (profile or {}).get("appium_overrides") or {}
    if not isinstance(overrides, dict):
        overrides = {}

    log("Creating Appium driver ...")
    server_url = "http://127.0.0.1:4723/wd/hub"

    try:
        if UiAutomator2Options is not None:
            options = UiAutomator2Options().load_capabilities(caps)

            # tes defaults
            options.set_capability("appium:adbExecTimeout", 200000)
            options.set_capability("appium:adbPort", 5038)
            options.set_capability("appium:adbPath", r"C:\Tools\ADB_StoryFX\adb.exe")
            options.set_capability("appium:adbExec", r"C:\Tools\ADB_StoryFX\adb.exe")
            options.set_capability("appium:ignoreHiddenApiPolicyError", True)
            options.set_capability("appium:disableWindowAnimation", True)

            # ‚úÖ appliquer les overrides (S20/S23/etc.)
            for k, v in overrides.items():
                options.set_capability(f"appium:{k}", v)

            ensure_appium_running()
            # ‚úÖ Reset UiAutomator2 c√¥t√© device avant nouvelle session (√©vite zombie)
            try:
                subprocess.run([ADB_PATH, "-s", device_id, "shell", "am", "force-stop", "io.appium.uiautomator2.server"], env=ADB_ENV, check=False)
                subprocess.run([ADB_PATH, "-s", device_id, "shell", "am", "force-stop", "io.appium.uiautomator2.server.test"], env=ADB_ENV, check=False)
                time.sleep(0.3)
            except Exception:
                pass

            driver = webdriver.Remote(server_url, options=options)
        else:
            driver = webdriver.Remote(server_url, desired_capabilities=caps)

        log("Driver created OK.")

        # üî• Nettoyage visuel + retour Galerie AVANT de continuer StoryFX
        try:
            clear_popups_and_go_home(driver)
            open_gallery(driver)
        except Exception as e:
            log(f"[WARN] Impossible de nettoyer l'√©cran / ouvrir la Galerie : {e!r}")

        return driver

    except Exception:
        log("[StoryFX] [ERROR] Failed to create driver :")
        traceback.print_exc()   # m√™me niveau de d√©tails que dans VS Code
        # ‚úÖ Log clair de l'erreur (tr√®s important dans Scheduler)
        try:
            import traceback as _tb
            log("[StoryFX] [DEBUG] Exception Appium d√©taill√©e :")
            log(_tb.format_exc())
        except Exception:
            pass


        # üîä Forcer le volume puis jouer le son d‚Äôalerte
        try:
            unmute_and_volume_80()
        except Exception:
            log("[StoryFX] [WARN] Unable to change system volume on error.")

        try:
            play_critical_sound()
        except Exception:
            log("[StoryFX] [WARN] Unable to play critical sound on error.")

        # Message tr√®s clair dans les logs
        log(
            "[StoryFX] [ALERTE] Probl√®me Appium/UiAutomator2. "
            "Red√©marre le t√©l√©phone et Appium Server."
        )

        # On relance l‚Äôexception pour ne rien cacher
        raise


_LOCATORS_CACHE = None

def load_locators():
    global _LOCATORS_CACHE
    if _LOCATORS_CACHE is None:
        loc_path = Path(__file__).resolve().parent.parent / "locators.json"
        if loc_path.exists():
            _LOCATORS_CACHE = json.loads(loc_path.read_text(encoding="utf-8"))
        else:
            _LOCATORS_CACHE = {}
    return _LOCATORS_CACHE

def get_locator(platform: str, key: str, profile_name: str | None = None) -> str | None:
    locs = load_locators()
    plat_cfg = locs.get(platform, {})
    key_cfg  = plat_cfg.get(key, {})

    if profile_name and profile_name in key_cfg:
        return key_cfg[profile_name]
    return key_cfg.get("default")

def unlock_screen_if_needed(driver):
    """
    D√©verrouille l'√©cran si n√©cessaire.

    Strat√©gie :
      1) R√©veille l'√©cran
      2) Fait plusieurs swipes bas ‚Üí haut (lockscreen simple / vid√©o "Swipe to open")
      3) Si l'√©cran est encore verrouill√© ‚Üí saisit le code PIN 233623
    """
    PASSWORD = "233623"

    try:
        log("[Screen] V√©rification de l'√©tat de l'√©cran...")

        # On essaie jusqu'√† 3 fois (utile si l'animation du lockscreen est lente)
        for attempt in range(1, 4):
            try:
                locked = driver.is_locked()
            except Exception:
                # certains lockscreens vid√©o r√©pondent mal, on suppose verrouill√© au 1er tour
                locked = (attempt == 1)

            if not locked:
                log("[Screen] √âcran d√©j√† d√©verrouill√©.")
                return

            log(f"[Screen] √âcran verrouill√© ‚Üí tentative de d√©verrouillage (essai {attempt}/3).")

            # 1) R√©veiller l'√©cran (Power ON)
            try:
                driver.press_keycode(224)  # WAKEUP
            except Exception:
                pass
            time.sleep(1.0)

            # 2) Swipes bas ‚Üí haut pour passer les lockscreens simples / vid√©os
            try:
                size = driver.get_window_size()
                x = size["width"] // 2

                swipe_configs = [
                    (0.85, 0.25, 700),
                    (0.90, 0.20, 800),
                ]

                for sy, ey, dur in swipe_configs:
                    start_y = int(size["height"] * sy)
                    end_y   = int(size["height"] * ey)
                    try:
                        driver.swipe(x, start_y, x, end_y, dur)
                        time.sleep(0.7)
                    except Exception as e_sw:
                        log(f"[Screen][WARN] Erreur swipe unlock: {e_sw!r}")
            except Exception as e_sz:
                log(f"[Screen][WARN] Impossible de r√©cup√©rer la taille √©cran: {e_sz!r}")

            time.sleep(1.0)

            # 3) Re-v√©rifier : peut-√™tre que le swipe a suffi
            try:
                if not driver.is_locked():
                    log("[Screen] ‚úî √âcran d√©verrouill√© par swipe.")
                    return
            except Exception:
                # on continue sur le PIN
                pass

            # 4) Si toujours verrouill√© ‚Üí tenter le code PIN 233623
            log("[Screen] Toujours verrouill√© apr√®s swipe ‚Üí tentative PIN 233623...")
            try:
                # Sur beaucoup d'appareils, la touche MENU 82 r√©veille / affiche le PIN si besoin
                try:
                    driver.press_keycode(82)
                    time.sleep(0.5)
                except Exception:
                    pass

                for digit in PASSWORD:
                    kc = 7 + int(digit)  # keycodes 7-16 = 0-9
                    driver.press_keycode(kc)
                    time.sleep(0.15)

                # ENTER pour valider le PIN (au cas o√π)
                try:
                    driver.press_keycode(66)  # ENTER
                except Exception:
                    pass

                time.sleep(1.5)

                try:
                    if not driver.is_locked():
                        log("[Screen] ‚úî √âcran d√©verrouill√© par code PIN.")
                        return
                except Exception:
                    # si is_locked plante, on laisse la boucle faire un autre essai
                    pass

            except Exception as e_pin:
                log(f"[Screen][WARN] Erreur pendant la saisie PIN : {e_pin!r}")

        # Si on est encore l√† ‚Üí √©chec apr√®s 3 essais
        log("[Screen] ‚ùå Impossible de d√©verrouiller l‚Äô√©cran apr√®s plusieurs tentatives.")
        beep_error()

    except Exception as e:
        log(f"[Screen][WARN] Erreur globale pendant le d√©verrouillage : {e!r}")

# ------------------------------------------------------------------ #
# GALERIE SAMSUNG
# ------------------------------------------------------------------ #

def reset_gallery_home(driver) -> bool:
    """
    Remet la Galerie dans un √©tat propre avant un run StoryFX.

    - kill Galerie
    - kill WhatsApp / WhatsApp Business
    - kill Facebook / Messenger
    - kill Instagram
    - kill TikTok
    - relance Galerie
    - tente d'aller sur l'onglet Albums
    """
    log("Reset Gallery : kill apps + relance Galerie + onglet Albums...")

    # 1) Fermer les apps pour √©viter les √©crans coinc√©s (share sheet, WhatsApp, FB, IG, TikTok, etc.)
    PACKAGE_IDS = [
        "com.sec.android.gallery3d",   # Galerie Samsung
        # "com.whatsapp.w4b",            # WhatsApp Business
        # "com.whatsapp",                # WhatsApp normal
        "com.facebook.katana",         # Facebook
        "com.facebook.orca",           # Messenger
        "com.instagram.android",       # Instagram
        "com.zhiliaoapp.musically",    # TikTok (package principal)
        # "com.ss.android.ugc.trill",   # (optionnel) autre package TikTok selon r√©gions
    ]

    for pkg in PACKAGE_IDS:
        try:
            driver.terminate_app(pkg)
            log(f"App termin√©e : {pkg}")
        except Exception:
            pass

    # 2) Relancer proprement la Galerie puis aller sur l‚Äôonglet Albums
    if not start_gallery(driver):
        return False
    for _ in range(3):
        if tap_albums_tab(driver):
            return True
        try:
            driver.back()
        except Exception:
            pass
        time.sleep(0.5)

    log("[ERROR] Impossible de revenir sur la vue Albums apr√®s reset.")
    return False

def start_gallery(driver) -> bool:
    """S'assure que la Galerie est au premier plan."""
    log("Trying activate_app('com.sec.android.gallery3d') ...")
    try:
        driver.activate_app("com.sec.android.gallery3d")
        time.sleep(1.5)
        log(f"Current package after activate_app: {driver.current_package}")
        return True
    except Exception:
        log("[WARN] activate_app failed, trying start_activity fallbacks ...")
        traceback.print_exc()

    candidates = [
        ("com.sec.android.gallery3d", "com.samsung.android.gallery.app.activity.GalleryActivity"),
        ("com.sec.android.gallery3d", "com.sec.android.gallery3d.app.GalleryActivity"),
        ("com.sec.android.gallery3d", "com.sec.android.gallery3d.activity.GalleryActivity"),
    ]
    for pkg, act in candidates:
        try:
            log(f"Trying start_activity({pkg}, {act}) ...")
            driver.start_activity(pkg, act)
            time.sleep(1.5)
            log(f"Current package: {driver.current_package}")
            return True
        except Exception:
            traceback.print_exc()

    log("Unable to start Samsung Gallery after all attempts.")
    return False


# --- Petit helper pour le son d‚Äôalerte ---
if sys.platform == "win32":
    import winsound

    def alert_beep():
        # fr√©quence 1000 Hz, dur√©e 600 ms
        winsound.Beep(1000, 600)
else:
    def alert_beep():
        # fallback simple sur les autres OS
        print("\a", end="", flush=True)

from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

def tap_albums_tab(driver, timeout: float = 5.0) -> bool:
    """
    Clique sur l‚Äôonglet Albums dans la Galerie Samsung.

    Ordre des essais :
      1) XPATH robustes (content-desc + resource-id li√©s √† "Albums")
      2) Fallback UiSelector (Album / Albums)
      3) Derni√®re chance : ic√¥ne globale [2]
    """

    # 1) XPATH principaux et robustes
    xpaths = [
        # LinearLayout complet de l‚Äôonglet Albums
        '//android.widget.LinearLayout[@content-desc="Albums"]/android.view.ViewGroup',
        '//android.widget.LinearLayout[@content-desc="Albums"]',

        # Titre "Albums" dans la barre du bas
        '//android.widget.TextView[@resource-id="com.sec.android.gallery3d:id/title" and @text="Albums"]',

        # Ic√¥ne √† l‚Äôint√©rieur de l‚Äôonglet Albums (sans index global)
        '//android.widget.LinearLayout[@content-desc="Albums"]//android.widget.ImageView',

        # Anciens s√©lecteurs plus larges
        "//*[@resource-id='com.sec.android.gallery3d:id/tab_albums']",
        "//*[@content-desc='Albums' or contains(@content-desc,'Album') or contains(@content-desc,'Albums')]",
        "//*[@text='Albums' or @text='Album' or contains(@text,'Albums') or contains(@text,'Album')]",
    ]

    # --- Essais XPATH robustes ---
    for xp in xpaths:
        try:
            el = WebDriverWait(driver, timeout).until(
                EC.element_to_be_clickable((AppiumBy.XPATH, xp))
            )
            el.click()
            time.sleep(0.6)
            return True
        except Exception:
            pass

    # 2) Fallback UiSelector (texte / description, avec ou sans "s")
    ui_selectors = [
        'new UiSelector().text("Albums")',
        'new UiSelector().text("Album")',
        'new UiSelector().textContains("Albums")',
        'new UiSelector().textContains("Album")',
        'new UiSelector().descriptionContains("Albums")',
        'new UiSelector().descriptionContains("Album")',
    ]

    for ui in ui_selectors:
        try:
            driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, ui).click()
            time.sleep(0.6)
            return True
        except Exception:
            pass

    # 3) Derni√®re chance : ic√¥ne 2e position dans la barre (fragile mais utile en secours)
    try:
        el = WebDriverWait(driver, timeout).until(
            EC.element_to_be_clickable((
                AppiumBy.XPATH,
                '(//android.widget.ImageView[@resource-id="com.sec.android.gallery3d:id/icon"])[2]'
            ))
        )
        el.click()
        time.sleep(0.6)
        return True
    except Exception:
        log("Could not tap Albums tab (all strategies failed).")
        return False



def open_album(driver, name: str, max_scrolls: int = 8) -> bool:
    """Ouvre un album par son nom, en scrollant si besoin."""
    for _ in range(max_scrolls):
        try:
            driver.find_element(
                AppiumBy.XPATH,
                f"//android.widget.TextView[@text='{name}']"
            ).click()
            time.sleep(0.8)
            log(f"Album '{name}' ouvert.")
            return True
        except Exception:
            # scroll down
            size = driver.get_window_size()
            start_y = int(size["height"] * 0.75)
            end_y = int(size["height"] * 0.25)
            x = int(size["width"] * 0.5)
            driver.swipe(x, start_y, x, end_y, 900)
            time.sleep(0.3)
    log(f"[ERROR] Album '{name}' not found after {max_scrolls} scrolls.")
    traceback.print_exc()
    return False

def long_press_first_thumb(driver, retries: int = 1) -> bool:
    """
    Active la multi-s√©lection via un long-press sur la premi√®re vignette,
    PUIS d√©s√©lectionne cette vignette pour ne pas la compter dans le total.

    - on trouve la 1 ≥·µâ vignette via thumbnail_preview_layout
    - on fait un click-and-hold (W3C Actions) puis release
    - ensuite on re-clique la m√™me vignette pour l'enlever de la s√©lection
    Si √ßa ne l√®ve pas d'exception ‚Üí on consid√®re que c'est OK.
    """

    xpath_first_thumb = (
        "(//android.widget.FrameLayout[@resource-id="
        "'com.sec.android.gallery3d:id/thumbnail_preview_layout'])[1]"
    )

    for attempt in range(1, retries + 1):
        try:
            log(f"[multi] Tentative long-press {attempt}/{retries}...")

            # 1) trouver la premi√®re vignette
            thumb = driver.find_element(AppiumBy.XPATH, xpath_first_thumb)
            log("[multi] Premi√®re vignette trouv√©e via XPATH historique.")

            # 2) long press pour activer la multi-s√©lection
            actions = ActionChains(driver)
            actions.click_and_hold(thumb).pause(1.0).release(thumb).perform()
            time.sleep(0.8)

            log("[multi] ‚úî Long-press effectu√©, mode multi activ√©.")

            # 3) D√©s√©lectionner la premi√®re vignette pour que la s√©lection
            #    suivante soit 100 % al√©atoire, sans imposer la premi√®re image
            try:
                thumb = driver.find_element(AppiumBy.XPATH, xpath_first_thumb)
                thumb.click()
                time.sleep(0.3)
                log("[multi] Premi√®re vignette d√©s√©lectionn√©e (on repart de 0 s√©lection).")
            except Exception as e:
                # Ce n'est pas bloquant : au pire on garde la 1 ≥·µâ image s√©lectionn√©e
                log(f"[multi][WARN] Impossible de d√©s√©lectionner la premi√®re vignette : {e!r}")

            return True

        except Exception as e:
            log(f"[multi] ‚ùå Erreur long-press : {e}")
            time.sleep(0.8)

    # Si on arrive ici => toutes les tentatives ont √©chou√©
    beep_error()
    return False


def select_first_video_then_share(driver) -> bool:
    """
    Flow minimal pour l‚Äôengine INTRO :
    - ouvre la premi√®re vignette de l‚Äôalbum
    - clique sur le bouton Share
    """
    try:
        # üëâ m√™me XPath que dans tes scripts "Never_Give_Up" / "Hurry"
        first = driver.find_element(
            AppiumBy.XPATH,
            "(//android.widget.FrameLayout[@resource-id="
            "'com.sec.android.gallery3d:id/thumbnail_preview_layout'])[1]"
        )
        first.click()
        time.sleep(0.5)
        log("Premi√®re vignette ouverte avec succ√®s.")
    except Exception:
        log("[ERROR] Could not open first thumbnail (thumbnail_preview_layout).")
        traceback.print_exc()     # stacktrace d√©taill√©e comme dans VS Code
        return False

    if not tap_share_button(driver):
        log("[ERROR] tap_share_button() failed apr√®s l‚Äôouverture de la vid√©o.")
        return False

    return True


def tap_share_button(driver) -> bool:
    """
    Essaie plusieurs XPaths pour le bouton Share dans la Galerie.

    Ordre :
      0) XPath personnalis√© depuis locators.json (platform='Gallery', key='share')
      1) Liste de XPaths "classiques" (fallback)
    """
    import traceback

    tried_xpaths = []

    # 0) XPath personnalis√© depuis locators.json
    custom_xp = get_locator("Gallery", "share")
    if custom_xp:
        tried_xpaths.append(custom_xp)
        try:
            el = driver.find_element(AppiumBy.XPATH, custom_xp)
            el.click()
            time.sleep(0.8)
            log(f"Share button clicked with CUSTOM XPath: {custom_xp}")
            return True
        except Exception as e:
            log(f"[WARN] Custom Share XPath KO: {custom_xp!r} ({e!r})")

    # 1) Fallbacks classiques
    xpaths_to_try = [
        "//android.widget.RelativeLayout[@content-desc='Share']",
        "//android.widget.Button[@content-desc='Share']",
        "//android.widget.ImageButton[@content-desc='Share']",
        "//android.widget.ImageButton[@content-desc='Partager']",
        "//*[@content-desc='Share']",
        "//*[@content-desc='Partager']",
        "//*[@text='Share']",
        "//*[@text='Partager']",
        "//*[@resource-id='com.sec.android.gallery3d:id/share']",
    ]

    last_error = None

    for xp in xpaths_to_try:
        tried_xpaths.append(xp)
        try:
            el = driver.find_element(AppiumBy.XPATH, xp)
            el.click()
            time.sleep(0.8)
            log(f"Share button clicked with XPath: {xp}")
            return True
        except Exception as e:
            last_error = e
            log(f"[WARN] Share introuvable avec XPath: {xp!r}")

    log("[ERROR] Share button not found in Gallery with any known XPath.")
    log(f"[DEBUG] XPaths test√©s pour Share: {tried_xpaths}")
    if last_error is not None:
        traceback.print_exc()
    return False




# ------------------------------------------------------------------ #
# FLOWS WHATSAPP BUSINESS
# ------------------------------------------------------------------ #
def choose_whatsapp_business_if_needed(driver, profile_name: str | None = None) -> None:
    """
    S√©lectionne l'entr√©e 'WhatsApp Business' dans la feuille de partage Android.

    ‚ùó Version simplifi√©e :
    - on ignore compl√®tement locators.json & Share_Ico.txt
    - on utilise uniquement un XPath g√©n√©rique sur le texte "WhatsApp"
    """
    log("S√©lection de WhatsApp Business (mode g√©n√©rique).")

    xpath = "//*[contains(@text,'WhatsApp')]"

    for attempt in range(1, 4):  # 3 petites tentatives max
        try:
            el = driver.find_element(AppiumBy.XPATH, xpath)
            el.click()
            time.sleep(0.8)
            log(f"WhatsApp Business s√©lectionn√© (generic:text_contains(WhatsApp), attempt={attempt}).")
            return
        except Exception:
            log(f"[WARN] Impossible de trouver WhatsApp Business (generic, attempt={attempt}).")
            time.sleep(0.6)

    log("‚ùå Impossible de s√©lectionner WhatsApp Business avec le XPath g√©n√©rique.")



def share_to_my_status(driver) -> None:
    """S√©lectionne 'My status' / 'Mon statut' puis clique sur Envoyer."""
    my_status = ("//*[@resource-id='com.whatsapp.w4b:id/contactpicker_row_name' and "
                 "(contains(@text,'My status') or contains(@text,'Mon statut'))]")

    # Choix du statut
    for _ in range(5):
        try:
            driver.find_element(AppiumBy.XPATH, my_status).click()
            time.sleep(0.6)
            break
        except Exception:
            time.sleep(0.4)

    # Bouton envoyer
    send_xpath = ("//*[@content-desc='Send' or @resource-id='com.whatsapp.w4b:id/send' "
                  "or @text='Send' or contains(@content-desc,'Envoyer') or @text='Envoyer']")

    for _ in range(5):
        try:
            driver.find_element(AppiumBy.XPATH, send_xpath).click()
            time.sleep(1.0)
            break
        except Exception:
            time.sleep(0.4)

    # S√©curit√© : reclique au cas o√π
    for _ in range(3):
        try:
            driver.find_element(AppiumBy.XPATH, send_xpath).click()
            time.sleep(0.8)
        except Exception:
            break


def beep_error():
    try:
        winsound.Beep(1200, 300)
        winsound.Beep(900, 200)
    except:
        pass


def debug_dump_thumbnails(driver):
    log("=== üîç DEBUG THUMBNAILS DUMP ===")

    nodes = driver.find_elements(AppiumBy.XPATH, "//android.widget.FrameLayout")
    log(f"Nombre de FrameLayout trouv√©s : {len(nodes)}")

    idx = 0
    candidates = []

    for el in nodes:
        try:
            rid = el.get_attribute("resource-id")
            desc = el.get_attribute("content-desc")
            bounds = el.get_attribute("bounds")

            log(f"[{idx}] id={rid} desc={desc} bounds={bounds}")

            if rid and "thumbnail" in rid.lower():
                candidates.append((idx, rid, bounds))

        except:
            pass

        idx += 1

    log("=== üîç CANDIDATES ===")
    for (i, rid, b) in candidates:
        log(f"[Candidate] index={i}  id={rid}  bounds={b}")

    if not candidates:
        log("‚ùå Aucune vignette trouv√©e automatiquement !")
        beep_error()
    else:
        log("‚úî Vignettes d√©tect√©es automatiquement.")

============================================================================================================================================
FILE: engine_intro.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\engine\engine_intro.py
============================================================================================================================================
# -*- coding: utf-8 -*-
"""
Engine INTRO
------------
- Ouvre la galerie
- Va dans l‚Äôonglet Albums
- Ouvre l‚Äôalbum demand√©
- S√©lectionne la premi√®re vid√©o
- Partage selon la plateforme (WhatsApp g√©r√© pour l‚Äôinstant)
"""
import time   # üëà AJOUTER √áA
from .platforms import pre_platform_setup, share_to_platform
from .core import (
    log,
    ensure_adb_connected,
    make_driver,
    open_album,
    select_first_video_then_share,
    choose_whatsapp_business_if_needed,
    share_to_my_status,
    reset_gallery_home,
    unlock_screen_if_needed,
    start_gallery,  # ‚¨ÖÔ∏è ajouter ceci

)


def run(
    profile: dict,
    album: str,
    platform: str = "WhatsApp",
    platform_opts: dict | None = None,
) -> int:
    """
    profile : dict provenant de profiles.json, avec une cl√© suppl√©mentaire
              'profile_name' ajout√©e par runner.py
    album   : nom exact de l‚Äôalbum dans la Galerie
    """
    platform_opts = platform_opts or {}

    # Ajout√© par runner.py : profile["profile_name"] = args.profile
    profile_name = profile.get("profile_name")

    device_id = profile.get("device_id")
    profile_label = profile.get("profile_name", "?")
    log(f"[intro] Profil : {profile_label} | device_id={device_id}")

    plat_ver = profile.get("platform_version")

    if not device_id:
        log("Profil sans device_id, abort.")
        return 1

    if not ensure_adb_connected(device_id):
        return 1

    driver = None
    try:
        # driver = make_driver(device_id, plat_ver)
        driver = make_driver(device_id, plat_ver, profile=profile)

        unlock_screen_if_needed(driver)

        # Pr√©paration sp√©cifique √† la plateforme (ex : s√©lectionner la page Facebook)
        pre_platform_setup(driver, platform, platform_opts)

        # Toujours repartir d'une Galerie propre sur l'onglet Albums
        if not reset_gallery_home(driver):
            log("Impossible de revenir sur la vue Albums.")
            return 1

        if not open_album(driver, album):
            log(f"Album '{album}' introuvable.")
            return 1

        if not select_first_video_then_share(driver):
            log("Impossible de s√©lectionner la premi√®re vid√©o.")
            # On l√®ve une exception pour que run_with_retries puisse relancer
            raise RuntimeError("select_first_video_then_share() returned False")

        # üöÄ ICI : on est sur la feuille de partage Android (Share sheet)

        if platform == "WhatsApp":
            choose_whatsapp_business_if_needed(driver, profile_name)
            share_to_my_status(driver)
            log("Partage WhatsApp termin√©.")
        else:
            share_to_platform(driver, platform, platform_opts)
            log(f"Partage {platform} termin√©.")

        # üïí Laisser 2‚Äì3 s pour que l'upload d√©marre
        try:
            log("Attente 2 s, puis retour sur la Galerie...")
            time.sleep(2.0)          # tu peux mettre 3.0 si tu veux plus
            start_gallery(driver)    # ‚¨ÖÔ∏è ouvre juste l'appli Galerie au premier plan
        except Exception:
            log("[WARN] Impossible de ramener la Galerie au premier plan (INTRO).")

        return 0

        # if platform == "WhatsApp":
        #     # Ic√¥ne WhatsApp Business dans la feuille de partage
        #     choose_whatsapp_business_if_needed(driver, profile_name)
        #     # Puis "My status" / "Mon statut" + bouton Envoyer
        #     share_to_my_status(driver)
        #     log("Partage WhatsApp termin√©.")
        # else:
        #     # Facebook / Instagram / TikTok
        #     share_to_platform(driver, platform, platform_opts)
        #     log(f"Partage {platform} termin√©.")
        #
        # # ‚úÖ Tr√®s important : code de succ√®s
        # return 0
        #

    finally:
        if driver is not None:
            try:
                # üî• Forcer Android √† rester sur Galerie
                driver.activate_app("com.sec.android.gallery3d")
                time.sleep(1.0)
            except Exception:
                pass

            try:
                # ‚ö†Ô∏è Petit hack : envoyer HOME mais en laissant Galerie ouverte
                driver.press_keycode(3)  # HOME
                time.sleep(0.8)
            except Exception:
                pass

            try:
                driver.quit()
            except Exception:
                pass

    #
    # finally:
    #     if driver is not None:
    #         try:
    #             driver.quit()
    #         except Exception:
    #             pass


============================================================================================================================================
FILE: engine_multi.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\engine\engine_multi.py
============================================================================================================================================
# -*- coding: utf-8 -*-
"""
Multi-selection engine (codes 3,4,5,6,7 ‚Ä¶)
"""

from appium.webdriver.common.touch_action import TouchAction

import time
import random
import math
from pathlib import Path

from ui.ui_paths_helpers import load_albums_dict
from appium.webdriver.common.appiumby import AppiumBy

from .platforms import pre_platform_setup, share_to_platform

from .core import (
    log,
    ensure_adb_connected,
    make_driver,
    open_album,
    long_press_first_thumb,
    tap_share_button,
    choose_whatsapp_business_if_needed,
    share_to_my_status,
    reset_gallery_home,
    unlock_screen_if_needed,
    start_gallery,  # ‚¨ÖÔ∏è ajouter ceci
    debug_dump_thumbnails,  # ‚úÖ AJOUTER CETTE LIGNE
)

ALBUMS_CACHE = None


def get_album_size(album_name: str) -> int:
    """Retourne album_size pour un album donn√© en lisant albums.json."""
    global ALBUMS_CACHE
    if ALBUMS_CACHE is None:
        ALBUMS_CACHE = load_albums_dict()
    cfg = ALBUMS_CACHE.get(album_name)
    return int(cfg.get("album_size", 0) or 0) if cfg else 0


def compute_scroll_max_for_album(album_name: str) -> int:
    """
    Calcule scroll_max en fonction de albums.json.
    Formule : ceil(n / 200), born√©e entre 1 et 10.
    """
    n = get_album_size(album_name)
    if not n:
        return 3
    scroll_max = math.ceil(n / 250.0)
    if scroll_max < 1:
        return 1
    if scroll_max > 10:
        return 10
    return scroll_max


def run(
    profile: dict,
    album_name: str,
    count: int,
    platform: str = "WhatsApp",
    platform_opts: dict | None = None,
) -> int:
    """
    Engine MULTI :
      - remet la Galerie dans un √©tat propre (reset_gallery_home)
      - ouvre l‚Äôalbum demand√©
      - active la s√©lection multiple (long press)
      - s√©lectionne `count` images : 1 par "page", puis scroll
      - partage vers la plateforme choisie :
          * WhatsApp Business (My status) si platform == "WhatsApp"
          * sinon Facebook / Instagram / TikTok via share_to_platform()

    Codes retour :
      1 : ADB non connect√© ou profil sans device_id
      2 : impossible de remettre la Galerie propre (reset_gallery_home)
      4 : album introuvable
      5 : impossible de faire le long press sur la premi√®re vignette
      6 : pas assez d‚Äôimages s√©lectionn√©es
      7 : bouton Share introuvable
      0 : succ√®s
    """
    platform_opts = platform_opts or {}

    device_id = profile.get("device_id")
    plat_ver  = profile.get("platform_version")
    profile_name = profile.get("profile_name")  # √©ventuellement utile plus tard

    if not device_id:
        log("[multi] Profil sans device_id, abort.")
        return 1

    if not ensure_adb_connected(device_id):
        return 1

    # S‚Äôassurer que count est bien un int
    try:
        count = int(count)
    except Exception:
        count = 11

    # driver = make_driver(device_id, plat_ver)
    driver = make_driver(device_id, plat_ver, profile=profile)

    unlock_screen_if_needed(driver)

    try:
        # D√©verrouillage simple si besoin
        try:
            if driver.is_locked():
                driver.press_keycode(82)
                time.sleep(0.5)
        except Exception:
            pass

        # Pr√©paration √©ventuelle (utile surtout pour Facebook)
        pre_platform_setup(driver, platform, platform_opts)

        # üî• Toujours repartir d'une Galerie propre sur l'onglet Albums
        if not reset_gallery_home(driver):
            log("[multi] Impossible de remettre la Galerie dans un √©tat propre.")
            return 2

        # Ouvrir l‚Äôalbum
        if not open_album(driver, album_name):
            log(f"[multi] Album '{album_name}' introuvable.")
            return 4

        # Activer la multi-s√©lection (long press sur la premi√®re vignette)
        if not long_press_first_thumb(driver):
            log("[multi] Impossible de faire le long press sur la premi√®re vignette.")
            return 5

        # Scroll max dynamique en fonction de l'album (bas√© sur albums.json)
        scroll_max   = compute_scroll_max_for_album(album_name)
        album_total  = get_album_size(album_name)
        log(f"[multi] scroll_max={scroll_max} pour l'album '{album_name}' (album_size={album_total}).")

        # Par s√©curit√© : ne jamais demander plus d'images que l'album n'en contient
        if album_total and count > album_total:
            count = album_total
            log(f"[multi] count ajust√© √† {count} (taille r√©elle de l'album).")

        # ------------------------------------------------------------------
        # MODE 1 : petits albums (‚â§ 32 photos) ‚Üí une seule page, aucun scroll
        # ------------------------------------------------------------------
        if album_total and album_total <= 32:
            log("[multi] Mode 'small album' activ√© (‚â§ 32 photos) : aucune analyse de scroll.")

            thumbs = driver.find_elements(
                AppiumBy.XPATH,
                "(//android.widget.FrameLayout[@resource-id="
                "'com.sec.android.gallery3d:id/thumbnail_preview_layout'])",
            )

            if not thumbs:
                log("[multi] ‚ùå Aucune vignette trouv√©e sur la page unique.")
                # Debug sp√©cial S23 pour voir ce que Samsung renvoie
                debug_dump_thumbnails(driver)
                return 6

            idxs = list(range(len(thumbs)))
            random.shuffle(idxs)

            selected = 0
            for i in idxs:
                if selected >= count:
                    break
                try:
                    thumbs[i].click()
                    selected += 1
                    log(f"[multi] Image s√©lectionn√©e (total={selected}/{count}).")
                    time.sleep(0.2)
                except Exception:
                    continue

            if selected < count:
                log(f"[multi] Seulement {selected}/{count} images s√©lectionn√©es ‚Üí code 6 (small album).")
                return 6

        # ------------------------------------------------------------------
        # MODE 2 : grands albums (> 32 photos) ‚Üí algo classique avec scroll
        # ------------------------------------------------------------------
        else:
            # --- S√©lection multi : 1 image puis scroll, comme ton ancien script ---
            selected = 0
            empty_loops = 0
            max_empty_loops = 10

            while selected < count and empty_loops < max_empty_loops:
                thumbs = driver.find_elements(
                    AppiumBy.XPATH,
                    "(//android.widget.FrameLayout[@resource-id="
                    "'com.sec.android.gallery3d:id/thumbnail_preview_layout'])",
                )

                if not thumbs:
                    empty_loops += 1
                    log(f"[multi] Aucune vignette trouv√©e (loop={empty_loops}), on scroll.")

                    # üîç DEBUG SP√âCIAL S23 : voir ce que Samsung affiche r√©ellement
                    if empty_loops == 1:
                        debug_dump_thumbnails(driver)

                else:
                    idxs = list(range(len(thumbs)))
                    random.shuffle(idxs)

                    clicked = False
                    for i in idxs:
                        if selected >= count:
                            break
                        try:
                            thumbs[i].click()
                            selected += 1
                            clicked = True
                            log(f"[multi] Image s√©lectionn√©e (total={selected}/{count}).")
                            time.sleep(0.2)
                            break
                        except Exception:
                            continue

                    if not clicked:
                        empty_loops += 1
                        log(
                            f"[multi] Impossible de s√©lectionner une image sur cette page "
                            f"(loop={empty_loops})."
                        )

                # Scroll 1 ‚Üí scroll_max fois selon la taille de l'album
                size = driver.get_window_size()
                start_x = size["width"] // 2
                start_y = int(size["height"] * 0.75)
                end_y   = int(size["height"] * 0.25)

                scroll_times = random.randint(1, scroll_max)
                for _ in range(scroll_times):
                    driver.swipe(start_x, start_y, start_x, end_y, 900)
                    time.sleep(0.4)

            if selected < count:
                log(f"[multi] Seulement {selected}/{count} images s√©lectionn√©es ‚Üí code 6.")
                return 6

        # Bouton Share
        if not tap_share_button(driver):
            return 7

        # ‚≠ê ROUTAGE SELON LA PLATEFORME ‚≠ê
        if platform == "WhatsApp":
            choose_whatsapp_business_if_needed(driver, profile_name)
            share_to_my_status(driver)
            log("‚úî Multi selection posted (WhatsApp Status).")
        else:
            share_to_platform(driver, platform, platform_opts)
            log(f"‚úî Multi selection posted on {platform}.")

        # üïí Laisser le temps √† l'upload de partir, puis revenir sur la Galerie
        try:
            log("Attente 2 s, puis retour sur la Galerie...")
            time.sleep(2.0)
            start_gallery(driver)    # ‚¨ÖÔ∏è met la Galerie au premier plan, sans fermer les autres apps
        except Exception:
            log("[WARN] Impossible de ramener la Galerie au premier plan (MULTI).")

        return 0


        # # ‚≠ê ROUTAGE SELON LA PLATEFORME ‚≠ê
        # if platform == "WhatsApp":
        #     # Feuille de partage ‚Üí WhatsApp Business ‚Üí My status
        #     choose_whatsapp_business_if_needed(driver, profile_name)
        #     share_to_my_status(driver)
        #     log("‚úî Multi selection posted (WhatsApp Status).")
        # else:
        #     # Facebook / Instagram / TikTok
        #     share_to_platform(driver, platform, platform_opts)
        #     log(f"‚úî Multi selection posted on {platform}.")
        #
        # return 0

    finally:
        try:
            driver.quit()
        except Exception:
            pass


============================================================================================================================================
FILE: platforms.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\engine\platforms.py
============================================================================================================================================
# StoryFx/engine/platforms.py
# -*- coding: utf-8 -*-
"""
Gestion centralis√©e des plateformes de publication :
- Facebook (CM / CI + page_name)
- Instagram (variant S20/S23 √©ventuel)
- TikTok
- WhatsApp
"""

import time
from pathlib import Path
from appium.webdriver.common.appiumby import AppiumBy
from .core import log, choose_whatsapp_business_if_needed
from selenium.common.exceptions import WebDriverException
import traceback

# ---------- Petits helpers ----------
def _findall(driver, xp): return driver.find_elements(AppiumBy.XPATH, xp)

def _click(driver, xp, delay=0.8):
    els = _findall(driver, xp)
    if els:
        els[0].click()
        time.sleep(delay)
        return True
    return False

def _maybe_click(
    driver,
    selectors: list[str],
    delay: float = 0.5,
    strategy: str = "xpath",
) -> bool:
    """
    Essaie de cliquer sur le premier √©l√©ment trouvable parmi 'selectors'.

    strategy:
      - "xpath"       ‚Üí selectors sont des XPATH (AppiumBy.XPATH)
      - "uiautomator" ‚Üí selectors sont des UiSelector(...) (AppiumBy.ANDROID_UIAUTOMATOR)
    """
    if strategy == "uiautomator":
        by = AppiumBy.ANDROID_UIAUTOMATOR
    else:
        by = AppiumBy.XPATH

    for sel in selectors:
        try:
            el = driver.find_element(by, sel)
            el.click()
            time.sleep(delay)
            return True
        except Exception:
            continue
    return False


# ===================== FACEBOOK =====================
def _reset_facebook(driver):
    """
    Termine proprement les apps Facebook avant la pr√©-s√©lection de page.
    √âquivalent minimal de reset_gallery_home mais cibl√© sur Facebook.
    """
    fb_packages = [
        "com.facebook.katana",  # app principale
        "com.facebook.orca",    # Messenger
        "com.facebook.lite",    # au cas o√π un Lite tra√Æne
    ]
    for pkg in fb_packages:
        try:
            driver.terminate_app(pkg)
            log(f"[FB] App termin√©e (reset): {pkg}")
        except Exception:
            # si l'app n'est pas install√©e ou d√©j√† ferm√©e, on ignore
            pass

def fb_preselect_page(driver, page_code: str | None, page_name: str | None):
    """
    Ouvre Facebook, s√©lectionne la page cible puis revient HOME.
    """

    log(f"[FB] fb_preselect_page() START (page_name={page_name!r}, page_code={page_code!r})")
    try:
        cur_pkg = getattr(driver, "current_package", None)
        log(f"[FB] current_package au d√©but: {cur_pkg}")
    except Exception as e:
        log(f"[FB] Impossible de lire current_package au d√©but: {e!r}")

    # üî• 0) RESET FACEBOOK AVANT DE LA LANCER
    _reset_facebook(driver)

    # 1) Lancer / ramener Facebook devant
    launched = False

    try:
        log("[FB] Tentative activate_app('com.facebook.katana')...")
        driver.activate_app("com.facebook.katana")
        time.sleep(2.0)
        log(f"[FB] current_package apr√®s activate_app: {driver.current_package}")
        launched = True
    except Exception as e:
        log(f"[FB] activate_app a √©chou√©: {e!r}")
        traceback.print_exc()

    if not launched:
        try:
            log("[FB] Tentative start_activity(com.facebook.katana, LoginActivity)...")
            driver.start_activity("com.facebook.katana", "com.facebook.katana.LoginActivity")
            time.sleep(2.0)
            log(f"[FB] current_package apr√®s start_activity: {driver.current_package}")
            launched = True
        except Exception as e2:
            log(f"[FB] start_activity a √©chou√©: {e2!r}")
            traceback.print_exc()

    if not launched:
        log("[FB] ‚ùå Impossible de lancer Facebook via activate_app/start_activity. Abandon pr√©-s√©lection page.")
        return

    log("[FB] Facebook lanc√©, ouverture du menu (dernier onglet)...")

    # 2) Ouvrir le menu (ic√¥ne tout √† droite, quel que soit le nombre d'onglets)
    for attempt in range(8):
        try:
            menu_tabs = driver.find_elements(
                AppiumBy.XPATH,
                "//android.view.View[starts-with(@content-desc,'Menu, tab ') "
                "and contains(@content-desc,' of ')]"
            )

            if menu_tabs:
                # Dernier onglet : Menu, tab 5/5, 6/6, 7/7, ...
                menu_tabs[-1].click()
                time.sleep(1.0)
                log(f"[FB] Menu ouvert via liste des onglets (attempt={attempt+1}).")
                break

            # Fallback explicites si jamais la liste est vide
            fallback_xpaths = [
                "//android.view.View[@content-desc='Menu, tab 6 of 6']",
                "//android.view.View[@content-desc='Menu, tab 5 of 5']",
                "//android.view.View[@content-desc='Menu, tab 7 of 7']",
                "//android.view.View[@content-desc='Menu, tab 8 of 8']",
            ]
            clicked = False
            for xp in fallback_xpaths:
                try:
                    driver.find_element(AppiumBy.XPATH, xp).click()
                    time.sleep(1.0)
                    log(f"[FB] Menu ouvert via fallback XPath {xp} (attempt={attempt+1}).")
                    clicked = True
                    break
                except Exception:
                    continue

            if clicked:
                break

            raise Exception("Menu tab not found")

        except WebDriverException as e:
            # Cas typique UiAutomator2 crash : instrumentation pas d√©marr√©e
            log(f"[FB] WebDriverException lors de la recherche du menu (attempt={attempt+1}): {e!r}")
            if attempt >= 2:
                log("[FB] ‚ùå Probl√®me UiAutomator2 persistant lors de l'ouverture du menu. Abandon fb_preselect_page.")
                traceback.print_exc()
                return
            time.sleep(1.0)
        except Exception as e:
            log(f"[FB] √âchec pour ouvrir l'onglet Menu (attempt={attempt+1}): {e!r}")
            if attempt == 7:
                log("[FB] ‚ùå √âchec d√©finitif pour ouvrir l'onglet Menu.")
                traceback.print_exc()
                return
            time.sleep(0.7)

    # 3) Ouvrir le profile switcher (ic√¥ne en haut permettant de choisir la page)
    log("[FB] Recherche du profile switcher (Open profile switcher / 9+)...")
    opened_switcher = False
    for attempt in range(8):
        try:
            # 3a) bouton standard (avec ou sans 'you have notifications')
            if _click(driver,
                      "//android.widget.Button[contains(@content-desc,'Open profile switcher')]",
                      delay=1.0):
                log(f"[FB] Profile switcher ouvert via bouton (attempt={attempt+1}).")
                opened_switcher = True
                break

            # 3b) fallback : le ViewGroup '9+'
            if _click(driver,
                      "//android.view.ViewGroup[@content-desc='9+']",
                      delay=1.0):
                log(f"[FB] Profile switcher ouvert via ViewGroup '9+' (attempt={attempt+1}).")
                opened_switcher = True
                break

            # 3c) fallback plus large : n‚Äôimporte quel content-desc contenant 'profile switcher'
            if _click(driver,
                      "//*[contains(@content-desc,'profile switcher')]",
                      delay=1.0):
                log(f"[FB] Profile switcher ouvert via content-desc contenant 'profile switcher' (attempt={attempt+1}).")
                opened_switcher = True
                break

        except WebDriverException as e:
            log(f"[FB] WebDriverException lors de l'ouverture du profile switcher (attempt={attempt+1}): {e!r}")
        except Exception as e:
            log(f"[FB] Erreur lors de l'ouverture du profile switcher (attempt={attempt+1}): {e!r}")

        time.sleep(0.7)

    if not opened_switcher:
        log("[FB] ‚ùå Impossible d‚Äôouvrir le profile switcher (fl√®che / 9+).")
        return

    # 4) S√©lection de la page dans la liste
    clicked = False

    # 4a) priorit√© au page_name saisi dans l‚ÄôUI
    if page_name:
        log(f"[FB] S√©lection de la page par page_name='{page_name}'...")
        xpaths = [
            f"//android.view.View[@text='{page_name}']",
            f"//android.view.View[contains(@text,'{page_name}')]",
            f"//*[@text='{page_name}']",
        ]
        for xp in xpaths:
            try:
                driver.find_element(AppiumBy.XPATH, xp).click()
                # ‚úÖ Laisser le temps √† Facebook de basculer sur la page
                time.sleep(2.0)
                log(f"[FB] Page s√©lectionn√©e avec XPath: {xp}")
                clicked = True
                break
            except Exception as e:
                log(f"[FB] XPath '{xp}' KO pour page_name (err={e!r})")


    # 4b) fallback par code CM / CI
    if not clicked:
        log(f"[FB] S√©lection de la page via page_code='{page_code}'...")
        if page_code == "CM":
            # Page Cameroun
            xpaths = [
                "//android.view.View[@text='Jerry Kamgang']",
                "//*[contains(@text,'Jerry Kamgang')]",
            ]
        elif page_code == "CI":
            # Page C√¥te d'Ivoire
            xpaths = [
                "//android.view.View[@text=\"Jerry Kamgang C√¥te d'Ivoire\"]",
                "//*[contains(@text,\"Jerry Kamgang C√¥te d'Ivoire\")]",
            ]
        else:
            xpaths = []

        for xp in xpaths:
            try:
                driver.find_element(AppiumBy.XPATH, xp).click()
                # ‚úÖ Laisser 2s pour que Facebook charge bien la page
                time.sleep(2.0)
                log(f"[FB] Page s√©lectionn√©e avec XPath (code={page_code}): {xp}")
                clicked = True
                break
            except Exception as e:
                log(f"[FB] XPath '{xp}' KO pour code {page_code} (err={e!r})")

    if not clicked:
        log("[FB] ‚ùå Impossible de s√©lectionner la page Facebook.")
        return

    # 5) Retour HOME
    log("[FB] ‚úÖ Page Facebook s√©lectionn√©e. Retour HOME avant Galerie...")
    try:
        # ‚úÖ Petite pause pour laisser le temps √† l‚ÄôUI de se stabiliser sur la page
        time.sleep(1.0)
        driver.press_keycode(3)  # HOME
        time.sleep(0.8)
        log(f"[FB] current_package apr√®s HOME: {driver.current_package}")
    except Exception as e:
        log(f"[FB] Probl√®me lors du retour HOME: {e!r}")
        traceback.print_exc()


def share_to_facebook(driver, platform_opts: dict | None = None) -> None:
    """
    S√©lectionne l‚Äôic√¥ne 'Facebook' dans la feuille de partage,
    puis clique sur le bouton Share/Partager dans Facebook.
    """
    log("[FB] S√©lection de l‚Äôic√¥ne Facebook dans la feuille de partage...")
    platform_opts = platform_opts or {}

    # 1) Essais robustes sur le texte pour l‚Äôic√¥ne Facebook
    clicked = _maybe_click(driver, [
        # XPath principal (Appium Inspector)
        "//android.widget.TextView[@resource-id='android:id/text1' and @text='Facebook']",

        # Variantes texte + content-desc
        "//android.widget.TextView[contains(@text,'Facebook')]",
        "//*[@text='Facebook']",
        "//*[@text='Facebook Your Story']",
        "//*[@content-desc='Facebook']",
        "//*[contains(@content-desc,'Facebook')]",
    ], delay=1.0)

    # 2) Fallback : ton Share_Ico.txt historique
    if not clicked:
        try:
            ico_path = Path(__file__).resolve().parent.parent / "Share_Ico.txt"
            xp = ico_path.read_text(encoding="utf-8").strip().replace('"', "'")
            if xp:
                if _maybe_click(driver, [xp], delay=1.0):
                    log("‚úî Ic√¥ne Facebook tap√©e via Share_Ico.txt.")
                    clicked = True
        except Exception as e:
            log(f"[FB][WARN] Impossible de lire Share_Ico.txt : {e}")

    if not clicked:
        log("‚ùå Impossible de taper sur l‚Äôic√¥ne Facebook dans la feuille de partage.")
        return

    log("[FB] Ic√¥ne Facebook s√©lectionn√©e, attente que l‚Äô√©diteur charge...")

    # üî• Laisser le temps √† Facebook de charger l‚Äô√©cran de partage
    # (surtout pour les VID√âOS : on allonge volontairement)
    time.sleep(3.0)

    log("[FB] Ic√¥ne Facebook s√©lectionn√©e, recherche du bouton Share/Partager...")

    # 3) Bouton Share dans Facebook (toutes les possibilit√©s connues)
    clicked_share = _maybe_click(driver, [
        # A) Bouton avec content-desc "Share" (prise en compte de ta capture)
        "//android.widget.Button[@content-desc='Share']",

        # B) TextView 'Share' avec resource-id Facebook (id masqu√© dans Inspector)
        #    ‚Üí on matche par starts-with sur le prefix com.facebook.katana:id/
        "//android.widget.TextView[starts-with(@resource-id,'com.facebook.katana:id/') and @text='Share']",

        # C) Variantes texte simples
        "//*[@text='Share']",
        "//*[@text='Partager']",
        "//*[contains(@text,'Share')]",
        "//*[contains(@text,'Partager')]",

        # D) Variantes content-desc
        "//*[@content-desc='Share']",
        "//*[@content-desc='Partager']",
        "//*[contains(@content-desc,'Share')]",
        "//*[contains(@content-desc,'Partager')]",
    ], delay=3.0)  # ‚¨ÖÔ∏è d√©lai TRIPL√â pour laisser le temps aux vid√©os

    if clicked_share:
        log("‚úÖ Bouton Share Facebook cliqu√© (story/post envoy√©e).")
    else:
        log("[FB] ‚ö†Ô∏è Bouton Share/Partager introuvable apr√®s chargement Facebook.")


# ===================== INSTAGRAM =====================
def share_to_instagram(driver, mode="auto"):

    """
    Flow Instagram Story g√©n√©rique.

    mode:
      - "intro" : une seule vid√©o / image (intro)
      - "multi" : plusieurs images/vid√©os (album)
      - "auto"  : tente d'abord le comportement intro, puis bascule en multi si besoin
    """
    mode = (mode or "auto").lower()
    is_intro = mode == "intro"
    is_multi = mode == "multi"

    # Facteur de d√©lai sp√©cial Instagram (surtout utile pour les vid√©os lourdes)
    IG_FACTOR = 4.0

    # Petit helper pour factoriser Share + Done
    def _ig_share_and_done(from_multi: bool):
        # 4) Bouton 'Share'
        log("[IG] Recherche du bouton 'Share' dans la feuille 'Share'...")
        clicked_share = _maybe_click(driver, [
            "(//android.widget.TextView[@text='Share'])[2]",
            "//*[@text='Share']",
        ], delay=1.0 * IG_FACTOR)
        if not clicked_share:
            log("[IG] ‚ö†Ô∏è Bouton 'Share' introuvable, abandon.")
            return False

        # 5) Bouton 'Done'
        log("[IG] Recherche du bouton 'Done' dans 'Also share to'...")
        clicked_done = _maybe_click(driver, [
            "//android.widget.TextView[@text='Done']",
            "//*[@text='Done']",
        ], delay=1.0 * IG_FACTOR)

        if clicked_done:
            if from_multi:
                log("‚úÖ Story publi√©e sur Instagram (Next ‚Üí Share ‚Üí Done, mode multi).")
            else:
                log("‚úÖ Story publi√©e sur Instagram via 'Share to' ‚Üí Share ‚Üí Done (sans Next).")
            return True
        else:
            log("[IG] ‚ö†Ô∏è Bouton 'Done' introuvable : publication Instagram non confirm√©e.")
            return False

    # 1) Feuille de partage Android ‚Üí entr√©e Instagram (si visible)
    log("[IG] S√©lection d'Instagram dans la feuille de partage (si visible)...")
    if not _maybe_click(driver, [
        "//*[@text='Instagram' or contains(@content-desc,'Instagram')]"
    ], delay=1.2 * IG_FACTOR):
        log("[IG] Instagram introuvable dans la feuille de partage (on est peut-√™tre d√©j√† dans l'app).")

    # 2) ESSAI RAPIDE (INTRO / AUTO) : Your story / Your stories / Share to
    if not is_multi:
        # 2a) Your story / Votre story / Your stories
        log("[IG] Tentative clic sur 'Your story' / 'Votre story' / 'Your stories'...")
        clicked_story = _maybe_click(driver, [
            "//*[@text='Your story']",
            "//*[@text='Votre story']",
            "//*[contains(@content-desc,'Your story')]",
            "//*[contains(@content-desc,'Votre story')]",
            "//android.widget.Button[@content-desc='Your stories']",
        ], delay=1.0 * IG_FACTOR)

        if clicked_story:
            # Dans ce cas, la story est post√©e directement, on ne fait PAS Next/Share/Done
            log("‚úÖ Story publi√©e sur Instagram via 'Your story / Your stories' (mode intro).")
            return
        else:
            log("[IG] 'Your story' / 'Your stories' introuvable.")

        # 2b) Bouton "Share to" (cas intro avec partage vers story)
        log("[IG] Tentative clic sur 'Share to'...")
        clicked_share_to = _maybe_click(driver, [
            "//android.widget.Button[@content-desc='Share to']/android.widget.TextView",
        ], delay=1.0 * IG_FACTOR)

        if clicked_share_to:
            log("[IG] 'Share to' cliqu√©, encha√Ænement Share ‚Üí Done (sans Next).")
            _ig_share_and_done(from_multi=False)
            return

    # Si on est en mode INTRO explicite et qu'on n'a ni Story ni Share to,
    # on NE DOIT PAS lancer le flow multi.
    if is_intro:
        log("[IG] Mode intro : pas de flow multi (Next ‚Üí Share ‚Üí Done). Abandon.")
        return

    # 3) FLOW AVANC√â (MULTI ou AUTO) ‚Üí Next ‚Üí Share ‚Üí Done
    #    - utilis√© pour mode "multi"
    #    - ou pour mode "auto" si on n‚Äôa pas trouv√© Story / Share to
    log("[IG] Flow multi Instagram (Next ‚Üí Share ‚Üí Done)...")

    # üî• On laisse le temps √† Instagram de charger toutes les vignettes,
    # surtout quand il y a plusieurs vid√©os (sinon 'Next' arrive trop tard).
    log("[IG] Pause avant recherche du bouton 'Next' (chargement vid√©os)...")
    time.sleep(1.0 * IG_FACTOR)

    log("[IG] Recherche du bouton 'Next'...")
    clicked_next = _maybe_click(driver, [
        # bouton 'Next' (content-desc)
        "//android.widget.Button[@content-desc='Next']",

        # bouton 'Next' dans le tray (texte + resource-id sp√©cifiques)
        "//android.widget.TextView[@resource-id='com.instagram.android:id/media_thumbnail_tray_button_text' and @text='Next']",
        "//android.widget.TextView[@resource-id='com.instagram.android:id/media_thumbnail_tray_button_text']",

        # layout qui contient le bouton Next (au cas o√π on clique le container)
        "//android.widget.LinearLayout[@resource-id='com.instagram.android:id/media_thumbnail_tray_next_buttons_layout']",

        # fallback texte simple
        "//*[@text='Next']",
    ], delay=1.0 * IG_FACTOR)

    if not clicked_next:
        log("[IG] ‚ö†Ô∏è Bouton 'Next' introuvable, abandon du flow multi.")
        return

    # 4 + 5) Share ‚Üí Done (mode multi)
    _ig_share_and_done(from_multi=True)


# ===================== WHATSAPP =====================
def share_to_whatsapp_status(driver):
    """On garde tes helpers W4B (s√©lecteur My status ensuite dans l‚Äôengine)."""
    choose_whatsapp_business_if_needed(driver)
    log("‚úÖ Feuille WhatsApp Business ouverte.")

# ===================== TIKTOK =====================
def share_to_tiktok(driver):
    """
    Feuille de partage ‚Üí TikTok ‚Üí premier bouton (Photo/story)
    ‚Üí mute √©ventuel ‚Üí publier en story.
    """

    # facteur global pour TikTok (d√©lais un peu plus longs)
    TT_FACTOR = 2.0

    # 1) Feuille de partage Android ‚Üí entr√©e TikTok
    log("[TT] S√©lection de TikTok dans la feuille de partage...")
    if not _maybe_click(driver, [
        "//*[@text='TikTok' or contains(@content-desc,'TikTok')]",
    ], delay=1.2 * TT_FACTOR):
        log("[TT] ‚ö†Ô∏è TikTok introuvable dans la feuille de partage.")
        return

    # 2) Premier bouton dans TikTok (Photo / premi√®re vignette)
    log("[TT] S√©lection du premier bouton (Photo / Vid√©o / premi√®re image)...")
    clicked_first = _maybe_click(
        driver,
        [
            # d‚Äôabord les boutons texte (plus stables)
            "//android.widget.Button[@resource-id='com.zhiliaoapp.musically:id/ktc' and @text='Photo']",
            "//android.widget.Button[@resource-id='com.zhiliaoapp.musically:id/ktc' and @text='Video']",

            # en DERNIER recours seulement : la 1re image ktq (fragile si l‚Äôordre change)
            "(//android.widget.ImageView[@resource-id='com.zhiliaoapp.musically:id/ktq'])[1]",
        ],
        delay=2.5 * TT_FACTOR,
    )

    if not clicked_first:
        log("[TT] ‚ö†Ô∏è Impossible de cliquer sur le premier bouton (Photo / ktq).")
        # On continue quand m√™me, au cas o√π l'√©cran suivant est d√©j√† affich√©

    # 3) D√©sactiver le son (mute) pour publier en story
    log("[TT] Tentative de d√©sactivation du son (mute)...")
    _maybe_click(
        driver,
        [
            "//android.widget.ImageView[@resource-id='com.zhiliaoapp.musically:id/c8b']",
            "//android.view.View[@resource-id='com.zhiliaoapp.musically:id/c8f']",
        ],
        delay=0.8 * TT_FACTOR,
    )

    # petite pause pour laisser TikTok pr√©parer l'√©cran "Your Story"
    time.sleep(1.0 * TT_FACTOR)

    # 4) Bouton de publication en story ("Your Story" / "Story")
    log("[TT] Recherche du bouton de publication (story / post)...")
    clicked_publish = _maybe_click(
        driver,
        [
            # A) XPATH bas√© sur le texte "Your Story" / "Story"
            "//android.widget.TextView[@resource-id='com.zhiliaoapp.musically:id/s30' and (@text='Your Story' or @text='Story')]",
            "//android.widget.TextView[contains(@text,'Your Story') or contains(@text,'Story')]",

            # B) Layout complet du bouton de story (container)
            "//android.widget.FrameLayout[@resource-id='com.zhiliaoapp.musically:id/mnh']/android.widget.LinearLayout",
            "//android.widget.FrameLayout[@resource-id='com.zhiliaoapp.musically:id/mnh']",

            # C) Autres vues associ√©es au bouton "Your Story"
            "//android.view.View[@resource-id='com.zhiliaoapp.musically:id/app']",
            "//android.widget.FrameLayout[@resource-id='com.zhiliaoapp.musically:id/mni']",
            "//android.widget.ImageView[@resource-id='com.zhiliaoapp.musically:id/hlr']",
        ],
        delay=1.5 * TT_FACTOR,
    )

    # D) Derni√®re chance : UiSelector sur le texte
    if not clicked_publish:
        clicked_publish = _maybe_click(
            driver,
            [
                'new UiSelector().text("Your Story")',
                'new UiSelector().textContains("Story")',
                'new UiSelector().descriptionContains("Your Story")',
                'new UiSelector().descriptionContains("Story")',
            ],
            delay=1.5 * TT_FACTOR,
            strategy="uiautomator",
        )

    if clicked_publish:
        log("‚úÖ Vid√©o post√©e en story TikTok.")
    else:
        log("[TT] ‚ö†Ô∏è Bouton de publication TikTok introuvable : story non confirm√©e.")


# ===================== ROUTAGE (hooks) =====================
def pre_platform_setup(driver, platform: str, options: dict | None):
    """
    Hook AVANT d‚Äôentrer dans la Galerie (utile pour Facebook : switch de page).
    options possibles :
      - page ('CM' / 'CI')
      - page_name (nom libre saisi en UI, prioritaire)
    """
    if platform == "Facebook":
        page_code = (options or {}).get("page")
        page_name = (options or {}).get("page_name")  # vient du front
        if page_code or page_name:
            fb_preselect_page(driver, page_code, page_name)

def share_to_platform(driver, platform: str, options: dict | None = None) -> None:
    """
    Action APR√àS avoir tap√© 'Share' dans la Galerie.
    """
    options = options or {}
    platform = (platform or "").strip()

    if platform == "WhatsApp":
        # On se contente d‚Äôouvrir la feuille WAB, le reste est fait dans engine_intro
        share_to_whatsapp_status(driver)
        return

    if platform == "Facebook":
        share_to_facebook(driver, options)
        return

    if platform == "Instagram":
        # Plus de variante IG : un seul Instagram par t√©l√©phone
        share_to_instagram(driver)
        return


    if platform == "TikTok":
        share_to_tiktok(driver)
        return

    log(f"[WARN] Plateforme inconnue pour share_to_platform : {platform}")



############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui
RELATIVE: ui
############################################################################################################################################
SUBDIRS:
  üìÅ tabs/
  üìÅ ui_admin/

FILES:
  üêç app.py (16973 bytes)
  üêç ui_devices.py (38073 bytes)
  üêç ui_events_router.py (2952 bytes)
  üêç ui_paths_helpers.py (8906 bytes)
  üêç ui_runner.py (12655 bytes)
  üêç ui_scheduler.py (9365 bytes)
  üêç ui_time.py (6602 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: app.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\app.py
============================================================================================================================================
# -*- coding: utf-8 -*-
import PySimpleGUI as sg

from ui.ui_devices import ensure_appium_running
from ui.ui_events_router import route_event
from ui.ui_admin.ui_admin import handle_admin_events
from ui.ui_time import (
    init_time_controls,
    auto_refresh_manual_time,
    get_manual_hhmm,
    update_time_selectors_from_profile,
    write_clock_state,          # üëà AJOUT
)

from ui.ui_scheduler import handle_scheduler_events, stop_scheduler
from ui.ui_runner import handle_runner_events
from ui.ui_devices import auto_connect_all_devices, get_last_usb_serials
from ui.ui_paths_helpers import (
    load_profiles_dict,
    load_systems_dict,
    load_matrix_rows,
    load_albums_dict,
    load_ui_state,
    save_ui_state,
    append_log,
    build_catalog_from_matrix,  # üëà AJOUT
    INTRO_ALBUM_CHOICES,  # üëà AJOUT
    MULTI_ALBUM_CHOICES,  # üëà AJOUT
    CONFIG,
    load_json,
)
from ui.tabs.ui_tabs_launcher import build_launcher_tab, update_platform_fields
from ui.tabs.ui_tabs_admin import (
    build_profiles_tab,
    build_systems_tab,
    build_matrix_tab,
    build_albums_tab,
    build_pages_tab,
    refresh_profiles_table,
    refresh_systems_table,
    refresh_matrix_table,
    refresh_albums_table,
)
from ui.tabs.ui_tabs_sched_devices import build_devices_tab, make_sched_tab
from ui.tabs.ui_tabs_locators import build_locators_tab


def main():
    # print("[StoryFX] Initialisation environnement‚Ä¶")
    # ensure_appium_running()     # ‚Üê configure ADB + Appium automatiquement

    sg.theme("DarkBlue3")

    # -------------------------------------------
    # üî• 1) Construction DES TABS
    # -------------------------------------------
    tab_launcher  = sg.Tab("Launcher",       build_launcher_tab())
    tab_pages     = sg.Tab("Pages",          build_pages_tab())
    tab_profiles  = sg.Tab("Profiles",       build_profiles_tab())
    tab_devices   = sg.Tab("Devices",        build_devices_tab())
    tab_systems   = sg.Tab("Systems",        build_systems_tab())
    tab_matrix    = sg.Tab("Matrix",         build_matrix_tab())
    tab_albums    = sg.Tab("Albums",         build_albums_tab())
    tab_sched     = sg.Tab("Programmation",  make_sched_tab())
    tab_locators  = sg.Tab("Locators",       build_locators_tab())

    layout = [[
        sg.TabGroup(
            [[tab_launcher, tab_pages, tab_profiles, tab_devices, tab_systems, tab_matrix, tab_albums, tab_sched, tab_locators]],
            expand_x=True,
            expand_y=True,
            key="-TABS-"
        )
    ]]

    win = sg.Window("StoryFX ‚Äì Final Edition", layout, finalize=True, resizable=True)

    # -------------------------------------------
    # üî• 2) Charger les donn√©es
    # -------------------------------------------
    profiles    = load_profiles_dict()
    systems     = load_systems_dict()
    matrix_rows = load_matrix_rows()
    albums_dict = load_albums_dict()
    ui_state    = load_ui_state()

    # Catalogue albums / pages (pages non utilis√©es ici)
    albums_from_matrix, _, _ = build_catalog_from_matrix(matrix_rows)

    # Combos ALBUMS (les listes viennent d√©j√† de INTRO_ALBUM_CHOICES / MULTI_ALBUM_CHOICES)
    win["-ALBUM-"].update(values=INTRO_ALBUM_CHOICES)
    win["-ALBUM2-"].update(values=MULTI_ALBUM_CHOICES)

    # ‚ö†Ô∏è On NE met plus √† jour -PAGE- / -PAGE_NAME- ici,
    # ils sont remplis directement depuis config/pages.json dans build_launcher_tab().

    # -------------------------------------------
    # üî• 2A) Remplir le Combo PROFIL
    # -------------------------------------------
    profile_names = list(profiles.keys())
    win["-PROFILE-"].update(values=profile_names)

    # S√©lectionner automatiquement le premier profil si tu veux
    if profile_names:
        win["-PROFILE-"].update(value=profile_names[0])
        # Appliquer directement les heures & minutes du premier profil
        update_time_selectors_from_profile(
            win,
            profile_names[0],
            systems,
            matrix_rows,
            profiles,
        )

    # -------------------------------------------
    # üî• 3) Remplir les tables Admin
    # -------------------------------------------
    refresh_profiles_table(win, profiles, matrix_rows)
    refresh_systems_table(win, systems)
    refresh_matrix_table(win, matrix_rows)
    refresh_albums_table(win, albums_dict)

    # -------------------------------------------
    # üî• 4) Initialiser HEURE (AUTO)
    # -------------------------------------------
    clock_path = CONFIG / "scheduler_clock.json"

    init_time_controls(win, clock_path)

    # -------------------------------------------
    # üî• 5) Contextes (r√©f√©rences runner + scheduler)
    # -------------------------------------------
    scheduler_ref = {"proc": None}
    runner_ref    = {"proc": None}

    editing_manual_time = False
    tick_counter = 0

    # -------------------------------------------
    # üî• 6) BOUCLE PRINCIPALE
    # -------------------------------------------
    while True:
        ev, vals = win.read(timeout=100)

        if ev in (sg.WINDOW_CLOSED, "Quitter"):
            break

        # 1) ROUTAGE DE L'√âV√âNEMENT
        category = route_event(ev, vals)

        # üî• Quand on change de PROFIL dans le launcher :
        # ‚Üí on met √† jour les heures (systems.json) et les minutes (offset_minutes)
        if ev == "-PROFILE-":
            profile_name = vals.get("-PROFILE-")
            if profile_name:
                update_time_selectors_from_profile(
                    win,
                    profile_name,
                    systems,
                    matrix_rows,
                    profiles,
                )
            continue
        # --------------------------------------
        # A) UI TEMPS
        # --------------------------------------
        if category == "time":

            # 1) Toggle Auto ‚Üî Manuel
            if ev in ("-TIME_AUTO-", "-TIME_MANUAL-"):
                auto_mode = vals["-TIME_AUTO-"]

                if auto_mode:
                    # Repasser en mode AUTO (heure PC) et √©crire dans le JSON
                    init_time_controls(win, clock_path)
                    append_log(win, "[Time] Mode auto activ√©.")
                else:
                    # Passage en MANUEL : d√©verrouiller HH/MM
                    for k in ("-TIME_HH-", "-TIME_MM-"):
                        win[k].update(disabled=False)

                    # On enregistre l'heure manuelle actuelle comme point de d√©part
                    hhmm = get_manual_hhmm(vals)
                    if hhmm:
                        write_clock_state(clock_path, "manual", hhmm)
                        append_log(win, f"[Time] Mode manuel activ√© : {hhmm}")

                editing_manual_time = False
                continue

            # 2) L‚Äôutilisateur change HH ou MM en mode MANUEL
            if ev in ("-TIME_HH-", "-TIME_MM-") and vals.get("-TIME_MANUAL-"):
                hhmm = get_manual_hhmm(vals)
                if hhmm:
                    write_clock_state(clock_path, "manual", hhmm)
                    append_log(win, f"[Time] Nouvelle heure manuelle : {hhmm}")
                editing_manual_time = False
                continue


        # --------------------------------------
        # B) ADMIN (Profiles / Systems / Matrix / Albums / Pages / Locators)
        # --------------------------------------
        if category in ("profiles", "systems", "matrix", "albums", "pages", "locators"):
            handled = handle_admin_events(
                ev, vals, win,
                profiles, systems, matrix_rows, albums_dict
            )
            if handled:
                continue

        # --------------------------------------
        # C) SCHEDULER
        # --------------------------------------
        if category == "scheduler":
            handled = handle_scheduler_events(
                ev, vals, win,
                scheduler_ref,
                albums_dict,
                matrix_rows
            )
            if handled:
                continue

        # --------------------------------------
        # D) RUNNER
        # --------------------------------------
        if category == "runner":
            handled = handle_runner_events(
                ev, vals, win,
                runner_ref,
                profiles,
                albums_dict,
                "ui_state.json"
            )
            if handled:
                continue

        # --------------------------------------
        # E) DEVICES
        # --------------------------------------
        # --------------------------------------
        # E) DEVICES
        # --------------------------------------
        if category == "adb":

            # --- 1) Scanner & connecter (USB ‚Üí Wi-Fi)
            if ev == "-DEV_SCAN_CONNECT-":
                from ui.ui_devices import list_devices_pro
                import threading

                # ‚úÖ Phase 1 (ms) : afficher √©tat ADB imm√©diat
                win["-DEV_LOG-"].update("‚è≥ Scan & connect en cours...\n")
                win["-DEV_LOG-"].update(list_devices_pro(with_ping=False), append=True)

                # ‚úÖ Phase 2 (lente) : vraie auto-connexion en background
                def _worker_scan():
                    # 1) Travail principal (long)
                    full = auto_connect_all_devices(profiles)

                    # 2) Affichage IMM√âDIAT du r√©sultat principal
                    win.write_event_value("-DEV_SCAN_DONE-", full)

                    # 3) LANCER le ping APR√àS (sans bloquer)
                    from ui.ui_devices import list_devices_pro
                    pinged = list_devices_pro(with_ping=True)
                    win.write_event_value("-DEV_PING_DONE-", pinged)

                threading.Thread(target=_worker_scan, daemon=True).start()
                continue

            # --- 2) `adb devices` PRO
            if ev in ("-DEV_LIST-", "-DEV_DEVICES-"):
                from ui.ui_devices import list_devices_pro
                import threading

                # 1) Phase rapide : ADB seulement (millisecondes)
                log_fast = list_devices_pro(with_ping=False)
                win["-DEV_LOG-"].update(log_fast)

                # 2) Phase lente : Ping (en background), puis update UI
                def _worker_ping():
                    log_full = list_devices_pro(with_ping=True)
                    win.write_event_value("-DEV_PING_DONE-", log_full)

                threading.Thread(target=_worker_ping, daemon=True).start()

                continue

            if ev == "-DEV_PING_DONE-":
                full = vals.get("-DEV_PING_DONE-", "")
                if full:
                    win["-DEV_LOG-"].update(full)
                continue

            if ev == "-DEV_SCAN_DONE-":
                full = vals.get("-DEV_SCAN_DONE-", "")
                if full:
                    win["-DEV_LOG-"].update(full)
                continue

            if ev == "-DEV_CONNECT_ALL_DONE-":
                full = vals.get("-DEV_CONNECT_ALL_DONE-", "")
                if full:
                    win["-DEV_LOG-"].update(full)
                continue

            if ev == "-DEV_DISCONNECT_DONE-":
                full = vals.get("-DEV_DISCONNECT_DONE-", "")
                if full:
                    win["-DEV_LOG-"].update(full)
                continue

            # --- 3) Copier serial(s) d√©tect√©s en USB
            if ev == "-DEV_COPY_SERIAL-":
                serials = get_last_usb_serials()
                if serials:
                    sg.clipboard_set(", ".join(serials))
                    append_log(win, f"[Devices] Serials copi√©s : {serials}")
                else:
                    sg.popup_error("Aucun serial USB d√©tect√©.\nClique d'abord sur Scanner & connecter.")
                continue

            # --- 4) Connecter TOUT (connexion PRO)
            if ev == "-DEV_CONNECT_ALL-":
                from ui.ui_devices import list_devices_pro, connect_all_devices
                import threading

                # ‚úÖ Phase 1 (ms) : √©tat ADB imm√©diat
                win["-DEV_LOG-"].update("‚è≥ Connecter tout en cours...\n")
                win["-DEV_LOG-"].update(list_devices_pro(with_ping=False), append=True)

                # ‚úÖ Phase 2 (lente) : connect_all_devices en background
                def _worker_connect_all():
                    # 1) Connexion globale (long)
                    full = connect_all_devices()

                    # 2) Affichage imm√©diat
                    win.write_event_value("-DEV_CONNECT_ALL_DONE-", full)

                    # 3) Ping APR√àS
                    from ui.ui_devices import list_devices_pro
                    pinged = list_devices_pro(with_ping=True)
                    win.write_event_value("-DEV_PING_DONE-", pinged)

                threading.Thread(target=_worker_connect_all, daemon=True).start()
                continue

            # --- 5) D√©connecter TOUT (reset adb)
            if ev == "-DEV_DISCONNECT-":
                from ui.ui_devices import list_devices_pro, disconnect_all_devices
                import threading

                # ‚úÖ Phase 1 (ms) : √©tat ADB imm√©diat
                win["-DEV_LOG-"].update("‚è≥ D√©connecter tout en cours...\n")
                win["-DEV_LOG-"].update(list_devices_pro(with_ping=False), append=True)

                # ‚úÖ Phase 2 (lente) : disconnect_all_devices en background
                def _worker_disconnect():
                    # 1) Reset ADB (long)
                    full = disconnect_all_devices()

                    # 2) Affichage imm√©diat
                    win.write_event_value("-DEV_DISCONNECT_DONE-", full)

                    # 3) Ping APR√àS
                    from ui.ui_devices import list_devices_pro
                    pinged = list_devices_pro(with_ping=True)
                    win.write_event_value("-DEV_PING_DONE-", pinged)

                threading.Thread(target=_worker_disconnect, daemon=True).start()
                continue

            # --- 6) Effacer le log
            if ev == "-DEV_CLEAR-":
                win["-DEV_LOG-"].update("")
                continue


        # F) LAUNCHER (albums, plateformes, engine‚Ä¶)
        if category == "launcher":

            # 1) Effacer le log COMPLET
            if ev == "-CLEAR_LOG-":
                win["-LOG-"].update("")
                continue

            # 2) Aller automatiquement vers l‚Äôonglet Admin (Profiles)
            if ev == "-GOTO_ADMIN-":
                try:
                    win["-TABS-"].Widget.select(1)   # Onglet Profiles
                except Exception:
                    pass
                continue

            # 3) Changement de plateforme
            if ev == "-PLATFORM-":
                update_platform_fields(win, vals["-PLATFORM-"])
                continue

            # 4) Changement d‚Äôalbum
            #    - L'album intro NE TOUCHE JAMAIS √† Count (toujours 1 pour l'intro)
            #    - Seul l'album multi met √† jour Count, et seulement si l'engine
            #      n'est pas "intro".
            if ev in ("-ALBUM-", "-ALBUM2-"):

                # Si c'est l'album intro ‚Üí on ne change rien
                if ev == "-ALBUM-":
                    continue

                # Ici on sait que ev == "-ALBUM2-" (album multi)
                album_name = (vals.get("-ALBUM2-") or "").strip()
                engine = (vals.get("-ENGINE-") or "").strip()

                # Si l'engine est "intro" ‚Üí Count reste 1
                if engine == "intro":
                    win["-COUNT-"].update(value=1)
                    continue

                # Sinon (multi ou intro+multi), on synchronise Count avec l'album
                if album_name and isinstance(albums_dict, dict):
                    cfg = albums_dict.get(album_name) or {}
                    default_count = cfg.get("count_per_post") or cfg.get("album_size") or 0
                    try:
                        default_count = int(default_count)
                    except Exception:
                        default_count = 0

                    if default_count <= 0:
                        default_count = 1  # s√©curit√©

                    win["-COUNT-"].update(value=default_count)

                continue

        # --------------------------------------
        # G) AUTO-REFRESH DE L'HEURE MANUELLE
        # --------------------------------------
        tick_counter += 1
        if tick_counter >= 10:
            tick_counter = 0
            if vals.get("-TIME_MANUAL-") and not editing_manual_time:
                auto_refresh_manual_time(win, editing_manual_time)

    # Arr√™ter scheduler si encore en cours
    if scheduler_ref["proc"] and scheduler_ref["proc"].poll() is None:
        stop_scheduler(win, scheduler_ref)

    win.close()

if __name__ == "__main__":
    main()


============================================================================================================================================
FILE: ui_devices.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_devices.py
============================================================================================================================================
# ui/ui_devices.py
# -*- coding: utf-8 -*-
"""
Module ADB complet pour StoryFX (version PRO refondue).

Fonctionnalit√©s :
    ‚úî auto_connect_all_devices (USB ‚Üí Wi-Fi)
    ‚úî connect_all_devices (connexion PRO)
    ‚úî disconnect_all_devices (reset serveur ADB, vue PRO)
    ‚úî list_devices_pro (vue PRO avec üü¢ / üî¥ / ‚ö™ + fusion des profils)
    ‚úî copier serial(s) (via LAST_USB_SERIALS + get_last_usb_serials)
    ‚úî propagation automatique IP/port/device_id entre profils li√©s
    ‚úî mapping centralis√© des devices (Wi-Fi / USB / d√©sactiv√©s)
    ‚úî logs propres format√©s, sans doublons

CONVENTIONS :
    - Un "p√©riph√©rique r√©el" est identifi√© par son device_id (IP:PORT).
    - Plusieurs profils peuvent partager le m√™me device_id : ils sont fusionn√©s
      dans l'affichage (ex: S23 (WA, IG, FB_CM, FB_CI, TikTok) (192.168.1.123:5555)).
    - Les serials USB sont affich√©s UNIQUEMENT dans la section USB.
"""
import shutil
from concurrent.futures import ThreadPoolExecutor
import requests

import os
import time
import socket
import subprocess

APPIUM_HOST = "127.0.0.1"
APPIUM_PORT = 4723
ADB_STORYFX = r"C:\Tools\ADB_StoryFX\adb.exe"   # ton adb s√©par√©
ADB_PORT_STORYFX = "5038"                      # IMPORTANT: ne touche pas 5037

from typing import Dict, Any, List, Tuple
import re
from subprocess import Popen, PIPE

from ui.ui_paths_helpers import (
    adb_run,
    load_profiles_dict,
    save_json,
    PROFILES,
)

# M√©morise les derniers serials USB d√©tect√©s (pour le bouton "Copier serial(s)")
LAST_USB_SERIALS: List[str] = []

# ==========================================================================
# üî• Ensure Appium Running (Auto-start si Appium n'est pas lanc√©)
# ==========================================================================

def scan_adb_devices_fast() -> tuple[set, set, str, str]:
    """
    Scan ultra rapide (preuve 5037 + 5038):
    - USB via 5037 (adb_run_sdk)
    - Wi-Fi via 5038 (adb_run)
    - ex√©cute 5037 et 5038 en parall√®le
    Retourne:
      usb_serials_device, wifi_ids_device, out_5037, out_5038
    """

    def _usb_5037():
        _, out = adb_run_sdk("adb devices")
        usb = set()
        for serial, status in _parse_adb_devices(out):
            if _is_emulator_serial(serial):
                continue
            if ":" in serial:
                continue
            if status == "device":
                usb.add(serial)
        return usb, (out or "")

    def _wifi_5038():
        _, out = adb_run("adb devices")  # 5038
        wifi = set()
        for serial, status in _parse_adb_devices(out):
            if _is_emulator_serial(serial):
                continue
            if ":" in serial and status == "device":
                wifi.add(serial)
        return wifi, (out or "")

    with ThreadPoolExecutor(max_workers=2) as ex:
        f_usb = ex.submit(_usb_5037)
        f_wifi = ex.submit(_wifi_5038)
        usb, out_5037 = f_usb.result()
        wifi, out_5038 = f_wifi.result()

    # fallback wifi lecture 5037 si 5038 vide
    if not wifi:
        for serial, status in _parse_adb_devices(out_5037):
            if _is_emulator_serial(serial):
                continue
            if ":" in serial and status == "device":
                wifi.add(serial)

    return usb, wifi, out_5037, out_5038

# ============================================================
# 1) ADB ANDROID STUDIO ‚Üí PORT 5037
# ============================================================
def start_android_studio_adb():
    """
    D√©marre ADB Android Studio sur le port 5037.
    Garantit que l‚ÄôADB officiel ne vole pas le port 5038.
    """

    SDK_ADB = r"C:\Users\lilgu\AppData\Local\Android\Sdk\platform-tools\adb.exe"

    # kill-server NE d√©pend PAS de ANDROID_ADB_SERVER_PORT
    subprocess.run([SDK_ADB, "kill-server"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # start-server d√©marre TOUJOURS sur 5037
    subprocess.run([SDK_ADB, "start-server"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# ============================================================
# 2) ADB STORYFX ‚Üí PORT 5038
# ============================================================
# def start_storyfx_adb():
#     """
#     Lance le serveur ADB StoryFX (port 5038).
#     Utilis√© pour g√©rer les t√©l√©phones en WiFi + Appium.
#     """
#
#     # FORCER UNIQUEMENT CE PROCESSUS √Ä UTILISER 5038
#     os.environ["ANDROID_ADB_SERVER_PORT"] = "5038"
#
#     STORYFX_ADB = r"C:\Tools\ADB_StoryFX\adb.exe"
#
#     # Red√©marrage complet
#     subprocess.run([STORYFX_ADB, "kill-server"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
#     subprocess.run([STORYFX_ADB, "start-server"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
#

from pathlib import Path

def _parse_adb_devices(out: str):
    """Parse adb devices ‚Üí [(serial, status), ...] sans l'ent√™te."""
    items = []
    for line in (out or "").splitlines():
        line = line.strip()
        if not line:
            continue
        if line.lower().startswith("list of devices"):
            continue
        parts = line.split()
        if len(parts) >= 2:
            items.append((parts[0].strip(), parts[1].strip()))
    return items

def _is_emulator_serial(serial: str) -> bool:
    s = (serial or "").lower()
    return ("emulator" in s) or ("5554" in s)

def launch_appium_from_bat():
    try:
        bat_path = Path(__file__).resolve().parents[1] / "Lancer_Appium_StoryFX.bat"
        subprocess.Popen(str(bat_path), shell=True)
        return True
    except Exception:
        return False


# ============================================================
# 3) ASSURER APPIUM ‚Üí PORT 4723 + ADB PORT 5038
# ============================================================
def ensure_appium_running(win=None) -> bool:
    """
    SAFE: ne tue ni adb global, ni node global.
    - Assure adb StoryFX sur port 5038
    - D√©marre Appium sur 4723 avec --adb-port 5038
    - Ne touche pas FormaFX (adb 5037 + √©mulateur)
    """

    # 1) Si Appium est d√©j√† UP -> OK (mais on v√©rifie le STATUS, pas juste le port)
    try:
        with socket.create_connection((APPIUM_HOST, APPIUM_PORT), timeout=0.5):
            # ‚úÖ health check /status
            try:
                r = requests.get(f"http://{APPIUM_HOST}:{APPIUM_PORT}/wd/hub/status", timeout=0.8)
                if r.status_code == 200:
                    return True
            except Exception:
                # port ouvert mais appium pas pr√™t ‚Üí on continue pour relancer/attendre
                pass
    except Exception:
        pass

    # 2) D√©marrer le serveur ADB StoryFX sur 5038 (sans impacter 5037)
    env = os.environ.copy()
    env["ANDROID_ADB_SERVER_PORT"] = str(ADB_PORT_STORYFX)

    try:
        subprocess.run(
            [ADB_STORYFX, "start-server"],
            env=env,
            capture_output=True,
            text=True
        )
    except Exception as e:
        if win:
            win.write_event_value(
                "-RUNNER-LOG-",
                f"[StoryFX] [WARN] adb start-server 5038 failed: {e!r}"
            )
        # on continue quand m√™me

    # 3) D√©marrer Appium
    appium_bin = shutil.which("appium") or shutil.which("appium.cmd") or "appium"

    cmd = [
        appium_bin,
        "--allow-cors",
        "--relaxed-security",
        "--base-path", "/wd/hub",
        "--address", APPIUM_HOST,
        "--port", str(APPIUM_PORT),
        "--adb-port", str(ADB_PORT_STORYFX),
    ]

    proc = None
    env["PATH"] = r"C:\Tools\ADB_StoryFX;" + env.get("PATH", "")

    try:
        proc = subprocess.Popen(
            " ".join(cmd),
            env=env,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            shell=True,
        )
    except FileNotFoundError:
        # fallback : on tente de lancer via le .bat (si 'appium' n'est pas dans le PATH)
        if launch_appium_from_bat():
            # attendre que 4723 √©coute
            for _ in range(60):  # ~15s
                try:
                    with socket.create_connection((APPIUM_HOST, APPIUM_PORT), timeout=0.5):
                        return True
                except Exception:
                    time.sleep(0.25)

        msg = "[Appium] introuvable. Installe Appium ou ajoute-le au PATH (ou v√©rifie Lancer_Appium_StoryFX.bat)."
        if win:
            win.write_event_value("-RUNNER-LOG-", msg)
        return False

    # 4) Attendre que 4723 √©coute (port ouvert)
    port_ok = False
    for _ in range(60):  # ~15 sec
        try:
            with socket.create_connection((APPIUM_HOST, APPIUM_PORT), timeout=0.5):
                port_ok = True
                break
        except Exception:
            time.sleep(0.25)

    # ‚úÖ Si le port n'est m√™me pas ouvert ‚Üí erreur classique
    if not port_ok:
        # (ton code de r√©cup√©ration logs Appium reste apr√®s)
        pass
    else:
        # 4bis) ‚úÖ V√©rifier que Appium r√©pond vraiment (status OK)
        try:
            for _ in range(20):
                try:
                    r = requests.get(f"http://{APPIUM_HOST}:{APPIUM_PORT}/wd/hub/status", timeout=0.8)
                    if r.status_code == 200:
                        return True
                except Exception:
                    time.sleep(0.25)
        except Exception:
            pass

    # 5) Si √ßa ne d√©marre pas, on r√©cup√®re quelques lignes du log Appium
    out = ""
    if proc and proc.stdout:
        try:
            for _ in range(40):
                line = proc.stdout.readline()
                if not line:
                    break
                out += line
        except Exception:
            pass

    raise RuntimeError(
        f"Appium ne d√©marre pas sur {APPIUM_HOST}:{APPIUM_PORT}. "
        f"V√©rifie que la commande 'appium' existe et que le port n'est pas occup√©.\n"
        f"--- Appium output ---\n{out}"
    )

# ==========================================================================
# üî• 0. Helpers g√©n√©riques : mapping, labels, adb devices
# ==========================================================================

def build_devices_mapping(profiles: dict) -> Tuple[dict, dict, dict, int]:
    """
    Construit TOUT le mapping des appareils r√©els √† partir de profiles.json.

    Retourne :
        wifi_map      : dict[device_id] -> [profil1, profil2, ...] (uniquement enabled)
        usb_map       : dict[serial]    -> [profil1, profil2, ...] (uniquement enabled)
        disabled_map  : dict[device_id] -> [profils d√©sactiv√©s]
        unique_count  : nombre total de t√©l√©phones r√©els (len(wifi_map))

    NOTE :
        - On consid√®re que l'identifiant "unique" d'un t√©l√©phone est son device_id (IP:PORT).
        - Les serials USB servent uniquement √† savoir quel t√©l√©phone est branch√© en USB.
    """
    wifi_map: Dict[str, List[str]] = {}
    usb_map: Dict[str, List[str]] = {}
    disabled_map: Dict[str, List[str]] = {}

    for name, cfg in profiles.items():
        dev_id = (cfg.get("device_id") or "").strip()
        serial = (cfg.get("adb_serial") or "").strip()
        enabled = cfg.get("enabled", True)

        if not enabled:
            if dev_id:
                disabled_map.setdefault(dev_id, []).append(name)
            else:
                # p√©riph√©rique d√©sactiv√© sans device_id (rare)
                disabled_map.setdefault("", []).append(name)
            continue

        if dev_id:
            wifi_map.setdefault(dev_id, []).append(name)

        if serial:
            usb_map.setdefault(serial, []).append(name)

    unique_count = len(wifi_map)
    return wifi_map, usb_map, disabled_map, unique_count


def fusion_label(profiles_list: List[str]) -> str:
    """
    Cr√©e un label fusionn√© PRO √† partir d'une liste de profils.

    Exemples :
        ["S23_FB_CM", "S23_IG", "S23_WA"]
            ‚Üí "S23 (FB_CM, IG, WA)"

        ["A16"]
            ‚Üí "A16"
    """
    if not profiles_list:
        return ""

    # Pr√©fixe principal (avant le premier "_")
    prefixes = [p.split("_")[0] for p in profiles_list]
    main_prefix = prefixes[0]

    # Noms courts (on enl√®ve "S23_", "G2_", etc.)
    short_names = [p.replace(main_prefix + "_", "") for p in profiles_list]

    if len(profiles_list) == 1:
        # Un seul profil ‚Üí on garde le nom brut
        return profiles_list[0]

    joined = ", ".join(short_names)
    return f"{main_prefix} ({joined})"

def _get_usb_serials_and_port() -> tuple[list[str], int, str, str]:
    """
    Cherche les serials USB sur 5038 d'abord, puis 5037.
    Retourne : (serials, port_used, raw5038, raw5037)
    """
    # 5038
    _, out_38 = adb_run("adb devices")
    usb_38 = [s for s, st in _parse_adb_devices(out_38)
              if st == "device" and ":" not in s and not _is_emulator_serial(s)]

    # 5037 (m√™me adb.exe mais port serveur 5037)
    _, out_37 = adb_run("adb devices", port=5037)
    usb_37 = [s for s, st in _parse_adb_devices(out_37)
              if st == "device" and ":" not in s and not _is_emulator_serial(s)]

    if usb_38:
        return sorted(usb_38), 5038, (out_38 or ""), (out_37 or "")
    return sorted(usb_37), 5037, (out_38 or ""), (out_37 or "")

def adb_run_sdk(cmd: str):
    """
    Ex√©cute une commande ADB via le binaire Android Studio (serveur 5037).
    Utilis√© pour tout ce qui touche l'USB (devices, ip route, tcpip).
    """
    SDK_ADB = r"C:\Users\lilgu\AppData\Local\Android\Sdk\platform-tools\adb.exe"
    env = os.environ.copy()
    # on s'assure de parler au serveur par d√©faut (5037)
    env.pop("ANDROID_ADB_SERVER_PORT", None)

    cmd = cmd.strip()
    if cmd.startswith("adb "):
        cmd = f"\"{SDK_ADB}\" {cmd[4:]}"
    elif cmd == "adb":
        cmd = f"\"{SDK_ADB}\""

    try:
        proc = subprocess.run(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            env=env,
        )
        return proc.returncode, proc.stdout
    except Exception as e:
        return 1, str(e)

def build_device_name_map(profiles: dict) -> dict:
    """
    Mapping brut : serial_ou_device_id -> nom lisible (label).

    Utilis√© surtout pour :
        - auto_connect_all_devices (affichage adb devices brut)
        - fallback pour les devices non fusionn√©s
    """
    name_map = {}
    for prof_name, cfg in profiles.items():
        label = cfg.get("label", prof_name)
        serial = (cfg.get("adb_serial") or "").strip()
        device_id = (cfg.get("device_id") or "").strip()

        if serial:
            name_map[serial] = label
        if device_id:
            name_map[device_id] = label
    return name_map


def _extract_ip_from_ip_route(text: str) -> str | None:
    """Analyse 'adb shell ip route' et r√©cup√®re l'IP Wi-Fi."""
    m = re.search(r"\bsrc\s+(\d+\.\d+\.\d+\.\d+)", text)
    if m:
        return m.group(1)

    # fallback g√©n√©rique
    m = re.search(r"(\d+\.\d+\.\d+\.\d+)", text)
    if m:
        return m.group(1)

    return None


def _build_adb_index(profiles: Dict[str, Dict[str, Any]]) -> Dict[str, List[str]]:
    """Construit serial ‚Üí liste des profils utilisant ce serial USB."""
    idx: Dict[str, List[str]] = {}
    for name, cfg in profiles.items():
        serial = (cfg.get("adb_serial") or "").strip()
        if serial:
            idx.setdefault(serial, []).append(name)
    return idx


def get_last_usb_serials() -> List[str]:
    """Retourne la derni√®re liste de serials USB d√©tect√©s (pour le bouton Copier serial(s))."""
    return LAST_USB_SERIALS


def scan_adb_devices(wait_seconds: float = 3.0, poll_interval: float = 0.4) -> Tuple[set, set, str]:
    """
    Version PRO (stable + multi-ports) :
    - USB: scan/poll sur 5037 (adb_run_sdk) + capture unauthorized/offline
    - Wi-Fi: priorit√© 5038 (adb_run)
      fallback lecture 5037 si 5038 ne voit aucun ip:port device
    - ignore emulator/5554
    - retourne:
        usb_serials_device : serials USB OK (status=device)
        wifi_ids_device    : ip:port OK (status=device)
        raw_output         : logs combin√©s (avec statuts)
    """

    # Assurer ADB 5037 vivant
    try:
        start_android_studio_adb()
    except Exception:
        pass

    usb_serials_device = set()
    wifi_ids_device = set()

    usb_other_status: list[tuple[str, str]] = []
    wifi_other_status: list[tuple[str, str]] = []

    out_usb_final = ""
    out_wifi_5038 = ""
    out_wifi_5037 = ""

    # -------------------------
    # 1) Poll USB (5037)
    # -------------------------
    t0 = time.time()
    while time.time() - t0 < wait_seconds:
        _, out_usb = adb_run_sdk("adb devices")
        out_usb_final = out_usb or ""

        usb_serials_device.clear()
        usb_other_status.clear()

        for serial, status in _parse_adb_devices(out_usb_final):
            if _is_emulator_serial(serial):
                continue
            # USB => pas de ":" (sinon c'est ip:port)
            if ":" in serial:
                continue

            if status == "device":
                usb_serials_device.add(serial)
            else:
                usb_other_status.append((serial, status))

        # stop t√¥t si on a au moins 1 device USB pr√™t
        if usb_serials_device:
            break

        time.sleep(poll_interval)

    # -------------------------
    # 2) Wi-Fi priorit√© 5038 (StoryFX)
    # -------------------------
    _, out_wifi_5038 = adb_run("adb devices")  # 5038 par d√©faut dans ton app
    out_wifi_5038 = out_wifi_5038 or ""

    wifi_ids_device.clear()
    wifi_other_status.clear()

    for serial, status in _parse_adb_devices(out_wifi_5038):
        if _is_emulator_serial(serial):
            continue
        if ":" not in serial:
            continue

        if status == "device":
            wifi_ids_device.add(serial)
        else:
            wifi_other_status.append((serial, status))

    # -------------------------
    # 3) Fallback lecture Wi-Fi sur 5037 si 5038 ne voit rien
    # -------------------------
    if not wifi_ids_device:
        _, out_wifi_5037 = adb_run_sdk("adb devices")
        out_wifi_5037 = out_wifi_5037 or ""

        for serial, status in _parse_adb_devices(out_wifi_5037):
            if _is_emulator_serial(serial):
                continue
            if ":" not in serial:
                continue

            if status == "device":
                wifi_ids_device.add(serial)
            else:
                wifi_other_status.append((serial, status))

    # -------------------------
    # 4) Logs propres
    # -------------------------
    raw: list[str] = []
    raw.append("=== ADB 5037 (USB / √©mulateurs) ===")
    raw.append(out_usb_final.strip() or "(vide)")

    if usb_other_status:
        raw.append("\n[USB] D√©tect√©s mais NON pr√™ts :")
        for s, st in usb_other_status:
            if st == "unauthorized":
                raw.append(f"  - {s} ‚Üí unauthorized (d√©verrouille + accepte 'Allow USB debugging')")
            elif st == "offline":
                raw.append(f"  - {s} ‚Üí offline (rebranche / change c√¢ble / attends 2s)")
            else:
                raw.append(f"  - {s} ‚Üí {st}")

    raw.append("\n=== ADB 5038 (StoryFX Wi-Fi) ===")
    raw.append(out_wifi_5038.strip() or "(vide)")

    if out_wifi_5037:
        raw.append("\n=== ADB 5037 (fallback Wi-Fi) ===")
        raw.append(out_wifi_5037.strip() or "(vide)")

    if wifi_other_status:
        raw.append("\n[Wi-Fi] D√©tect√©s mais NON pr√™ts :")
        for s, st in wifi_other_status:
            raw.append(f"  - {s} ‚Üí {st}")

    return usb_serials_device, wifi_ids_device, "\n".join(raw)

# ==========================================================================
# üî• 1. D√©connexion totale + vue PRO
# ==========================================================================

def disconnect_all_devices() -> str:
    """
    Reset ADB 5038 propre + vue PRO.
    """
    profiles = load_profiles_dict()
    wifi_map, usb_map, disabled_map, unique_count = build_devices_mapping(profiles)

    logs: List[str] = []
    logs.append("=== Reset ADB (Mode PRO) : d√©connexion de tous les appareils ===\n")

    adb_run("adb disconnect")
    adb_run("adb kill-server")
    _, out = adb_run("adb start-server")
    logs.append((out or "").strip())

    usb_connected, wifi_connected, _ = scan_adb_devices(wait_seconds=1.5, poll_interval=0.3)

    logs.append("\nüü¢ CONNECT√âS (USB) :")
    found_usb = False
    for serial, profils in usb_map.items():
        if serial in usb_connected:
            logs.append(f"   üü¢ {fusion_label(profils)} ({serial})")
            found_usb = True
    for serial in usb_connected:
        if serial not in usb_map:
            logs.append(f"   üü¢ {serial} (nouveau p√©riph√©rique USB)")
            found_usb = True
    if not found_usb:
        logs.append("   Aucun device USB connect√©.")

    logs.append("\nüü¢ CONNECT√âS (Wi-Fi) :")
    found_wifi = False
    for dev_id, profils in wifi_map.items():
        if dev_id in wifi_connected:
            logs.append(f"   üü¢ {fusion_label(profils)} ({dev_id})")
            found_wifi = True
    if not found_wifi:
        logs.append("   Aucun device Wi-Fi connect√©.")

    logs.append("\nüî¥ ABSENTS (Wi-Fi) :")
    abs_found = False
    for dev_id, profils in wifi_map.items():
        if dev_id not in wifi_connected:
            logs.append(f"   üî¥ {fusion_label(profils)} ({dev_id}) ‚Üí Hors ligne")
            abs_found = True
    if not abs_found:
        logs.append("   Aucun device absent.")

    logs.append("\n‚ö™ D√âSACTIV√âS :")
    if disabled_map:
        for dev_id, profils in disabled_map.items():
            dev_label = dev_id or "device_id inconnu"
            logs.append(f"   ‚ö™ {fusion_label(profils)} ({dev_label}) ‚Üí D√©sactiv√©")
    else:
        logs.append("   Aucun device d√©sactiv√©.")

    # comptage ‚Äúactif‚Äù
    connected_devices_ids = set()
    for dev_id in wifi_map.keys():
        if dev_id in wifi_connected:
            connected_devices_ids.add(dev_id)
            continue
        for prof_name in wifi_map[dev_id]:
            serial = (profiles.get(prof_name, {}).get("adb_serial") or "").strip()
            if serial and serial in usb_connected:
                connected_devices_ids.add(dev_id)
                break

    logs.append(f"\n=== R√©sultat : {len(connected_devices_ids)} / {unique_count} p√©riph√©riques actifs ===")
    return "\n".join(logs)

# ==========================================================================
# üî• 2. Auto-connexion USB ‚Üí Wi-Fi compl√®te
# ==========================================================================

def auto_connect_all_devices(profiles: Dict[str, Dict[str, Any]]) -> str:
    """
    Auto-connexion USB ‚Üí Wi-Fi (version PRO multi-ports) :

    Objectif :
    - d√©tecter l‚ÄôUSB m√™me si le t√©l√©phone appara√Æt sur 5038 (ADB StoryFX) OU 5037 (ADB Android Studio)
    - ex√©cuter ip route + tcpip sur LE BON port (celui qui voit le serial USB)
    - connecter ensuite en Wi-Fi sur 5038
    - mettre √† jour profiles.json + propagation des profils li√©s

    Notes :
    - ADB Wi-Fi (ip:port) doit √™tre connect√© sur 5038 (adb_run par d√©faut)
    - On ignore emulator / 5554
    """
    global LAST_USB_SERIALS

    logs: List[str] = []
    logs.append("=== Auto-connexion ADB (USB ‚Üí Wi-Fi) ===")

    # ------------------------------------------------------------------
    # 0) Reload profils (source de v√©rit√©)
    # ------------------------------------------------------------------
    profiles = load_profiles_dict()

    # ------------------------------------------------------------------
    # 1) D√©tection USB sur 5038 d'abord, sinon fallback 5037
    # ------------------------------------------------------------------
    def _usb_serials_from_output(out: str) -> list[str]:
        serials = []
        for s, st in _parse_adb_devices(out or ""):
            if st != "device":
                continue
            if _is_emulator_serial(s):
                continue
            if ":" in s:  # ip:port => pas USB
                continue
            serials.append(s)
        return serials

    # Lire USB via adb_run (5038)
    _, out_38 = adb_run("adb devices")                 # 5038 (StoryFX)
    usb_38 = _usb_serials_from_output(out_38)

    # Lire USB via adb_run(port=5037)
    _, out_37 = adb_run("adb devices", port=5037)      # 5037 (fallback)
    usb_37 = _usb_serials_from_output(out_37)

    # Choisir le port USB √† utiliser (priorit√© 5038 car ton cas r√©el)
    if usb_38:
        usb_port = 5038
        serials_usb = sorted(usb_38)
    else:
        usb_port = 5037
        serials_usb = sorted(usb_37)

    LAST_USB_SERIALS = serials_usb[:]

    logs.append("\n=== USB detection (5038 + 5037) ===")
    logs.append("[DEBUG] ADB 5038 raw (USB check):")
    logs.append((out_38 or "").strip() or "(vide)")
    logs.append("\n[DEBUG] ADB 5037 raw (USB check):")
    logs.append((out_37 or "").strip() or "(vide)")
    logs.append(f"\n‚úÖ USB port utilis√© = {usb_port}")

    if not serials_usb:
        logs.append("\n‚ùå Aucun appareil USB d√©tect√© (ni sur 5038 ni sur 5037).")
        logs.append("‚û°Ô∏è V√©rifie : c√¢ble / port USB / t√©l√©phone d√©verrouill√© / popup 'Allow USB debugging'.")
        return "\n".join(logs)

    # ------------------------------------------------------------------
    # 2) Index serial -> profils li√©s
    # ------------------------------------------------------------------
    adb_index = _build_adb_index(profiles)
    profiles_changed = False

    # ------------------------------------------------------------------
    # 3) Pour chaque serial USB : ip route + tcpip (sur usb_port), puis connect (5038)
    # ------------------------------------------------------------------
    for serial in serials_usb:
        logs.append(f"\n--- USB: {serial} (via port {usb_port}) ---")

        prof_names = adb_index.get(serial) or []
        if not prof_names:
            logs.append(f"üü° Serial USB non mapp√© dans profiles.json: {serial}")
            logs.append("‚û°Ô∏è Mets ce serial dans le bon profil (onglet Profiles).")
            continue

        for pname in prof_names:
            cfg = profiles.get(pname, {}) or {}
            if not cfg.get("enabled", True):
                logs.append(f"[SKIP] Profil d√©sactiv√©: {pname}")
                continue

            port = int(cfg.get("tcpip_port", 5555) or 5555)
            logs.append(f"{pname} ‚Üí tcpip_port={port}")

            # 3.1) IP route (sur le m√™me port qui voit l'USB)
            _, out_ip = adb_run(f"adb -s {serial} shell ip route", port=usb_port)
            ip = _extract_ip_from_ip_route(out_ip or "")
            logs.append("[ip route]")
            logs.append((out_ip or "").strip())

            if not ip:
                logs.append("‚ùå IP introuvable (le t√©l√©phone n‚Äôest peut-√™tre pas sur le Wi-Fi).")
                continue

            logs.append(f"‚úÖ IP: {ip}")

            # 3.2) tcpip (sur le m√™me port USB)
            _, out_tcp = adb_run(f"adb -s {serial} tcpip {port}", port=usb_port)
            logs.append(f"[tcpip {port}]")
            logs.append((out_tcp or "").strip())

            # petite pause (le daemon red√©marre en tcpip)
            time.sleep(0.6)

            # 3.3) connect Wi-Fi sur 5038 (adb_run sans port => 5038)
            _, out_conn = adb_run(f"adb connect {ip}:{port}")
            txt = (out_conn or "").strip()
            logs.append(f"[connect {ip}:{port} ‚Üí 5038]")
            logs.append(txt)

            ok = ("connected" in txt.lower()) or ("already connected" in txt.lower())
            if not ok:
                logs.append("‚ùå adb connect KO.")
                logs.append("‚û°Ô∏è Causes probables :")
                logs.append("   - T√©l√©phone red√©marr√© (ADB Wi-Fi OFF) ‚Üí refais 'Scanner & connecter'")
                logs.append("   - IP chang√© (nouveau Wi-Fi) ‚Üí refais 'Scanner & connecter'")
                logs.append("   - R√©seau d‚Äôh√¥tel isol√© (client isolation) ‚Üí ports bloqu√©s")
                continue

            # 3.4) Mise √† jour du profil + propagation
            old_id = (cfg.get("device_id") or "").strip()
            new_id = f"{ip}:{port}"

            cfg["tcpip_ip"] = ip
            cfg["tcpip_port"] = port
            cfg["device_id"] = new_id
            profiles[pname] = cfg
            profiles_changed = True

            if old_id and old_id != new_id:
                for other_name, other_cfg in profiles.items():
                    if other_name == pname:
                        continue
                    if (other_cfg.get("device_id") or "").strip() == old_id:
                        other_cfg["tcpip_ip"] = ip
                        other_cfg["tcpip_port"] = port
                        other_cfg["device_id"] = new_id
                        profiles_changed = True
                        logs.append(f"  ‚Üí propagation aussi pour '{other_name}'")

            logs.append(f"‚úÖ OK: {pname} ‚Üí {new_id}")

    # ------------------------------------------------------------------
    # 4) Sauvegarde profiles.json
    # ------------------------------------------------------------------
    if profiles_changed:
        save_json(PROFILES, {"profiles": profiles})
        logs.append("\n‚úÖ profiles.json mis √† jour.")
    else:
        logs.append("\n‚ÑπÔ∏è Rien √† sauvegarder.")

    # ------------------------------------------------------------------
    # 5) √âtat final
    # ------------------------------------------------------------------
    _, _, raw_after = scan_adb_devices(wait_seconds=1.5, poll_interval=0.3)
    logs.append("\n=== adb devices (apr√®s auto-connexion) ===")
    logs.append(raw_after)

    return "\n".join(logs)

# ==========================================================================
# üî• 3. LIST DEVICES PRO : adb devices styl√© et fusionn√©
# ==========================================================================

def list_devices_pro(with_ping: bool = True) -> str:

    """
    Vue PRO de l'√©tat ADB, avec fusion des profils :

        - üü¢ CONNECT√âS (USB)
        - üü¢ CONNECT√âS (Wi-Fi)
        - üî¥ ABSENTS (Wi-Fi)
        - ‚ö™ D√âSACTIV√âS
        - R√©sum√© final X / Y p√©riph√©riques actifs (sans doublons)
    """
    profiles = load_profiles_dict()
    wifi_map, usb_map, disabled_map, unique_count = build_devices_mapping(profiles)

    logs: List[str] = []
    logs.append("=== ADB DEVICES (Mode PRO) ===\n")
    usb_connected, wifi_connected, out_5037, out_5038 = scan_adb_devices_fast()

    logs.append("[DEBUG] ADB 5038 raw:")
    logs.append(out_5038.strip() or "(vide)")
    logs.append("\n[DEBUG] ADB 5037 raw:")
    logs.append(out_5037.strip() or "(vide)")
    logs.append("")

    # üü¢ CONNECT√âS (USB)
    logs.append("üü¢ CONNECT√âS (USB) :")
    usb_found = False

    for serial, profils in usb_map.items():
        if serial in usb_connected:
            logs.append(f"   üü¢ {fusion_label(profils)} ({serial})")
            usb_found = True

    # USB inconnus (nouveaux devices)
    for serial in usb_connected:
        if serial not in usb_map:
            logs.append(f"   üü¢ {serial} (nouveau p√©riph√©rique USB)")
            usb_found = True

    if not usb_found:
        logs.append("   Aucun device USB connect√©.")

    # üü¢ CONNECT√âS (Wi-Fi)
    logs.append("\nüü¢ CONNECT√âS (Wi-Fi) :")
    wifi_found = False

    for dev_id, profils in wifi_map.items():
        if dev_id in wifi_connected:
            logs.append(f"   üü¢ {fusion_label(profils)} ({dev_id})")
            wifi_found = True

    if not wifi_found:
        logs.append("   Aucun device Wi-Fi connect√©.")

    # üî¥ ABSENTS (Wi-Fi)
    logs.append("\nüî¥ ABSENTS (Wi-Fi) :")
    abs_found = False

    for dev_id, profils in wifi_map.items():
        if dev_id not in wifi_connected:
            ip = dev_id.split(":")[0]

            # ‚úÖ Phase 1 : affichage instantan√© (pas de ping)
            if not with_ping:
                status = "Analyse r√©seau..."
            else:
                # ‚úÖ Phase 2 : ping (plus lent)
                try:
                    p = Popen(["ping", "-n", "1", "-w", "300", ip], stdout=PIPE)
                    resp = p.stdout.read().decode(errors="ignore")
                    if "TTL=" in resp:
                        status = "‚ö° Ping OK (ADB OFF)"
                    else:
                        status = "üî¥ Hors ligne"
                except Exception:
                    status = "‚ùì Ind√©fini"

            logs.append(f"   üî¥ {fusion_label(profils)} ({dev_id}) ‚Üí {status}")
            abs_found = True

    if not abs_found:
        logs.append("   Aucun device absent.")

    # ‚ö™ D√âSACTIV√âS
    logs.append("\n‚ö™ D√âSACTIV√âS :")
    if disabled_map:
        for dev_id, profils in disabled_map.items():
            dev_label = dev_id or "device_id inconnu"
            logs.append(f"   ‚ö™ {fusion_label(profils)} ({dev_label}) ‚Üí D√©sactiv√©")
    else:
        logs.append("   Aucun device d√©sactiv√©.")

    # Comptage
    connected_devices_ids = set()

    # Devices connect√©s en Wi-Fi
    for dev_id in wifi_map.keys():
        if dev_id in wifi_connected:
            connected_devices_ids.add(dev_id)
            continue

        # Devices connect√©s via USB
        profils = wifi_map[dev_id]
        for prof in profils:
            serial = (profiles.get(prof, {}).get("adb_serial") or "").strip()
            if serial and serial in usb_connected:
                connected_devices_ids.add(dev_id)
                break

    total_connected = len(connected_devices_ids)
    logs.append(
        f"\n=== R√©sultat : {total_connected} / {unique_count} p√©riph√©riques actifs ==="
    )

    return "\n".join(logs)


# ==========================================================================
# üî• 4. Connexion PRO : connect_all_devices()
# ==========================================================================

def connect_all_devices() -> str:
    """
    Connecte tous les device_id (ip:port) configur√©s.
    - priorit√© 5038
    - si 5038 ne voit aucun ip:port, on "importe" depuis 5037 (lecture) puis connect via 5038
    """
    profiles = load_profiles_dict()
    wifi_map, _, disabled_map, unique_count = build_devices_mapping(profiles)

    logs: List[str] = []
    logs.append("=== ADB CONNECT ALL (Mode PRO) ===\n")

    adb_run("adb disconnect")  # 5038

    # ‚úÖ si 5038 ne voit aucun wifi, on tente de "r√©-importer" depuis 5037
    _, out_5038 = adb_run("adb devices")
    wifi_5038 = [s for s, st in _parse_adb_devices(out_5038) if ":" in s and st == "device" and not _is_emulator_serial(s)]

    if not wifi_5038:
        _, out_5037 = adb_run_sdk("adb devices")
        wifi_5037 = [s for s, st in _parse_adb_devices(out_5037) if ":" in s and st == "device" and not _is_emulator_serial(s)]
        for dev in wifi_5037:
            adb_run(f"adb connect {dev}")  # connect sur 5038
        if wifi_5037:
            logs.append(f"[Import] {len(wifi_5037)} device(s) import√©(s) de 5037 ‚Üí 5038")

    connected_ids: List[str] = []
    missing_ids: List[str] = []

    for dev_id in wifi_map.keys():
        _, outc = adb_run(f"adb connect {dev_id}")  # 5038
        txt = (outc or "").strip().lower()
        if "connected" in txt or "already connected" in txt:
            connected_ids.append(dev_id)
        else:
            missing_ids.append(dev_id)

    logs.append("üü¢ CONNECT√âS (Wi-Fi) :")
    if connected_ids:
        for dev_id in connected_ids:
            profils = wifi_map.get(dev_id, [])
            logs.append(f"   üü¢ {fusion_label(profils)} ({dev_id})")
    else:
        logs.append("   Aucun device connect√©.")

    logs.append("\nüî¥ ABSENTS (Wi-Fi) :")
    if missing_ids:
        for dev_id in missing_ids:
            profils = wifi_map.get(dev_id, [])
            ip = dev_id.split(":")[0]
            try:
                p = Popen(["ping", "-n", "1", "-w", "300", ip], stdout=PIPE)
                resp = p.stdout.read().decode(errors="ignore")
                status = "‚ö° Ping OK (ADB OFF)" if "TTL=" in resp else "üî¥ Hors ligne"
            except Exception:
                status = "‚ùì Ind√©fini"
            logs.append(f"   üî¥ {fusion_label(profils)} ({dev_id}) ‚Üí {status}")
    else:
        logs.append("   Aucun device absent.")

    logs.append("\n‚ö™ D√âSACTIV√âS :")
    if disabled_map:
        for dev_id, profils in disabled_map.items():
            dev_label = dev_id or "device_id inconnu"
            logs.append(f"   ‚ö™ {fusion_label(profils)} ({dev_label}) ‚Üí D√©sactiv√©")
    else:
        logs.append("   Aucun device d√©sactiv√©.")

    logs.append(f"\n=== R√©sultat : {len(connected_ids)} / {unique_count} p√©riph√©riques Wi-Fi actifs ===")
    return "\n".join(logs)


============================================================================================================================================
FILE: ui_events_router.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_events_router.py
============================================================================================================================================
# ui/ui_events_router.py
# -*- coding: utf-8 -*-
"""
Routeur d‚Äô√©v√©nements COMPLET pour StoryFX.

Analyse THEORIQUEMENT l‚Äôensemble des √©v√©nements pr√©sents dans app.py
et renvoie :
    - "time"
    - "scheduler"
    - "runner"
    - "adb"
    - "admin"
    - "launcher"
    - "matrix"
    - "albums"
    - "systems"
    - "profiles"
    - "locators"
    - "unknown"

Ce routeur est con√ßu pour couvrir 100 % des √©v√©nements de app.py.
Il permet √† app.py d‚Äô√™tre propre, minimal, et d√©l√©guer chaque action
au bon module sans jamais rien oublier.
"""


def route_event(ev, vals):

    # ==========================================================
    # üî• RUNNER
    # ==========================================================
    if ev in ("-RUN-", "-RUN_STOP-", "-RUNNER-LOG-", "-RUNNER-DONE-"):
        return "runner"

    # ==========================================================
    # üî• SCHEDULER
    # ==========================================================
    if ev.startswith("-SCHED-"):
        return "scheduler"

    # ==========================================================
    # üî• TEMPS (heure automatique / manuelle)
    # ==========================================================
    if ev.startswith("-TIME_"):
        return "time"

    # ==========================================================
    # üî• DEVICES / ADB
    # ==========================================================
    if ev.startswith("-DEV_"):
        return "adb"

    # Navigation rapide
    if ev == "-GOTO_ADMIN-":
        return "launcher"

    # ==========================================================
    # üî• ADMIN (Profiles / Systems / Matrix / Albums / Locators)
    # ==========================================================

    # Profiles
    if ev == "-PROF_TABLE-" or ev.startswith("-P_"):
        return "profiles"

    # Systems
    if ev == "-SYS_TABLE-" or ev.startswith("-S_"):
        return "systems"

    # Matrix
    if ev == "-MAT_TABLE-" or ev.startswith("-M_"):
        return "matrix"

    # Albums
    if ev == "-ALB_TABLE-" or ev.startswith("-ALB_"):
        return "albums"

    # Pages   üëà NOUVEAU
    if ev == "-PG_TABLE-" or ev.startswith("-PG_"):
        return "pages"

    # Locators
    if ev.startswith("-LOC_"):
        return "locators"

    # ==========================================================
    # üî• Launcher (engine, album, plateforme‚Ä¶)
    # ==========================================================
    if ev in (
        "-ENGINE-", "-ALBUM-", "-ALBUM2-",
        "-PAGE-", "-PAGE_NAME-", "-PLATFORM-",
        "-IGVAR-", "-COUNT-",
        "-CLEAR_LOG-",
    ):
        return "launcher"

    # ==========================================================
    # üî• INCONNU
    # ==========================================================
    return "unknown"

============================================================================================================================================
FILE: ui_paths_helpers.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_paths_helpers.py
============================================================================================================================================
# ui/ui_paths_helpers.py
# -*- coding: utf-8 -*-
"""
Module centralis√© de StoryFX pour :
    - Chemins principaux
    - Chargement / sauvegarde JSON
    - Chargement des albums / profils / systems / matrix
    - Construction du catalogue albums / pays / pages
    - Gestion ADB (path + environnement)
    - append_log (multiline LOG)
    - Helpers divers utilis√©s par l‚ÄôUI et le Runner

Ce fichier r√©cup√®re 100% de ce que app.py utilisait auparavant.
"""

import sys
import json
import subprocess
from pathlib import Path
import os
import re


# ==========================================================================
# üî• 1. CHEMINS PRINCIPAUX
# ==========================================================================
HERE    = Path(__file__).resolve().parent        # .../StoryFx/ui
ROOT    = HERE.parent                            # .../StoryFx
CONFIG  = ROOT / "config"

RUNNER   = ROOT / "runner.py"
PROFILES = CONFIG / "profiles.json"
SYSTEMS  = CONFIG / "systems.json"
MATRIX   = CONFIG / "matrix.json"
ALBUMS   = CONFIG / "albums.json"

# Fichier de sauvegarde UI
UI_STATE = ROOT / "ui_state.json"

# Locators (XPaths)
LOCATORS = ROOT / "locators.json"


# ==========================================================================
# üî• 2. ADB CONFIGURATION
# ==========================================================================

# Chemin ADB StoryFX (version stable utilis√©e par toute l‚ÄôUI)
ADB_PATH = r"C:\Tools\ADB_StoryFX\adb.exe"

# ADB doit tourner sur port 5038 (pas de conflit avec runner)
ADB_ENV = os.environ.copy()
ADB_ENV["ANDROID_ADB_SERVER_PORT"] = "5038"


ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")

def strip_ansi(s: str) -> str:
    """Supprime les codes couleurs ANSI (Appium, HTTP, etc.) d'une ligne."""
    return ANSI_RE.sub("", s)

def adb_run(cmd: str, port: int | None = None):
    """
    Ex√©cute une commande ADB :
        - Remplace "adb" par ADB_PATH
        - Force env sur le port (par d√©faut 5038)
        - Retourne (code, sortie)
    """
    try:
        cmd = cmd.strip()

        if cmd.startswith("adb "):
            cmd = f"\"{ADB_PATH}\" {cmd[4:]}"
        elif cmd == "adb":
            cmd = f"\"{ADB_PATH}\""

        # ‚úÖ port ADB : par d√©faut 5038 (StoryFX), sinon override
        env = os.environ.copy()
        if port is None:
            env.update(ADB_ENV)  # garde ton 5038 par d√©faut
        else:
            env["ANDROID_ADB_SERVER_PORT"] = str(port)

        proc = subprocess.run(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            env=env,
        )
        return proc.returncode, proc.stdout

    except Exception as e:
        return 1, str(e)

# ==========================================================================
# üî• 3. JSON LOAD & SAVE HELPER
# ==========================================================================
def load_json(path: Path, default=None):
    """Lecture JSON s√ªre."""
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default if default is not None else {}


def save_json(path: Path, data):
    """√âcriture JSON avec indentation lisible."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


# ==========================================================================
# üî• 4. ALBUMS (intro / multi)
# ==========================================================================
def load_albums_dict():
    """
    Retourne :
        {album_name: {kind, album_size, count_per_post}}
    """
    albums = {}
    try:
        data = load_json(ALBUMS, {"albums": []})
    except Exception:
        data = {"albums": []}

    for row in data.get("albums", []):
        name = row.get("name")
        if not name:
            continue

        albums[name] = {
            "kind": row.get("kind", "multi"),
            "album_size": int(row.get("album_size", 0) or 0),
            "count_per_post": int(row.get("count_per_post", 0) or 0),
        }

    return albums


def save_albums_dict(albums: dict):
    rows = []
    for name, cfg in albums.items():
        rows.append({
            "name": name,
            "kind": cfg.get("kind", "multi"),
            "album_size": int(cfg.get("album_size", 0) or 0),
            "count_per_post": int(cfg.get("count_per_post", 0) or 0),
        })
    save_json(ALBUMS, {"albums": rows})


# Chargement initial pour construire les listes intro/multi
_albums_cfg = load_albums_dict()

INTRO_ALBUM_CHOICES = sorted(
    name for name, cfg in _albums_cfg.items()
    if cfg.get("kind", "multi") == "intro"
)

MULTI_ALBUM_CHOICES = sorted(
    name for name, cfg in _albums_cfg.items()
    if cfg.get("kind", "multi") == "multi"
)


# ==========================================================================
# üî• 5. UI STATE (profil, engine, albums‚Ä¶)
# ==========================================================================
def load_ui_state():
    """Charge ui_state.json si pr√©sent."""
    return load_json(UI_STATE, {})


def save_ui_state(state: dict):
    """Sauvegarde ui_state.json."""
    save_json(UI_STATE, state)


# ==========================================================================
# üî• 6. LOCATORS (XPaths)
# ==========================================================================
def load_locators_dict():
    return load_json(LOCATORS, {})


def save_locators_dict(data: dict):
    save_json(LOCATORS, data)


# ==========================================================================
# üî• 7. PROFILS / SYSTEMS / MATRIX
# ==========================================================================
def load_profiles_dict():
    return load_json(PROFILES, {"profiles": {}}).get("profiles", {})


def load_systems_dict():
    return load_json(SYSTEMS, {"systems": {}}).get("systems", {})


def load_matrix_rows():
    return load_json(MATRIX, {"rows": []}).get("rows", [])


# ==========================================================================
# üî• 8. BUILD DEVICES MAP
# ==========================================================================
def build_devices_map_from_profiles(profiles_dict: dict) -> dict:
    """
    Construit un mapping :
        adb_serial ‚Üí {ip, port, label}

    Utilis√© dans l‚Äôonglet Devices et lors de connexions cibl√©es.
    """
    devices_map = {}

    for prof_name, cfg in profiles_dict.items():
        adb_serial = cfg.get("adb_serial")
        ip        = cfg.get("tcpip_ip")
        port      = cfg.get("tcpip_port")
        label     = cfg.get("label", prof_name)

        if not adb_serial or not ip or not port:
            continue

        devices_map[adb_serial] = {
            "ip": str(ip),
            "port": str(port),
            "label": label,
        }

    return devices_map


# ==========================================================================
# üî• 9. CATALOG : albums, pays, pages Facebook
# ==========================================================================
def build_catalog_from_matrix(matrix_rows):
    """
    Retourne :
        albums[], pages[], page_names[]
    Utilis√© pour :
        - Combos Launcher
        - Combo Albums
        - Combo Matrix
    """

    albums_set = set()

    for row in matrix_rows:
        a1 = row.get("album")
        a2 = row.get("album2")

        if a1:
            albums_set.add(a1)
        if a2:
            albums_set.add(a2)

    albums = sorted(albums_set)

    page_codes  = sorted({row.get("page", "") for row in matrix_rows if row.get("page")})
    page_names  = sorted({row.get("page_name", "") for row in matrix_rows if row.get("page_name")})

    if not albums:
        albums = [""]

    return albums, page_codes, page_names

# ==========================================================================
# üî• 10. APPEND LOG (Multiline)
# ==========================================================================
def append_log(win, msg: str):
    """
    Ajoute proprement une ligne de log dans -LOG-.
    win : sg.Window
    msg : texte √† ajouter
    """
    try:
        win["-LOG-"].update(value=msg.rstrip() + "\n", append=True)
    except:
        pass


# ==========================================================================
# üî• 11. PYTHON PATH
# ==========================================================================
def get_python_exe():
    """Retourne l'ex√©cutable Python utilis√© actuellement."""
    return sys.executable or "python"


============================================================================================================================================
FILE: ui_runner.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_runner.py
============================================================================================================================================
# ui/ui_runner.py
# -*- coding: utf-8 -*-
"""
MODULE : Gestion compl√®te du RUNNER (UI)

Ce module extrait TOUT ce qui concerne le lancement du runner
depuis app.py, y compris :

- V√©rification Appium (auto-d√©marrage si off)
- Pr√©paration du bon t√©l√©phone (adb connect device_id)
- Construction compl√®te de la commande runner.py
- Gestion intro / multi / intro+multi
- Albums intro / albums multi
- Pays (page) + Page Facebook (page_name)
- Count automatique
- STORYFX_TIME (heure logique)
- Lancement du runner + thread de logs
- Gestion logs UI
- Arr√™t du runner + kill apps
- Sauvegarde ui_state.json

Ce MODULE est 100 % propre et ne contient PLUS de duplication.
"""

import socket, subprocess
import threading
import os
import PySimpleGUI as sg
import time  # en haut du fichier

from ui.ui_paths_helpers import (
    ROOT,
    RUNNER,
    PROFILES,
    get_python_exe,
    append_log,
    adb_run,
    save_ui_state,
    strip_ansi,  # üëà ajout
)

# üî• Fonction officielle (appel√©e dans TOUT StoryFX)
from ui.ui_devices import ensure_appium_running

from scheduler import get_logical_minute


# ==========================================================================
# üî• 1) Connecter le BON t√©l√©phone avant le run
# ==========================================================================
def connect_profile_device(win, profile_cfg):
    """
    Reproduit exactement la logique de app.py :
        adb disconnect
        adb connect <device_id>
    """

    device_id = (profile_cfg.get("device_id") or "").strip()

    if not device_id:
        append_log(win, "[Devices] ATTENTION : aucun device_id d√©fini pour ce profil.")
        return

    append_log(win, f"[Devices] Pr√©paration du device {device_id}‚Ä¶")

    # 1) vider les connexions ADB
    adb_run("adb disconnect")

    # 2) reconnecter
    code, out = adb_run(f"adb connect {device_id}")
    msg = out.strip() or f"adb connect {device_id} (code={code})"
    append_log(win, msg)


# ==========================================================================
# üî• 2) Construire la commande complete du runner
# ==========================================================================
def build_runner_cmd(vals, profile_name, profile_cfg, albums_dict):
    """
    Reproduit exactement la logique de construction de commande du runner :
        - engine intro / multi / intro+multi
        - selection des albums
        - count
        - platform / page / page_name / ig_variant
    """

    engine_ui = vals.get("-ENGINE-") or "intro"

    if engine_ui == "intro":
        engine = "intro"
    elif engine_ui == "multi":
        engine = "multi"
    else:
        engine = "intro_multi"

    album_intro = (vals.get("-ALBUM-") or "").strip()
    album_multi = (vals.get("-ALBUM2-") or "").strip()

    # Validation
    if engine == "intro" and not album_intro:
        sg.popup_error("Choisis un album (intro).")
        return None

    if engine == "multi" and not album_multi:
        sg.popup_error("Choisis un album (multi).")
        return None

    if engine == "intro_multi" and (not album_intro or not album_multi):
        sg.popup_error("Choisis un album intro ET un album multi.")
        return None

    # Count
    count_val = vals.get("-COUNT-", 11)
    try:
        count = str(int(count_val))
    except:
        count = "11"

    # Plateforme
    platform = vals.get("-PLATFORM_", vals.get("-PLATFORM-", "WhatsApp"))

    # Pays / Page
    page      = (vals.get("-PAGE-") or "").strip()       # Pays
    page_name = (vals.get("-PAGE_NAME-") or "").strip()  # Page Facebook

    # Commande finale
    cmd = [
        get_python_exe(), str(RUNNER),
        "--profiles", str(PROFILES),
        "--profile", profile_name,
        "--engine", engine,
        "--platform", platform,
    ]

    # Albums
    if engine == "intro":
        cmd += ["--album", album_intro]

    elif engine == "multi":
        cmd += ["--album", album_multi, "--count", count]

    elif engine == "intro_multi":
        cmd += ["--album", album_intro, "--album2", album_multi, "--count", count]

    # Pages
    if page:
        cmd += ["--page", page]
    if page_name:
        cmd += ["--page-name", page_name]


    return cmd


# ==========================================================================
# üî• 3) Injecter l‚Äôheure logique
# ==========================================================================
def apply_logical_time(win):
    """
    Ins√®re STORYFX_TIME dans les variables d‚Äôenvironnement
    pour que runner.py simule l'heure logique du scheduler.
    """

    try:
        logical = get_logical_minute()
        os.environ["STORYFX_TIME"] = logical + ":00"
        append_log(win, f"[StoryFX] Heure logique appliqu√©e : {logical}:00")
    except Exception as e:
        append_log(win, f"[StoryFX] Impossible d‚Äôappliquer l‚Äôheure logique : {e}")


# ==========================================================================
# üî• 4) Lancer runner.py + lire les logs sans BLOQUER l‚ÄôUI
# ==========================================================================
def start_runner_process(win, cmd, runner_ref):
    """
    D√©marre runner.py en t√¢che de fond,
    et lit les logs ligne par ligne dans un thread.
    """

    append_log(win, " ".join(cmd))

    try:
        p = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding="utf-8",
            errors="replace",
            cwd=str(ROOT)
        )

        runner_ref["proc"] = p

        def reader_thread(proc):
            try:
                for line in proc.stdout:
                    win.write_event_value("-RUNNER-LOG-", line)
                proc.wait()
                win.write_event_value("-RUNNER-DONE-", proc.returncode)
            except Exception as e:
                win.write_event_value("-RUNNER-LOG-", f"[UI][ERREUR thread] {e}\n")
                win.write_event_value("-RUNNER-DONE-", -1)

        threading.Thread(target=reader_thread, args=(p,), daemon=True).start()

    except Exception as e:
        append_log(win, f"[UI][ERREUR d√©marrage runner] {e}")


# ==========================================================================
# üî• 5) Stopper runner + kill apps mobiles
# ==========================================================================
def stop_runner(win, runner_ref):
    """
    Arr√™te proprement le runner + reset de l'√©cran c√¥t√© t√©l√©phone.
    """

    p = runner_ref["proc"]

    if p and p.poll() is None:
        append_log(win, "[UI] arr√™t du runner en cours...")
        try:
            p.terminate()
            p.wait(timeout=3)
        except Exception:
            try:
                p.kill()
            except Exception:
                pass

        append_log(win, "[UI] runner stopp√©.")
    else:
        append_log(win, "[UI] aucun runner actif √† stopper.")

    # On oublie l'ancien process dans le ref
    runner_ref["proc"] = None

    # üî• Reset complet du t√©l√©phone (force-stop + BACK + HOME)
    append_log(win, "[UI] arr√™t des applications mobiles‚Ä¶")
    reset_phone_to_home(win)


# ==========================================================================
# üî• 6) Sauvegarde de l'√©tat UI
# ==========================================================================
def save_ui_after_run(vals, ui_state_path):
    """
    Sauvegarde l‚Äô√©tat courant UI pour restauration au prochain d√©marrage.
    """

    engine_ui = vals.get("-ENGINE-") or "intro"

    ui_state = {
        "profile":      vals.get("-PROFILE-"),
        "engine":       engine_ui,
        "album_intro":  vals.get("-ALBUM-", ""),
        "album_multi":  vals.get("-ALBUM2-", ""),
        "platform":     vals.get("-PLATFORM-", "WhatsApp"),
        "page":         vals.get("-PAGE-", ""),
        "page_name":    vals.get("-PAGE_NAME-", ""),
    }

    save_ui_state(ui_state)


# ==========================================================================
# üî• 7) Gestion des √©v√©nements Runner depuis l‚ÄôUI
# ==========================================================================
def handle_runner_events(ev, vals, win, runner_ref, profiles, albums_dict, ui_state_path):
    """
    G√®re :
        - d√©marrage du RUNNER
        - arr√™t
        - logs
        - fin du runner
    """

    # STOP RUNNER
    if ev == "-RUN_STOP-":
        stop_runner(win, runner_ref)
        return True

    # Logs
    if ev == "-RUNNER-LOG-":
        line = vals.get("-RUNNER-LOG-", "")
        if not line:
            return True

        clean = strip_ansi(line).rstrip()
        txt = clean.strip()
        if not txt:
            return True

        # ‚úÖ On garde :
        # - logs StoryFX
        # - logs [runner]
        # - stacktraces Python (Traceback + File + exceptions)
        keep = (
            "[StoryFX]" in txt
            or txt.startswith("[runner]")
            or txt.startswith("Traceback")
            or txt.startswith("File ")  # ‚úÖ au lieu de "  File "
            or "WebDriverException" in txt
            or "ConnectionRefusedError" in txt
            or "ECONNREFUSED" in txt
            or "uiautomator2" in txt.lower()
            or "instrumentation" in txt.lower()
        )

        if keep:
            append_log(win, txt)

        return True

    if ev == "-RUNNER-DONE-":
        code = vals.get("-RUNNER-DONE-")
        append_log(win, f"[UI] termin√©, code={code}")
        runner_ref["proc"] = None
        return True

    # START RUN
    if ev == "-RUN-":

        # üî• 0) Nettoyer l'√©cran du t√©l√©phone AVANT TOUT
        reset_phone_to_home(win)

        # üî• Indispensable : d√©marrer Appium s'il n'est pas actif
        ok = ensure_appium_running(win)
        if not ok:
            append_log(win, "[UI] Appium indisponible. V√©rifie l'installation ou le PATH.")
            return True

        profile_name = vals.get("-PROFILE-")
        if not profile_name:
            sg.popup_error("Choisis un profil.")
            return True

        profile_cfg = profiles.get(profile_name, {})

        if not profile_cfg.get("enabled", True):
            sg.popup_error("Ce device est d√©sactiv√© dans les profils.")
            return True

        # Connecter le bon t√©l√©phone
        connect_profile_device(win, profile_cfg)

        # Construire la commande runner.py
        cmd = build_runner_cmd(vals, profile_name, profile_cfg, albums_dict)
        if not cmd:
            return True

        # Injecter l‚Äôheure logique
        apply_logical_time(win)

        # Afficher commande
        append_log(win, " ".join(cmd))

        # Sauvegarde UI
        save_ui_after_run(vals, ui_state_path)

        # Lancer runner + logs en temps r√©el
        start_runner_process(win, cmd, runner_ref)

        return True

    return False  # cet event ne concerne pas le runner

UNWANTED_PACKAGES = [
    # Galerie + r√©seaux
    "com.sec.android.gallery3d",
    "com.facebook.katana",
    "com.facebook.orca",
    "com.facebook.lite",
    "com.instagram.android",
    "com.zhiliaoapp.musically",
    # Applis de rappels / horloge / calendrier
    "com.sec.android.app.clockpackage",   # Horloge Samsung
    "com.google.android.deskclock",       # Horloge Google
    "com.google.android.calendar",
    "com.samsung.android.calendar",
]

def reset_phone_to_home(win):
    """
    1) Force-stop des applis connues (Galerie, FB, IG, TikTok, Clock, Calendar‚Ä¶)
    2) Fermeture des popups USSD/MMI avec plusieurs BACK
    3) Retour √† la page d'accueil (HOME)
    """
    append_log(win, "[UI] Reset de l'√©cran Android avant le run‚Ä¶")

    # 1) Fermer les apps connues
    for pkg in UNWANTED_PACKAGES:
        try:
            adb_run(f"adb shell am force-stop {pkg}")
        except Exception as e:
            append_log(win, f"[UI] Impossible de fermer {pkg} : {e}")

    # 2) Fermer les popups USSD/MMI (Connection problem / invalid MMI)
    # BACK plusieurs fois pour fermer les bo√Ætes de dialogue
    for _ in range(4):
        adb_run("adb shell input keyevent 4")  # KEYCODE_BACK
        time.sleep(0.2)

    # 3) Retour √† la Home
    adb_run("adb shell input keyevent 3")      # KEYCODE_HOME
    time.sleep(0.5)

============================================================================================================================================
FILE: ui_scheduler.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_scheduler.py
============================================================================================================================================
# ui/ui_scheduler.py
# -*- coding: utf-8 -*-
"""
Module : Gestion compl√®te du PROGRAMMATEUR (Scheduler UI)

Ce module extrait **toute la logique li√©e √† la programmation** qui se trouvait dans app.py :
- D√©marrage du scheduler (boucle infinie)
- Arr√™t du scheduler
- Thread de lecture des logs
- Mise √† jour UI (-SCHED-LOG-, -SCHED-DONE-)
- Rafra√Æchissement complet du planning (-SCHED-REFRESH-)
- Injection de STORYFX_TIME (heure logique) avant lancement du Runner
- Synchronisation Albums ‚Üí Matrix (counts multi)
- Gestion des erreurs

Cette version est 100 % fid√®le √† ton code source original,
mais d√©coup√©e PROPREMENT, pr√™te √† √™tre utilis√©e dans app.py.
"""
import psutil   # √Ä mettre en haut du fichier
import subprocess
import threading
import os

from ui.ui_paths_helpers import (
    ROOT,
    MATRIX,
    save_json,
    append_log,
    get_python_exe,
    strip_ansi,  # üëà ajout
)
from scheduler import build_planning, get_logical_minute


# ==========================================================================
# üî• 1) START SCHEDULER
# ==========================================================================
def start_scheduler(win, scheduler_ref):
    """
    D√©marre scheduler.py en boucle infinie (exactement comme dans app.py).

    scheduler_ref = {"proc": process | None}
    """
    # D√©j√† en cours ?
    if scheduler_ref["proc"] and scheduler_ref["proc"].poll() is None:
        append_log(win, "[Scheduler] d√©j√† en cours.")
        return

    cmd = [get_python_exe(), str(ROOT / "scheduler.py")]

    try:
        p = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding="utf-8",
            errors="replace",
            cwd=str(ROOT)
        )

        scheduler_ref["proc"] = p
        append_log(win, "[Scheduler] d√©marr√©.")

        # Thread lecteur des logs
        def reader_thread(proc):
            try:
                for line in proc.stdout:
                    win.write_event_value("-SCHED-LOG-", line)
                proc.wait()
                win.write_event_value("-SCHED-DONE-", proc.returncode)
            except Exception as e:
                win.write_event_value("-SCHED-LOG-", f"[Scheduler][ERREUR thread] {e}\n")
                win.write_event_value("-SCHED-DONE-", -1)

        threading.Thread(target=reader_thread, args=(p,), daemon=True).start()

    except Exception as e:
        append_log(win, f"[Scheduler] erreur au d√©marrage : {e}")


# ==========================================================================
# üî• 2) STOP SCHEDULER
# ==========================================================================
def stop_scheduler(win, scheduler_ref):
    p = scheduler_ref["proc"]

    if not p:
        append_log(win, "[Scheduler] Aucun scheduler actif.")
        return

    try:
        # R√©cup√©rer l‚Äôarbre des processus
        parent = psutil.Process(p.pid)
        children = parent.children(recursive=True)

        # Tuer tous les sous-processus (Appium, adb, runner‚Ä¶)
        for child in children:
            try:
                child.kill()
            except:
                pass

        # Tuer le scheduler lui-m√™me
        parent.kill()

        append_log(win, "[Scheduler] Arr√™t complet (processus + sous-processus).")

    except Exception as e:
        append_log(win, f"[Scheduler] Erreur lors de l'arr√™t : {e}")

    scheduler_ref["proc"] = None


# ==========================================================================
# üî• 3) REFRESH PLANNING (Onglet Programmation)
# ==========================================================================
def refresh_planning(win):
    """
    Recharge le tableau de programmation (-SCHED-TABLE-)
    en utilisant scheduler.build_planning().
    """

    data = build_planning()     # ‚Üí Profil / System / Engine / Albums‚Ä¶
    win["-SCHED-TABLE-"].update(values=data)

    # Recalcul du total des Counts (colonne index 6 dans ton planning)
    total = 0
    for row in data:
        try:
            total += int(row[6])
        except:
            pass

    win["-SCHED-TOTAL-"].update(str(total))


# ==========================================================================
# üî• 4) SYNCHRO Albums ‚Üí Matrix (counts multi)
# ==========================================================================
def sync_album_to_matrix(album_name, albums_dict, matrix_rows):
    """
    Applique count_per_post de l'album aux lignes matrix qui l'utilisent.
    Logique 100% identique √† app.py.
    """
    cfg = albums_dict.get(album_name)
    if not cfg:
        return

    # Seulement pour albums multi
    if cfg.get("kind") != "multi":
        return

    new_count = cfg.get("count_per_post")
    if not new_count:
        return

    changed = False
    for r in matrix_rows:
        # album multi standard
        if r.get("album2") == album_name:
            r["count"] = int(new_count)
            changed = True

        # anciens sc√©narios
        elif r.get("engine") == "multi" and r.get("album") == album_name:
            r["count"] = int(new_count)
            changed = True

    return changed


def sync_all_albums_to_matrix(win, albums_dict, matrix_rows):
    """
    Synchronise TOUS les albums multi vers la Matrix.
    Identique √† app.py.
    """
    changed_any = False

    for name, cfg in albums_dict.items():
        if cfg.get("kind") == "multi":
            changed = sync_album_to_matrix(name, albums_dict, matrix_rows)
            if changed:
                changed_any = True

    # Sauvegarder si modifi√©
    if changed_any:
        save_json(MATRIX, {"rows": matrix_rows})
        append_log(win, "[Scheduler] Matrix synchronis√©e depuis Albums.")


# ==========================================================================
# üî• 5) INJECTER HEURE LOGIQUE DANS STORYFX_TIME
# ==========================================================================
def apply_logical_time_env(win):
    """
    R√©cup√®re le logical_time (get_logical_minute())
    et applique STORYFX_TIME="MM:00"
    EXACTEMENT comme dans app.py avant le lancement du runner.
    """
    try:
        logical = get_logical_minute()
        os.environ["STORYFX_TIME"] = logical + ":00"
        append_log(win, f"[StoryFX] Heure logique appliqu√©e : {logical}:00")
    except Exception as e:
        append_log(win, f"[StoryFX] Impossible d'appliquer l'heure logique : {e}")


# ==========================================================================
# üî• 6) HANDLE UI EVENTS (LE PLUS IMPORTANT)
# ==========================================================================
def handle_scheduler_events(ev, vals, win, scheduler_ref, albums_dict, matrix_rows):
    """
    Point d‚Äôentr√©e unique appel√© depuis app.py :

    handle_scheduler_events(
        ev,
        vals,
        win,
        {"proc": scheduler_proc},
        albums_dict,
        matrix_rows
    )

    Ici on r√©cup√®re **TOUT** ce qui concerne la programmation :
    - Start / Stop scheduler
    - Logs
    - Refresh planning
    - Sync albums ‚Üí matrix
    """

    # Rafra√Æchir
    if ev == "-SCHED-REFRESH-":
        refresh_planning(win)
        return True

    # Start (depuis 2 boutons)
    if ev in ("-SCHED-START-", "-SCHED-START-L-"):
        start_scheduler(win, scheduler_ref)
        return True

    # Stop (depuis 2 boutons)
    if ev in ("-SCHED-STOP-", "-SCHED-STOP-L-"):
        stop_scheduler(win, scheduler_ref)
        return True

    # Log scheduler
    if ev == "-SCHED-LOG-":
        line = vals.get("-SCHED-LOG-", "")
        if not line:
            return True

        clean = strip_ansi(line).rstrip()
        txt = clean.strip()
        if not txt:
            return True

        # üîá 1) BRUIT √Ä IGNORER COMPLETEMENT
        noisy_prefixes = (
            "[HTTP]",  # Appium HTTP proxy
            "[ADB]",  # bruit ADB
            "[AppiumDriver@",  # driver interne
            "[AndroidUiautomator2Driver@",  # driver interne
            "[Logcat]",  # logcat bruit
            "[SettingsApp]",  # settings internes
        )
        if txt.startswith(noisy_prefixes):
            return True

        # üîä 2) LIGNES UTILES √Ä GARDER
        # On garde :
        #   - tout ce qui contient [StoryFX]
        #   - tout ce qui commence par [Scheduler]
        #   - les messages Appium de haut niveau ([Appium] ... )
        if ("[StoryFX]" in txt) or txt.startswith("[Scheduler]") or txt.startswith("[Appium]"):
            append_log(win, "[Scheduler] " + txt)
        # le reste (par ex. identifiants de session, etc.) on jette
        return True

    # Fin du scheduler
    if ev == "-SCHED-DONE-":
        code = vals.get("-SCHED-DONE-")
        append_log(win, f"[Scheduler] termin√©, code={code}")
        scheduler_ref["proc"] = None
        return True

    # Sync Albums ‚Üí Matrix
    if ev == "-ALB_SYNC-":
        sync_all_albums_to_matrix(win, albums_dict, matrix_rows)
        return True

    return False   # ‚Üí pas un event du scheduler


============================================================================================================================================
FILE: ui_time.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_time.py
============================================================================================================================================
# ui/ui_time.py
# -*- coding: utf-8 -*-
"""
Module de gestion du temps du scheduler (UI Temps).

Ce module extrait **toute** la logique qui √©tait auparavant dans app.py :
- Initialisation du bloc d'heure (mode auto / PC)
- Passage Auto <-> Manuel
- Lecture / √©criture dans scheduler_clock.json
- Stabilisation de l‚Äôheure (pas d‚Äô√©crasement pendant que l'utilisateur tape)
- Rafra√Æchissement automatique (toutes les secondes) uniquement en mode manuel
- Mise √† jour HH/MM selon le profil s√©lectionn√©
- Suppression compl√®te de AM/PM et du format 12h

Tout fonctionne d√©sormais en **24h strict**, bas√© sur ce que tu veux.
"""

import json
from datetime import datetime
from scheduler import load_clock_state


# --------------------------------------------------------------------------
# üî• 1) FONCTION : write_clock_state
# --------------------------------------------------------------------------
def write_clock_state(path, mode: str, hhmm: str | None = None):
    """
    Sauvegarde le mode et l'heure dans scheduler_clock.json.

    mode  : "auto" ou "manual"
    hhmm  : "HH:MM" (24h) uniquement utilis√© si mode == manual

    Ce fichier est utilis√© par le scheduler pour savoir s'il doit
    utiliser l'heure PC ou une heure impos√©e.
    """
    data = {"mode": mode}
    if mode == "manual" and hhmm:
        data["time"] = hhmm

    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[UITemps] Erreur write_clock_state: {e}")


# --------------------------------------------------------------------------
# üî• 2) FONCTION : init_time_controls (Mode AUTO)
# --------------------------------------------------------------------------
def init_time_controls(win, clock_path):
    """
    Initialise le bloc de temps en mode AUTO :
    - Heure PC r√©elle (24h)
    - HH et MM verrouill√©s
    - Radio bouton Auto s√©lectionn√©
    - write_clock_state("auto")
    """

    now = datetime.now()
    hh = f"{now.hour:02d}"
    mm = f"{now.minute:02d}"

    # Mise √† jour UI
    win["-TIME_HH-"].update(hh)
    win["-TIME_MM-"].update(mm)

    win["-TIME_AUTO-"].update(True)
    win["-TIME_MANUAL-"].update(False)

    # D√©sactivation des champs
    win["-TIME_HH-"].update(disabled=True)
    win["-TIME_MM-"].update(disabled=True)

    # Sauvegarde √©tat
    write_clock_state(clock_path, "auto", f"{hh}:{mm}")


# --------------------------------------------------------------------------
# üî• 3) R√©cup√©ration HH:MM depuis l‚ÄôUI (mode manuel)
# --------------------------------------------------------------------------
def get_manual_hhmm(vals) -> str | None:
    """
    R√©cup√®re HH et MM depuis l'UI et retourne "HH:MM".
    Validation simple : 00‚Äì23 pour HH et 00‚Äì59 pour MM.

    Retourne None si invalide.
    """
    hh = (vals.get("-TIME_HH-") or "").strip()
    mm = (vals.get("-TIME_MM-") or "").strip()

    try:
        h = int(hh)
        m = int(mm)
    except:
        return None

    if not (0 <= h <= 23 and 0 <= m <= 59):
        return None

    return f"{h:02d}:{m:02d}"


# --------------------------------------------------------------------------
# üî• 4) Mise √† jour automatique de l'affichage en MANUEL (toutes les 1 s)
# --------------------------------------------------------------------------
def auto_refresh_manual_time(win, editing_manual_time: bool):
    """
    Appel√© toutes les ~1 seconde par app.py.
    NE rafra√Æchit que SI :
    - le mode est MANUEL
    - l'utilisateur n‚Äôest PAS en train de taper
    - le scheduler_clock.json contient une heure valide

    Ce comportement est identique √† ton application actuelle,
    mais SANS √©craser l'heure quand elle vaut "00:00" ou quand l'utilisateur √©crit.
    """

    # Ne jamais toucher si l‚Äôutilisateur est en train de taper
    if editing_manual_time:
        return

    state = load_clock_state()
    hhmm = state.get("time")

    # Ne rien faire si vide ou "00:00"
    if not hhmm or hhmm == "00:00":
        return

    try:
        h, m = map(int, hhmm.split(":"))
    except:
        return

    # Mise √† jour UI (24h natif)
    win["-TIME_HH-"].update(f"{h:02d}")
    win["-TIME_MM-"].update(f"{m:02d}")


# --------------------------------------------------------------------------
# üî• 5) R√©action au changement de profil
# --------------------------------------------------------------------------
def update_time_selectors_from_profile(win, profile_name, systems, matrix_rows, profiles):
    """
    NOUVELLE LOGIQUE (demand√©e par Jerry) :
    - Les HEURES = toutes les heures de TOUS les syst√®mes.json (24h)
    - Les MINUTES = tous les offsets de TOUS les profils (tri√©s, sans doublons)
    - Le profil ne d√©termine PLUS les heures ni les minutes
    """

    # ------------------------------------------------------------------
    # 1) Extraire TOUTES les heures de systems.json
    # ------------------------------------------------------------------
    all_hours = set()

    for sys_name, times in systems.items():
        for t in times:
            try:
                hh, mm = t.split(":")
                all_hours.add(hh.zfill(2))
            except:
                pass

    hours_list = sorted(all_hours, key=lambda x: int(x))

    # ------------------------------------------------------------------
    # 2) Extraire TOUS les offset_minutes des profils
    # ------------------------------------------------------------------
    all_minutes = set()

    for prof_name, cfg in profiles.items():
        try:
            off = int(cfg.get("offset_minutes", 0))
            all_minutes.add(f"{off:02d}")
        except:
            pass

    minutes_list = sorted(all_minutes, key=lambda x: int(x))

    # ------------------------------------------------------------------
    # 3) Mise √† jour UI
    # ------------------------------------------------------------------
    win["-TIME_HH-"].update(values=hours_list)
    win["-TIME_MM-"].update(values=minutes_list)

    # S√©lectionner par d√©faut la premi√®re valeur
    if hours_list:
        win["-TIME_HH-"].update(hours_list[0])
    if minutes_list:
        win["-TIME_MM-"].update(minutes_list[0])

    print(f"[UITemps] HEURES charg√©es = {hours_list}")
    print(f"[UITemps] MINUTES charg√©es = {minutes_list}")



############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\tabs
RELATIVE: ui\tabs
############################################################################################################################################
SUBDIRS: (none)

FILES:
  üêç __init__.py (513 bytes)
  üêç ui_tabs_admin.py (18084 bytes)
  üêç ui_tabs_launcher.py (9034 bytes)
  üêç ui_tabs_locators.py (2220 bytes)
  üêç ui_tabs_sched_devices.py (2665 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: __init__.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\tabs\__init__.py
============================================================================================================================================
# ui/tabs/__init__.py
# -*- coding: utf-8 -*-

from .ui_tabs_launcher import build_launcher_tab, update_platform_fields
from .ui_tabs_admin import (
    build_profiles_tab,
    build_systems_tab,
    build_matrix_tab,
    build_albums_tab,
    build_pages_tab,  # üëà
    refresh_profiles_table,
    refresh_systems_table,
    refresh_matrix_table,
    refresh_albums_table,
)
from .ui_tabs_locators import build_locators_tab
from .ui_tabs_sched_devices import make_sched_tab, build_devices_tab


============================================================================================================================================
FILE: ui_tabs_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\tabs\ui_tabs_admin.py
============================================================================================================================================

# en haut du fichier
from collections import Counter
import PySimpleGUI as sg

from ui.ui_paths_helpers import (
    INTRO_ALBUM_CHOICES,
    MULTI_ALBUM_CHOICES,
    load_systems_dict,
    load_profiles_dict,
    build_catalog_from_matrix,
)

from pathlib import Path
import json

PAGES_FILE = Path(__file__).resolve().parents[2] / "config" / "pages.json"

def _load_pages_from_json():
    """Charge la liste des pages depuis config/pages.json."""
    pages = []
    if PAGES_FILE.exists():
        with PAGES_FILE.open("r", encoding="utf-8") as f:
            data = json.load(f)
        pages = data.get("pages", [])
    return pages

def build_pages_tab():
    """Onglet Admin pour g√©rer les pages Facebook (Pays + Page)."""
    pages = _load_pages_from_json()
    data = [
        [p.get("country", ""), p.get("name", "")]
        for p in pages
    ]

    headings = ["Pays", "Page"]

    table = sg.Table(
        values=data,
        headings=headings,
        key="-PG_TABLE-",
        enable_events=True,
        auto_size_columns=True,
        justification="left",
        expand_x=True,
        expand_y=True,
        num_rows=10,
        display_row_numbers=True,
    )

    layout = [
        [table],
        [
            sg.Text("Pays"),
            sg.Input(key="-PG_COUNTRY-", size=(20, 1)),

            sg.Text("Page"),
            sg.Input(key="-PG_NAME-", size=(30, 1)),
        ],
        [
            sg.Button("Ajouter", key="-PG_ADD-"),
            sg.Button("Mettre √† jour", key="-PG_UPDATE-"),
            sg.Button("Supprimer", key="-PG_DEL-"),
        ],
    ]
    return layout


def refresh_pages_table(win):
    """Recharge la table des pages depuis pages.json."""
    pages = _load_pages_from_json()
    data = [
        [p.get("country", ""), p.get("name", "")]
        for p in pages
    ]
    win["-PG_TABLE-"].update(values=data)


def build_profiles_tab():
    headings = [
        "enabled",     # üü© nouvelle colonne
        "name",
        "device_id",
        "adb_serial",
        "tcpip_ip",
        "tcpip_port",
        "platform_version",
        "offset_minutes",
        "rows",
    ]

    table = sg.Table(
        headings=headings,
        values=[],
        key="-PROF_TABLE-",
        auto_size_columns=True,
        display_row_numbers=True,  # ‚úÖ indice
        select_mode=sg.TABLE_SELECT_MODE_EXTENDED,  # ‚úÖ multi-select
        enable_events=True,
        expand_x=True,
        expand_y=True,
        justification="center",
    )

    sort_row = [
        sg.Text("Trier par"),
        sg.Combo(
            ["enabled", "name", "device_id", "adb_serial", "tcpip_ip", "tcpip_port",
             "platform_version", "offset_minutes", "rows"],
            key="-P_SORT_KEY-",
            default_value="name",
            readonly=True,
            size=(16, 1),
        ),
        sg.Checkbox("A‚ÜíZ", key="-P_SORT_ASC-", default=True),
        sg.Button("Trier", key="-P_SORT-"),
    ]

    # üî• LIGNE 1 ‚Äî on met le bouton Coller juste apr√®s adb_serial
    bottom_row1 = [
        sg.Text("name"),
        sg.Input(key="-P_NAME-", size=(12, 1)),
        sg.Input("", key="-P_NAME_ORIG-", visible=False),

        sg.Text("device_id"),
        sg.Input(key="-P_DEVICE-", size=(18, 1)),

        sg.Text("adb_serial"),
        sg.Input(key="-P_ADB_SERIAL-", size=(14, 1)),
        sg.Checkbox("Propager serial", key="-P_PROP_SERIAL-", default=False),
        sg.Button("Coller serial", key="-P_PASTE_SERIAL-"),   # üÜï d√©plac√© ici !
    ]

    # LIGNE 2 (inchang√©e)
    bottom_row2 = [
        sg.Text("tcpip_ip"),
        sg.Input(key="-P_TCPIP_IP-", size=(14, 1)),

        sg.Text("port"),
        sg.Input(key="-P_TCPIP_PORT-", size=(6, 1)),

        sg.Text("platform_version"),
        sg.Input(key="-P_PVER-", size=(4, 1)),

        sg.Text("offset"),
        sg.Input(key="-P_OFFSET-", size=(4, 1)),
        sg.Checkbox("Actif", key="-P_ENABLED-", default=True),

        sg.Button("Add / Update", key="-P_SAVE-"),
        sg.Button("Supprimer", key="-P_DEL-"),
    ]

    # LIGNE 3 ‚Äî On garde seulement Rafra√Æchir
    bottom_row3 = [
        sg.Button("Dupliquer", key="-P_DUP-"),  # üÜï
        sg.Button("Rafra√Æchir", key="-P_REFRESH-"),
    ]

    bottom_row4 = [
        sg.Text("appium_overrides (JSON)"),
        sg.Multiline(
            "",
            key="-P_APPIUM_OVERRIDES-",
            size=(80, 4),
            font=("Consolas", 9),
        ),
    ]

    bottom_row5 = [
        sg.Text("Gallery appPackage"),
        sg.Input(key="-P_GALLERY_PKG-", size=(35, 1)),
        sg.Text("Gallery appActivity"),
        sg.Input(key="-P_GALLERY_ACT-", size=(45, 1)),
    ]

    layout = [
        [table],
        sort_row,  # ‚úÖ nouveau
        bottom_row1,
        bottom_row2,
        bottom_row3,
        bottom_row4,
        bottom_row5,
    ]

    return layout


def build_systems_tab():
    headings = ["key", "times (HH:MM,HH:MM,...)"]
    layout = [
        [
            sg.Table(
                values=[],
                headings=headings,
                key="-SYS_TABLE-",
                enable_events=True,
                auto_size_columns=True,
                justification="left",
                expand_x=True,
                expand_y=True,
                num_rows=8,
            )
        ],
        [
            sg.Text("key"),
            sg.Input(key="-S_KEY-", size=(20, 1)),
            sg.Input("", key="-S_KEY_ORIG-", visible=False),  # üëà ancien nom cach√©

            sg.Text("times"),
            sg.Input(key="-S_TIMES-", size=(40, 1)),
        ],
        [
            sg.Button("Add", key="-S_ADD-"),
            sg.Button("Update", key="-S_UPDATE-"),
            sg.Button("Supprimer", key="-S_DEL-"),
        ],
    ]
    return layout

def build_matrix_tab():
    headings = [
        "device", "system", "engine",
        "album_intro", "album_multi",
        "album_size", "count",
        "platform", "pays", "page_name",
    ]

    # üî• Charger les pays/pages depuis config/pages.json
    pages_file = Path(__file__).resolve().parents[2] / "config" / "pages.json"
    countries, page_names = [], []

    if pages_file.exists():
        with pages_file.open("r", encoding="utf-8") as f:
            data = json.load(f)
        for entry in data.get("pages", []):
            c = (entry.get("country") or "").strip()
            n = (entry.get("name") or "").strip()
            if c:
                countries.append(c)
            if n:
                page_names.append(n)

    countries = sorted(set(countries))
    page_names = sorted(set(page_names))

    layout = [
        [
            sg.Table(
                values=[],
                headings=headings,
                key="-MAT_TABLE-",
                enable_events=True,
                auto_size_columns=True,
                justification="left",
                expand_x=True,
                expand_y=True,
                num_rows=12,
                display_row_numbers=True,
                select_mode=sg.TABLE_SELECT_MODE_EXTENDED,  # ‚úÖ multi-s√©lection
            )
        ],
        [
            sg.Text("Total count:", size=(10, 1)),
            sg.Text("0", key="-MAT_TOTAL-", size=(6, 1)),
        ],
        [
            sg.Text("Trier par"),
            sg.Combo(
                ["device", "system", "engine", "album intro", "album multi", "platform", "pays", "page_name", "count"],
                key="-M_SORT_KEY-",
                default_value="device",
                readonly=True,
                size=(14, 1),
            ),
            sg.Checkbox("A‚ÜíZ", key="-M_SORT_ASC-", default=True),
            sg.Button("Trier", key="-M_SORT-"),
        ],

        [
            sg.Text("device"),
            sg.Combo([], key="-M_DEVICE-", size=(12, 1), readonly=True, enable_events=True),

            sg.Text("system"),
            sg.Combo([], key="-M_SYSTEM-", size=(16, 1), readonly=True),

            sg.Text("engine"),
            sg.Combo(
                ["intro", "multi", "intro+multi"],
                key="-M_ENGINE-", size=(10, 1),
                readonly=True, default_value="multi",
            ),

            sg.Text("platform"),
            sg.Combo(
                ["WhatsApp", "Facebook", "Instagram", "TikTok"],
                key="-M_PLATFORM-", size=(12, 1),
                readonly=True, default_value="WhatsApp",
            ),
        ],

        [
            sg.Text("album intro"),
            sg.Combo(
                INTRO_ALBUM_CHOICES, key="-M_ALBUM-",
                size=(20, 1), readonly=True,
            ),

            sg.Text("album multi"),
            sg.Combo(
                MULTI_ALBUM_CHOICES, key="-M_ALBUM2-",
                size=(22, 1), readonly=True,
            ),

            sg.Text("album_size"),
            sg.Input(key="-M_ALBUM_SIZE-", size=(6, 1), default_text="0"),

            sg.Text("count"),
            sg.Input(key="-M_COUNT-", size=(5, 1), default_text="11"),
        ],

        [
            sg.Text("Pays"),
            sg.Combo(countries, key="-M_PAGE-", size=(25, 1), readonly=True),

            sg.Text("Page"),
            sg.Combo(page_names, key="-M_PNAME-", size=(40, 1), readonly=True),
        ],

        [
            sg.Button("Rafra√Æchir (Albums -> Matrix)", key="-M_REFRESH-"),
            sg.Button("Add row", key="-M_ADD-"),
            sg.Button("Update row", key="-M_UPDATE-"),
            sg.Button("Supprimer row", key="-M_DEL-"),
            sg.Button("Dupliquer row", key="-M_DUP-"),
        ],
    ]

    return layout


# ---------- Refresh des tables ----------
def refresh_profiles_table(win, profiles: dict, matrix_rows: list):
    """
    Recharge la table des profils avec :
    - colonnes ADB (serial, ip, port)
    - nb de lignes Matrix par profil (colonne 'device')
    """
    # Compter les lignes Matrix par profil
    counts = Counter()
    for r in matrix_rows or []:
        dev = r.get("device")
        if dev:
            counts[dev] += 1

    data = []
    names = getattr(win, "_prof_view_names", None) or sorted(profiles.keys())

    for name in names:
        cfg = profiles.get(name, {})
        device_id       = cfg.get("device_id", "")
        adb_serial      = cfg.get("adb_serial", "")
        tcpip_ip        = cfg.get("tcpip_ip", "")
        tcpip_port      = cfg.get("tcpip_port", "")
        platform_version = cfg.get("platform_version", "")
        offset          = cfg.get("offset_minutes", 0)
        row_count       = counts.get(name, 0)
        enabled = cfg.get("enabled", True)
        enabled_icon = "üü¢" if enabled else "üî¥"
        data.append([
            enabled_icon,  # üî• 1√®re colonne = √©tat activ√©/d√©sactiv√©
            name,
            device_id,
            adb_serial,
            tcpip_ip,
            tcpip_port,
            platform_version,
            offset,
            row_count,
        ])

    win["-PROF_TABLE-"].update(values=data)
    try:
        win["-M_DEVICE-"].update(values=sorted(profiles.keys()))
    except Exception:
        pass

sg.Checkbox("Propager serial", key="-P_PROP_SERIAL-", default=False),

def refresh_systems_table(win, systems):
    data = []
    keys_sorted = sorted(systems.keys())

    # Table Systems
    for key in keys_sorted:
        val = systems[key]
        if isinstance(val, list):
            times = val
        else:
            times = val.get("times", [])
        data.append([key, ",".join(times)])

    win["-SYS_TABLE-"].update(values=data)

    # üî• Propagation vers les autres onglets

    # 1) Onglet Albums : combo System
    try:
        win["-ALB_SYSTEM-"].update(values=keys_sorted)
    except Exception:
        pass  # au cas o√π l'onglet n'est pas encore construit

    # 2) Onglet Matrix : combo System
    try:
        win["-M_SYSTEM-"].update(values=keys_sorted)
    except Exception:
        pass



def refresh_matrix_table(win, matrix_rows):
    data = []
    total_count = 0
    for r in matrix_rows:
        c = r.get("count", 0) or 0
        try:
            total_count += int(c)
        except Exception:
            pass

        data.append([
            r.get("device", ""),
            r.get("system", ""),
            r.get("engine", ""),
            r.get("album", ""),
            r.get("album2", ""),
            r.get("album_size", ""),
            c,
            r.get("platform", "WhatsApp"),
            r.get("page", ""),        # ici = Pays
            r.get("page_name", ""),   # ici = Nom de la page
        ])

    win["-MAT_TABLE-"].update(values=data)
    win["-MAT_TOTAL-"].update(str(total_count))

    # # üî• Mettre √† jour la liste des pays / pages pour les combos Matrix
    # try:
    #     _, page_codes, page_names = build_catalog_from_matrix(matrix_rows)
    #     win["-M_PAGE-"].update(values=page_codes)
    #     win["-M_PNAME-"].update(values=page_names)
    # except Exception:
    #     pass


def build_albums_tab():
    headings = [
        "name",
        "engine",
        "album_size",
        "count_per_post",
        "scroll_max",
        "system",
        "engine_full",
        "intro_album",
        "profiles",
    ]


    table = sg.Table(
        values=[],
        headings=headings,
        key="-ALB_TABLE-",
        enable_events=True,
        auto_size_columns=True,
        justification="center",
        expand_x=True,
        expand_y=True,
        num_rows=8,
    )

    layout = [
        [table],

        # Ligne 1 : infos de base de l'album
        [
            sg.Text("name"),
            # readonly=False pour pouvoir taper un nouveau nom
            sg.Combo(values=[], key="-ALB_NAME-", size=(22, 1), readonly=False),
            sg.Input("", key="-ALB_NAME_ORIG-", visible=False),  # ancien nom (invisible)

            sg.Text("engine"),
            sg.Combo(
                values=["intro", "multi"],
                key="-ALB_KIND-",
                size=(8, 1),
                default_value="multi",
            ),

            sg.Text("album_size"),
            sg.Input(key="-ALB_SIZE-", size=(6, 1)),

            sg.Text("count/post"),
            sg.Input(key="-ALB_COUNT-", size=(6, 1)),
        ],

        # Ligne 2 : boutons CRUD
        [
            sg.Button("Nouveau", key="-ALB_NEW-"),
            sg.Button("Add / Update", key="-ALB_SAVE-"),
            sg.Button("Supprimer", key="-ALB_DEL-"),
            sg.Button("Sync counts -> Matrix", key="-ALB_SYNC-"),
            sg.Button("Sync -> profils", key="-ALB_PUSH_ALL-"),
        ],

        # Ligne 3 : s√©lection multi-profils + system
        [
            sg.Text("Profils"),
            sg.Listbox(
                values=[],
                key="-ALB_DEVICES-",
                select_mode=sg.SELECT_MODE_EXTENDED,  # plusieurs profils possibles
                size=(22, 4),
            ),
            sg.Button("Tous", key="-ALB_SELECT_ALL_PROF-"),  # üëà nouveau bouton

            sg.Text("System"),
            sg.Combo(
                [],
                key="-ALB_SYSTEM-",
                size=(20, 1),
                readonly=True,
            ),
        ],

        # Ligne 4 : engine complet + album intro
        [
            sg.Text("Engine complet"),
            sg.Combo(
                ["intro", "multi", "intro+multi"],
                key="-ALB_ENGINE_FULL-",
                size=(12, 1),
                default_value="multi",
            ),

            sg.Text("Album intro (si intro+multi)"),
            sg.Combo(
                [],
                key="-ALB_INTRO_TMP-",
                size=(22, 1),
                readonly=True,
            ),
        ],
    ]

    return layout

def refresh_albums_table(win, albums_dict):
    import math

    data = []
    names = sorted(albums_dict.keys())
    for name in names:
        cfg = albums_dict[name]
        size = cfg.get("album_size", 0)
        scroll_max = 3
        if size > 0:
            scroll_max = max(1, min(10, math.ceil(size / 250.0)))

        profiles_list = cfg.get("profiles", []) or []
        profiles_str = " | ".join(profiles_list)

        data.append([
            name,
            cfg.get("kind", "multi"),
            size,
            cfg.get("count_per_post", 0),
            scroll_max,
            cfg.get("default_system", ""),
            cfg.get("engine_full", ""),
            cfg.get("intro_album", ""),
            profiles_str,
        ])

    # Rafra√Æchir la table + combo name
    win["-ALB_TABLE-"].update(values=data)
    win["-ALB_NAME-"].update(values=names)

    # ---------- Nouveaux √©l√©ments : systems, profils, albums intro ----------

    # Systems
    systems_raw = load_systems_dict()
    if isinstance(systems_raw, dict) and "systems" in systems_raw:
        systems = systems_raw["systems"]
    else:
        systems = systems_raw or {}

    win["-ALB_SYSTEM-"].update(values=sorted(systems.keys()))

    # Profils actifs
    profiles_raw = load_profiles_dict()
    if isinstance(profiles_raw, dict) and "profiles" in profiles_raw:
        profiles = profiles_raw["profiles"]
    else:
        profiles = profiles_raw or {}

    # Profils (actifs + inactifs)
    profile_names = sorted(profiles.keys())
    win["-ALB_DEVICES-"].update(values=profile_names)

    # Albums intro (pour intro+multi)
    intro_albums = sorted(
        n for n, c in albums_dict.items()
        if c.get("kind", "multi") == "intro"
    )
    win["-ALB_INTRO_TMP-"].update(values=intro_albums)


============================================================================================================================================
FILE: ui_tabs_launcher.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\tabs\ui_tabs_launcher.py
============================================================================================================================================
# -*- coding: utf-8 -*-
import PySimpleGUI as sg
import json
from pathlib import Path

from ui.ui_paths_helpers import (
    MATRIX,
    save_json,
    build_catalog_from_matrix,
)


def build_launcher_tab():
    """
    Onglet Launcher 100% format 24h.
    - PLUS DE AM/PM
    - HH & MM seront mis √† jour dynamiquement par update_time_selectors_from_profile()
    """

    engines   = ["intro", "multi", "intro+multi"]
    platforms = ["WhatsApp", "Facebook", "Instagram", "TikTok"]

    # üî• Charger la liste des pays/pages depuis pages.json
    pages_file = Path(__file__).resolve().parents[2] / "config" / "pages.json"
    countries = []
    page_names = []
    if pages_file.exists():
        with open(pages_file, "r", encoding="utf-8") as f:
            data = json.load(f)
            for entry in data.get("pages", []):
                countries.append(entry.get("country", ""))
                page_names.append(entry.get("name", ""))
    countries = sorted(set(countries))
    page_names = sorted(set(page_names))

    layout = [
        # --- PROFIL ---
        [
            sg.Text("Profil"),
            sg.Combo(
                [], key="-PROFILE-", size=(28, 1),
                readonly=True, enable_events=True
            ),
        ],

        # --- ENGINE ---
        [
            sg.Text("Engine"),
            sg.Combo(
                engines, default_value="intro",
                key="-ENGINE-", size=(12, 1),
                readonly=True, enable_events=True
            ),
        ],

        # --- ALBUM INTRO ---
        [
            sg.Text("Album (intro)"),
            sg.Combo(
                [], key="-ALBUM-", size=(28, 1),
                readonly=True, enable_events=True
            ),
            sg.Button("‚öô", key="-EDIT_ALBUMS-", size=(3, 1)),
        ],

        # --- ALBUM MULTI ---
        [
            sg.Text("Album (multi)"),
            sg.Combo(
                [], key="-ALBUM2-", size=(28, 1),
                readonly=True, enable_events=True
            ),
        ],

        # --- COUNT ---
        [
            sg.Text("Count"),
            sg.Spin(
                [i for i in range(1, 60)],
                initial_value=11,
                key="-COUNT-", size=(5, 1)
            ),
        ],

        # --- PLATEFORME ---
        [
            sg.Text("Plateforme"),
            sg.Combo(
                platforms, default_value="WhatsApp",
                key="-PLATFORM-", size=(14, 1),
                readonly=True, enable_events=True
            ),
        ],

        # --- PAYS / PAGE FACEBOOK ---
        [
            sg.Text("Pays"),
            sg.Combo(countries, key="-PAGE-", size=(25, 1), readonly=True),  # üî• plus large et lit pages.json

            sg.Text("Page"),
            sg.Combo(page_names, key="-PAGE_NAME-", size=(40, 1), readonly=True),

            sg.Button("‚öô", key="-EDIT_PAGES-", size=(3, 1)),
        ],

        [sg.HorizontalSeparator()],

        # --- TEMPS DU SCHEDULER ‚Äî FORMAT 24H ---
        [
            sg.Text("Temps scheduler"),
            sg.Radio("Auto (PC)", "TIME_MODE", key="-TIME_AUTO-", default=True, enable_events=True),
            sg.Radio("Manuel", "TIME_MODE", key="-TIME_MANUAL-", enable_events=True),

            sg.Text("Heure"),

            # üî• FORMAT 24H ‚Äî VALEURS PAR D√âFAUT VIDES, REMPLIES PAR update_time_selectors_from_profile()
            sg.Combo(
                [],
                key="-TIME_HH-",
                size=(4, 40),  # üëà 20 lignes affich√©es d‚Äôun coup
                readonly=True,
                enable_events=True,
                # sbar_width=0,  # üëà enl√®ve la barre de scroll disgracieuse
            ),

            sg.Text(":"),

            sg.Combo(
                [],
                key="-TIME_MM-",
                size=(4, 40),  # üëà m√™me height pour coh√©rence
                readonly=True,
                enable_events=True,
                # sbar_width=0,
            )

        ],

        # --- BOUTONS ---
        [
            sg.Button("‚ñ∂ D√©marrer scheduler", key="-SCHED-START-L-", button_color=("white", "green")),
            sg.Button("‚ñ† Arr√™ter scheduler", key="-SCHED-STOP-L-", button_color=("white", "firebrick4")),
            sg.Button("‚ñ∂ Lancer", key="-RUN-", bind_return_key=True),
            sg.Button("Stopper", key="-RUN_STOP-"),
            sg.Button("Effacer", key="-CLEAR_LOG-"),
            sg.Button("Admin", key="-GOTO_ADMIN-"),
            sg.Push(),
            sg.Button("Quitter"),
        ],

        # --- LOGS ---
        [
            sg.Multiline(
                key="-LOG-", size=(120, 25),
                autoscroll=True, disabled=True,
                expand_x=True, expand_y=True,
                font=("Consolas", 9)
            )
        ],
    ]

    return layout


def update_platform_fields(win, platform: str):
    """Active/d√©sactive les champs suivant la plateforme choisie."""
    platform = (platform or "").strip()

    fb_active = (platform == "Facebook")
    win["-PAGE-"].update(disabled=not fb_active)
    win["-PAGE_NAME-"].update(disabled=not fb_active)
    win["-EDIT_PAGES-"].update(disabled=not fb_active)

    if not fb_active:
        win["-PAGE-"].update(value="")
        win["-PAGE_NAME-"].update(value="")


def edit_albums(win, matrix_rows):
    albums, _, _, _ = build_catalog_from_matrix(matrix_rows)

    layout = [
        [sg.Text("S√©lectionne un album et renomme-le")],
        [sg.Listbox(albums, key="-ALIST-", size=(30, 8), enable_events=True)],
        [sg.Text("Nouveau nom"), sg.Input(key="-ANEW-")],
        [sg.Button("Renommer"), sg.Button("Fermer")],
    ]
    dlg = sg.Window("Albums", layout, modal=True)

    while True:
        ev, vals = dlg.read()
        if ev in (sg.WINDOW_CLOSED, "Fermer"):
            break

        if ev == "-ALIST-":
            if vals["-ALIST-"]:
                dlg["-ANEW-"].update(vals["-ALIST-"][0])
            continue

        if ev == "Renommer":
            if not vals["-ALIST-"]:
                sg.popup_error("Choisis un album dans la liste.")
                continue
            old = vals["-ALIST-"][0]
            new = vals["-ANEW-"].strip()
            if not new:
                sg.popup_error("Saisis un nouveau nom.")
                continue

            # Mettre √† jour Matrix
            for r in matrix_rows:
                if r.get("album") == old:
                    r["album"] = new
                if r.get("album2") == old:
                    r["album2"] = new

            albums, _, _, _ = build_catalog_from_matrix(matrix_rows)
            dlg["-ALIST-"].update(albums)
            sg.popup("Album renomm√©.")

    dlg.close()
    save_json(MATRIX, {"rows": matrix_rows})

    # Recalcul complet (intro vs multi)
    updated_albums, page_codes, page_names = build_catalog_from_matrix(matrix_rows)

    # Mise √† jour du Launcher
    win["-ALBUM-"].update(values=updated_albums)
    win["-ALBUM2-"].update(values=updated_albums)

    # Mise √† jour Pays / Pages
    win["-PAGE-"].update(values=page_codes)
    win["-PAGE_NAME-"].update(values=page_names)

    return matrix_rows

def edit_pages(win, matrix_rows):
    _, _, page_names, _ = build_catalog_from_matrix(matrix_rows)

    layout = [
        [sg.Text("Renomme une page Facebook")],
        [sg.Listbox(page_names, key="-PLIST-", size=(40, 8), enable_events=True)],
        [sg.Text("Nouveau nom"), sg.Input(key="-PNEW-")],
        [sg.Button("Renommer"), sg.Button("Fermer")],
    ]
    dlg = sg.Window("Pages FB", layout, modal=True)

    while True:
        ev, vals = dlg.read()
        if ev in (sg.WINDOW_CLOSED, "Fermer"):
            break

        if ev == "-PLIST-":
            if vals["-PLIST-"]:
                dlg["-PNEW-"].update(vals["-PLIST-"][0])
            continue

        if ev == "Renommer":
            if not vals["-PLIST-"]:
                sg.popup_error("Choisis une page dans la liste.")
                continue

            old = vals["-PLIST-"][0]
            new = vals["-PNEW-"].strip()
            if not new:
                sg.popup_error("Saisis un nouveau nom.")
                continue

            for r in matrix_rows:
                if r.get("page_name") == old:
                    r["page_name"] = new

            _, _, page_names, _ = build_catalog_from_matrix(matrix_rows)
            dlg["-PLIST-"].update(page_names)
            sg.popup("Page renomm√©e.")

    dlg.close()
    save_json(MATRIX, {"rows": matrix_rows})

    # Recharger toutes les valeurs Launcher
    _, page_codes, page_names = build_catalog_from_matrix(matrix_rows)

    win["-PAGE-"].update(values=page_codes)
    win["-PAGE_NAME-"].update(values=page_names)

    return matrix_rows




============================================================================================================================================
FILE: ui_tabs_locators.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\tabs\ui_tabs_locators.py
============================================================================================================================================
# -*- coding: utf-8 -*-
import PySimpleGUI as sg

from ui.ui_paths_helpers import load_profiles_dict


def build_locators_tab():
    """
    Onglet Admin - Locators (XPaths).

    - Plateforme : WhatsApp, Facebook, Instagram, TikTok
    - Profil/device : default + tous les profils de profiles.json
    - Cl√© : type de locator (share_entry, my_status, send_button)
    - Champ Multiline pour saisir l'XPath
    - Boutons Charger / Enregistrer (g√©r√©s dans app.py)
    """
    profiles = load_profiles_dict()
    profile_names = ["default"] + sorted(profiles.keys())

    # On garde uniquement les 3 √©tapes r√©elles de ton flow :
    # 1) share_entry  : ic√¥ne / texte de l'app dans la feuille de partage (WhatsApp Business, Facebook, IG, TikTok)
    # 2) my_status    : entr√©e "My status" dans WhatsApp
    # 3) send_button  : bouton Send / Envoyer dans WhatsApp
    locator_keys = [
        "share_entry",   # entr√©e g√©n√©rique de partage (WhatsApp Business, Facebook, IG, TikTok)
        "my_status",     # entr√©e "My status" dans WhatsApp
        "send_button",   # bouton Send / Envoyer
    ]

    layout = [
        [
            sg.Text("Plateforme"),
            sg.Combo(
                ["WhatsApp", "Facebook", "Instagram", "TikTok"],
                key="-LOC_PLATFORM-",
                readonly=True,
                size=(15, 1),
            ),
        ],
        [
            sg.Text("Profil / device"),
            sg.Combo(
                profile_names,
                key="-LOC_PROFILE-",
                readonly=True,
                size=(20, 1),
            ),
        ],
        [
            sg.Text("Cl√©"),
            sg.Combo(
                locator_keys,
                key="-LOC_KEY-",
                readonly=True,
                size=(18, 1),
            ),
        ],
        [
            sg.Multiline(
                "",
                size=(80, 6),
                key="-LOC_XPATH-",
                autoscroll=True,
            )
        ],
        [
            sg.Button("Charger", key="-LOC_LOAD-"),
            sg.Button("Enregistrer", key="-LOC_SAVE-"),
        ],
    ]

    return layout


============================================================================================================================================
FILE: ui_tabs_sched_devices.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\tabs\ui_tabs_sched_devices.py
============================================================================================================================================
# -*- coding: utf-8 -*-
import PySimpleGUI as sg

from scheduler import build_planning   # ton scheduler.py reste tel quel


def make_sched_tab():
    headings = [
        "Profil", "Syst√®me", "Engine",
        "Album intro", "Album multi",
        "Plateforme", "Count",
        "Heure base", "Offset", "Heure r√©elle",
        "Pays", "Page"
    ]


    data = build_planning()  # lit les JSON et calcule toutes les lignes

    total = 0
    # data = [Profil, Syst√®me, Engine, Album intro, Album multi, Plateforme, Count,
    #         Heure base, Offset, Heure r√©elle, Page, Page name, IG variant]
    for row in data:
        try:
            total += int(row[6])  # colonne Count (index 6 maintenant)
        except Exception:
            pass

    layout = [
        [sg.Text("Programmations calcul√©es (d'apr√®s profiles / systems / matrix)")],
        [sg.Table(
            values=data,
            headings=headings,
            key="-SCHED-TABLE-",
            auto_size_columns=True,
            display_row_numbers=True,
            justification="left",
            num_rows=15,
            enable_events=False,
            expand_x=True,
            expand_y=True,
        )],
        [
            sg.Text("Total count:", size=(12, 1)),
            sg.Text(str(total), key="-SCHED-TOTAL-", size=(8, 1)),
        ],
        [
            sg.Button("‚Üª Rafra√Æchir", key="-SCHED-REFRESH-"),
            sg.Button("‚ñ∂ D√©marrer scheduler", key="-SCHED-START-", button_color=("white", "green")),
            sg.Button("‚ñ† Arr√™ter scheduler", key="-SCHED-STOP-", button_color=("white", "firebrick4")),
        ],
    ]

    return layout


def build_devices_tab():
    """
    Onglet Devices : gestion de la connexion ADB des t√©l√©phones.
    """
    layout = [
        [sg.Text("Connexion ADB des t√©l√©phones")],
        [
            sg.Button("üì° Scanner & connecter", key="-DEV_SCAN_CONNECT-"),
            sg.Button("adb devices", key="-DEV_LIST-"),
            sg.Button("Copier serial(s)", key="-DEV_COPY_SERIAL-"),
            sg.Button("Connecter tout", key="-DEV_CONNECT_ALL-"),
            sg.Button("D√©connecter tout", key="-DEV_DISCONNECT-"),
            sg.Button("Effacer", key="-DEV_CLEAR-"),
        ],
        [
            sg.Multiline(
                key="-DEV_LOG-",
                size=(120, 25),       # terminal plus grand
                autoscroll=True,
                expand_x=True,
                expand_y=True,
                font=("Consolas", 9),  # police monospace agr√©able
            )
        ],
    ]
    return layout



############################################################################################################################################
SCAN DIR: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin
RELATIVE: ui\ui_admin
############################################################################################################################################
SUBDIRS: (none)

FILES:
  üêç __init__.py (250 bytes)
  üêç albums_admin.py (16043 bytes)
  üêç locators_admin.py (2480 bytes)
  üêç matrix_admin.py (11740 bytes)
  üêç pages_admin.py (5011 bytes)
  üêç profiles_admin.py (16238 bytes)
  üêç systems_admin.py (5763 bytes)
  üêç ui_admin.py (3313 bytes)

--------------------------------------------------------------------------------------------------------------------------------------------
CONTENTS (for selected files):
--------------------------------------------------------------------------------------------------------------------------------------------

============================================================================================================================================
FILE: __init__.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\__init__.py
============================================================================================================================================
from .profiles_admin import handle_profiles_events
from .systems_admin import handle_systems_events
from .matrix_admin import handle_matrix_events
from .albums_admin import handle_albums_events
from .locators_admin import handle_locators_events


============================================================================================================================================
FILE: albums_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\albums_admin.py
============================================================================================================================================
# ui/ui_admin/albums_admin.py
# -*- coding: utf-8 -*-

import PySimpleGUI as sg

from ui.ui_paths_helpers import (
    MATRIX,
    save_json,
    load_albums_dict,
    save_albums_dict,
    INTRO_ALBUM_CHOICES,
    MULTI_ALBUM_CHOICES,
)
from ui.tabs.ui_tabs_admin import (
    refresh_albums_table,
    refresh_matrix_table,
)


def handle_albums_events(ev, vals, win, albums_dict, matrix_rows, profiles):
    """
    G√àRE 100% DE LA LOGIQUE ALBUMS provenant de ton app.py :

        -ALB_TABLE-
        -ALB_NEW-
        -ALB_SAVE-
        -ALB_DEL-
        -ALB_SYNC-

    Aucun widget n‚Äôest cr√©√© ici : seulement de la logique.
    """

    # ======================================================================
    # üî• 1) S√©lection dans la table Albums
    # ======================================================================
    if ev == "-ALB_TABLE-":
        sel = vals.get("-ALB_TABLE-", [])
        if sel:
            idx = sel[0]
            names = sorted(albums_dict.keys())

            if 0 <= idx < len(names):
                name = names[idx]
                cfg = albums_dict[name]

                win["-ALB_NAME-"].update(name)
                win["-ALB_KIND-"].update(cfg.get("kind", "multi"))
                win["-ALB_SIZE-"].update(str(cfg.get("album_size", 0)))
                win["-ALB_COUNT-"].update(str(cfg.get("count_per_post", 0)))
                win["-ALB_SYSTEM-"].update(cfg.get("default_system", ""))
                win["-ALB_ENGINE_FULL-"].update(cfg.get("engine_full", "multi"))
                win["-ALB_INTRO_TMP-"].update(cfg.get("intro_album", ""))

                # üî• Profils associ√©s √† cet album : on les coche dans la Listbox
                if isinstance(profiles, dict) and "profiles" in profiles:
                    profiles_dict = profiles["profiles"]
                else:
                    profiles_dict = profiles or {}

                all_profile_names = sorted(profiles_dict.keys())
                win["-ALB_DEVICES-"].update(values=all_profile_names)

                selected = cfg.get("profiles", []) or []
                indices = [i for i, n in enumerate(all_profile_names) if n in selected]
                if indices:
                    win["-ALB_DEVICES-"].update(set_to_index=indices)
                else:
                    win["-ALB_DEVICES-"].update(set_to_index=[])

                # üî• Tr√®s important : m√©moriser l‚Äôancien nom !
                win["-ALB_NAME_ORIG-"].update(name)

        return True

    # ======================================================================
    # üî• 1 bis) Bouton "Nouveau" : r√©initialiser le formulaire
    # ======================================================================
    if ev == "-ALB_NEW-":
        # On vide les champs pour pr√©parer la cr√©ation d‚Äôun nouvel album
        win["-ALB_NAME-"].update("")
        win["-ALB_KIND-"].update("multi")
        win["-ALB_SIZE-"].update("0")
        win["-ALB_COUNT-"].update("0")
        win["-ALB_NAME_ORIG-"].update("")


        # On ne touche NI √† albums_dict NI √† matrix_rows ici.
        # La cr√©ation r√©elle se fera quand tu cliqueras sur -ALB_SAVE-.
        return True

    # ======================================================================
    # üî• 1 ter) Bouton "Tous" : s√©lectionner tous les profils
    # ======================================================================
    if ev == "-ALB_SELECT_ALL_PROF-":

        # R√©cup√©rer la dict des profils
        if isinstance(profiles, dict) and "profiles" in profiles:
            profiles_dict = profiles["profiles"]
        else:
            profiles_dict = profiles or {}

        # On prend TOUS les profils (actifs + inactifs)
        profile_names = sorted(profiles_dict.keys())

        # Mettre la liste + tout s√©lectionner
        win["-ALB_DEVICES-"].update(
            values=profile_names,
            set_to_index=list(range(len(profile_names)))  # coche tous les indices
        )

        return True

    # ======================================================================
    # üî• 2) Enregistrer un album
    # ======================================================================
    if ev == "-ALB_SAVE-":
        name = (vals.get("-ALB_NAME-") or "").strip()
        if not name:
            sg.popup_error("Choisis ou saisis un nom d‚Äôalbum.")
            return True

        kind = (vals.get("-ALB_KIND-") or "multi").strip() or "multi"

        try:
            album_size = int((vals.get("-ALB_SIZE-") or "0").strip())
        except:
            album_size = 0

        try:
            count_per_post = int((vals.get("-ALB_COUNT-") or "0").strip())
        except:
            count_per_post = 0

        # NOM AVANT CHANGEMENT (pour rename global)
        old_name = (vals.get("-ALB_NAME_ORIG-") or "").strip()
        if not old_name:
            old_name = name  # aucun ancien nom ‚Üí cas "nouvel album"


        # Nouveaux champs persist√©s avec l'album
        default_system = (vals.get("-ALB_SYSTEM-") or "").strip()
        engine_full = (vals.get("-ALB_ENGINE_FULL-") or "multi").strip()
        intro_album = (vals.get("-ALB_INTRO_TMP-") or "").strip()
        # Profils associ√©s √† cet album (liste de noms)
        selected_profiles = vals.get("-ALB_DEVICES-", []) or []


        # ==========================================================
        # üî• RENOMMAGE GLOBAL si old_name diff√©rent
        # ==========================================================
        if old_name and old_name != name and old_name in albums_dict:

            # 1) Rename dans albums_dict
            albums_dict.pop(old_name)
            albums_dict[name] = {
                "kind": kind,
                "album_size": album_size,
                "count_per_post": count_per_post,
                "default_system": default_system,
                "engine_full": engine_full,
                "intro_album": intro_album,
                "profiles": selected_profiles,
            }

            # 2) Mise √† jour Matrix
            for r in matrix_rows:
                if r.get("album") == old_name:
                    r["album"] = name
                if r.get("album2") == old_name:
                    r["album2"] = name

            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)

        else:
            # ======================================================
            # üî• Mode normal : cr√©ation / update simple d‚Äôun album
            # ======================================================
            albums_dict[name] = {
                "kind": kind,
                "album_size": album_size,
                "count_per_post": count_per_post,
                "default_system": default_system,
                "engine_full": engine_full,
                "intro_album": intro_album,
                "profiles": selected_profiles,
            }


        # 3) Sauvegarde finale
        save_albums_dict(albums_dict)
        refresh_albums_table(win, albums_dict)

        # ======================================================
        # üî• Synchronisation automatique si album MULTI
        # ======================================================
        if kind == "multi":
            for r in matrix_rows:
                if r.get("album2") == name:
                    r["count"] = count_per_post

            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)

        # ======================================================
        # üî• Mise √† jour combos intro/multi
        # ======================================================
        intro_list = sorted(
            n for n, cfg in albums_dict.items()
            if cfg.get("kind", "multi") == "intro"
        )
        multi_list = sorted(
            n for n, cfg in albums_dict.items()
            if cfg.get("kind", "multi") == "multi"
        )

        win["-ALBUM-"].update(values=intro_list)
        win["-ALBUM2-"].update(values=multi_list)
        win["-M_ALBUM-"].update(values=intro_list)
        win["-M_ALBUM2-"].update(values=multi_list)

        sg.popup("Album enregistr√©.")
        return True

    # ======================================================================
    # üî• 3) Supprimer un album
    # ======================================================================
    if ev == "-ALB_DEL-":
        name = (vals.get("-ALB_NAME-") or "").strip()

        if not name or name not in albums_dict:
            sg.popup_error("S√©lectionne un album existant.")
            return True

        if sg.popup_yes_no(f"Supprimer l‚Äôalbum '{name}' ?") != "Yes":
            return True

        # 1) Supprimer dans albums.json
        albums_dict.pop(name, None)
        save_albums_dict(albums_dict)
        refresh_albums_table(win, albums_dict)

        # 2) Supprimer les lignes matrix qui utilisent cet album
        new_rows = []
        for r in matrix_rows:
            if r.get("album") == name or r.get("album2") == name:
                continue
            new_rows.append(r)

        matrix_rows[:] = new_rows
        save_json(MATRIX, {"rows": matrix_rows})
        refresh_matrix_table(win, matrix_rows)

        # 3) Nettoyage combos
        intro_list = sorted(
            n for n, cfg in albums_dict.items()
            if cfg.get("kind", "multi") == "intro"
        )
        multi_list = sorted(
            n for n, cfg in albums_dict.items()
            if cfg.get("kind", "multi") == "multi"
        )

        win["-ALBUM-"].update(values=intro_list, value="")
        win["-ALBUM2-"].update(values=multi_list, value="")
        win["-M_ALBUM-"].update(values=intro_list, value="")
        win["-M_ALBUM2-"].update(values=multi_list, value="")

        # 4) Nettoyage champs
        win["-ALB_NAME-"].update("")
        win["-ALB_KIND-"].update("")
        win["-ALB_SIZE-"].update("0")
        win["-ALB_COUNT-"].update("0")

        sg.popup("Album supprim√©.")
        return True

    # ======================================================================
    # üî• 4) Envoyer cet album dans Matrix pour un ou plusieurs profils
    # ======================================================================

    if ev == "-ALB_PUSH_ALL-":

        album_name = (vals.get("-ALB_NAME-") or "").strip()
        if not album_name:
            sg.popup_error("Choisis un album.")
            return True

        cfg = albums_dict.get(album_name)
        if not cfg:
            sg.popup_error("Album introuvable dans albums.json.")
            return True

        system = (vals.get("-ALB_SYSTEM-") or "").strip()
        if not system:
            sg.popup_error("Choisis un system.")
            return True

        # üî• profils r√©ellement s√©lectionn√©s dans la Listbox
        selected_profiles = vals.get("-ALB_DEVICES-", []) or []
        if not selected_profiles:
            # Si rien n'est s√©lectionn√© manuellement, on prend les profils m√©moris√©s
            selected_profiles = cfg.get("profiles", []) or []

        if not selected_profiles:
            sg.popup_error("S√©lectionne au moins un profil.")
            return True


        engine_full = (vals.get("-ALB_ENGINE_FULL-") or "multi").strip()

        # Si intro+multi ‚Üí on doit aussi conna√Ætre l'album intro
        intro_album = None
        if engine_full == "intro+multi":
            intro_album = (vals.get("-ALB_INTRO_TMP-") or "").strip()
            if not intro_album:
                sg.popup_error("Choisis un album intro pour 'intro+multi'.")
                return True

        album_size = int(cfg.get("album_size", 0) or 0)
        count = int(cfg.get("count_per_post", 0) or 0)

        created = 0

        for prof in selected_profiles:

            # üí° Anti-doublon : on v√©rifie si une ligne similaire existe d√©j√†
            already = any(
                (r.get("device") == prof) and
                (r.get("system") == system) and
                (
                    (engine_full == "intro"      and r.get("album")  == album_name) or
                    (engine_full == "multi"      and r.get("album2") == album_name) or
                    (engine_full == "intro+multi" and r.get("album2") == album_name)
                )
                for r in matrix_rows
            )
            if already:
                continue

            row = {
                "device": prof,
                "system": system,
                "engine": engine_full,
                "platform": "WhatsApp",
                "page": "",
                "page_name": "",
                "album_size": album_size,
                "count": count,
            }


            if engine_full == "intro":
                row["album"] = album_name
                row["album2"] = ""
            elif engine_full == "multi":
                row["album"] = ""
                row["album2"] = album_name
            elif engine_full == "intro+multi":
                row["album"] = intro_album
                row["album2"] = album_name

            matrix_rows.append(row)
            created += 1

        if created > 0:
            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)
            sg.popup(f"{created} ligne(s) ajout√©e(s) dans Matrix.")
        else:
            sg.popup("Aucune ligne ajout√©e (elles existent peut-√™tre d√©j√†).")

        return True

    # ======================================================================
    # üî• 5) Renommer un album dans Matrix
    # ======================================================================
    if ev == "-ALB_RENAME_MATRIX-":

        old_name = vals.get("-ALB_NAME_ORIG-", "").strip()
        new_name = vals.get("-ALB_NAME-", "").strip()

        if not old_name or not new_name:
            sg.popup_error("Ancien ou nouveau nom invalide.")
            return True

        if old_name == new_name:
            sg.popup("Aucun changement √† appliquer.")
            return True

        changed = 0

        for row in matrix_rows:
            # intro engine ‚Üí champ album
            if row.get("album") == old_name:
                row["album"] = new_name
                changed += 1

            # multi engine ‚Üí champ album2
            if row.get("album2") == old_name:
                row["album2"] = new_name
                changed += 1

        if changed > 0:
            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)
            sg.popup(f"Album renomm√© dans {changed} ligne(s) Matrix.")
        else:
            sg.popup("Aucune entr√©e Matrix ne contenait cet album.")

        return True

    # ======================================================================
    # üî• 6) Synchronisation : albums multi ‚Üí Matrix
    # ======================================================================
    if ev == "-ALB_SYNC-":

        for name, cfg in albums_dict.items():
            if cfg.get("kind") == "multi":
                count = cfg.get("count_per_post", 0)

                for r in matrix_rows:
                    if r.get("album2") == name:
                        r["count"] = count

        save_json(MATRIX, {"rows": matrix_rows})
        refresh_matrix_table(win, matrix_rows)

        sg.popup("Synchronisation Matrix OK.")
        return True

    # ======================================================================
    # Aucun event Albums
    # ======================================================================
    return False


============================================================================================================================================
FILE: locators_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\locators_admin.py
============================================================================================================================================
# ui/ui_admin/locators_admin.py
# -*- coding: utf-8 -*-

import PySimpleGUI as sg
from ui.ui_paths_helpers import load_locators_dict, save_locators_dict


def handle_locators_events(ev, vals, win):
    """
    G√®re 100% de la logique LOCATORS qui √©tait dans app.py :

        -LOC_LOAD-
        -LOC_SAVE-

    ‚ö† Ne cr√©e aucun widget.
    ‚ö† Ne fait que de la logique sur locators.json.
    """

    # ======================================================================
    # üî• 1) Chargement d'un locator existant (-LOC_LOAD-)
    # ======================================================================
    if ev == "-LOC_LOAD-":
        platform = vals.get("-LOC_PLATFORM-") or ""
        profile  = vals.get("-LOC_PROFILE-") or "default"
        key      = vals.get("-LOC_KEY-") or ""

        if not platform or not key:
            sg.popup_error("Choisis au moins une plateforme et une cl√©.")
            return True

        locs = load_locators_dict()
        plat_cfg = locs.get(platform, {})
        key_cfg  = plat_cfg.get(key, {})

        # On essaie d'abord le profile, puis 'default', puis vide
        xpath = key_cfg.get(profile) or key_cfg.get("default") or ""
        win["-LOC_XPATH-"].update(xpath)

        return True

    # ======================================================================
    # üî• 2) Enregistrement d'un locator (-LOC_SAVE-)
    # ======================================================================
    if ev == "-LOC_SAVE-":
        platform = vals.get("-LOC_PLATFORM-") or ""
        profile  = vals.get("-LOC_PROFILE-") or "default"
        key      = vals.get("-LOC_KEY-") or ""
        xpath    = (vals.get("-LOC_XPATH-") or "").strip()

        if not platform or not key:
            sg.popup_error("Plateforme et cl√© sont obligatoires.")
            return True

        if not xpath:
            sg.popup_error("XPath vide, rien √† enregistrer.")
            return True

        locs = load_locators_dict()

        plat_cfg = locs.setdefault(platform, {})
        key_cfg  = plat_cfg.setdefault(key, {})
        key_cfg[profile] = xpath

        save_locators_dict(locs)
        sg.popup("Locator enregistr√©.")
        return True

    # ======================================================================
    # Pas un event Locators
    # ======================================================================
    return False


============================================================================================================================================
FILE: matrix_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\matrix_admin.py
============================================================================================================================================
# ui/ui_admin/matrix_admin.py
# -*- coding: utf-8 -*-

import PySimpleGUI as sg
from ui.ui_paths_helpers import MATRIX, save_json
from ui.ui_paths_helpers import INTRO_ALBUM_CHOICES, MULTI_ALBUM_CHOICES
from ui.tabs.ui_tabs_admin import refresh_matrix_table


import copy

# ‚úÖ Mapping des colonnes triables (UI -> champ JSON)
SORT_FIELDS = {
    "device": "device",
    "system": "system",
    "engine": "engine",
    "album intro": "album",
    "album multi": "album2",
    "platform": "platform",
    "pays": "page",
    "page_name": "page_name",
    "count": "count",
    "album_size": "album_size",
}

def handle_matrix_events(ev, vals, win, matrix_rows, albums_dict):
    """
    G√àRE 100% DE LA LOGIQUE 'MATRIX' provenant de app.py :

    -MAT_TABLE-
    -M_SAVE-
    -M_DEL-
    -M_REFRESH-

    ‚ö† Aucun widget n'est cr√©√© ici.
    ‚ö† Logique pure et propre.
    """

    # ======================================================================
    # üî• 1) S√©lection dans la TABLE Matrix
    # ======================================================================
    if ev == "-MAT_TABLE-":
        sel = vals["-MAT_TABLE-"]
        if sel:
            idx = sel[0]
            if 0 <= idx < len(matrix_rows):

                r = matrix_rows[idx]

                win["-M_DEVICE-"].update(r.get("device", ""))
                win["-M_SYSTEM-"].update(r.get("system", ""))
                win["-M_ENGINE-"].update(r.get("engine", ""))

                win["-M_ALBUM-"].update(r.get("album", ""))
                win["-M_ALBUM2-"].update(r.get("album2", ""))

                win["-M_ALBUM_SIZE-"].update(str(r.get("album_size", 0)))
                win["-M_COUNT-"].update(str(r.get("count", 11)))

                win["-M_PLATFORM-"].update(r.get("platform", "WhatsApp"))
                win["-M_PAGE-"].update(r.get("page", ""))
                win["-M_PNAME-"].update(r.get("page_name", ""))

        return True

    # ======================================================================
    # üî• 1 bis) Trier la matrix (comme Excel)
    # ======================================================================
    if ev == "-M_SORT-":
        key_ui = (vals.get("-M_SORT_KEY-") or "device").strip()
        asc = bool(vals.get("-M_SORT_ASC-", True))

        field = SORT_FIELDS.get(key_ui, "device")

        def _norm(v):
            if v is None:
                return ""
            if isinstance(v, (int, float)):
                return v
            return str(v).strip().lower()

        matrix_rows.sort(key=lambda r: _norm(r.get(field)), reverse=not asc)

        save_json(MATRIX, {"rows": matrix_rows})
        refresh_matrix_table(win, matrix_rows)
        return True

    # ======================================================================
    # üî• 2) Ajout / Mise √† jour d'une ligne MATRIX
    # ======================================================================
    if ev in ("-M_ADD-", "-M_UPDATE-"):

        data = {
            "device": (vals.get("-M_DEVICE-") or "").strip(),
            "system": (vals.get("-M_SYSTEM-") or "").strip(),
            "engine": (vals.get("-M_ENGINE-") or "").strip(),

            "album": (vals.get("-M_ALBUM-") or "").strip(),
            "album2": (vals.get("-M_ALBUM2-") or "").strip(),

            "platform": (vals.get("-M_PLATFORM-") or "").strip() or "WhatsApp",
            "page": (vals.get("-M_PAGE-") or "").strip(),       # Pays
            "page_name": (vals.get("-M_PNAME-") or "").strip(), # Page

        }

        # album_size
        try:
            data["album_size"] = int((vals.get("-M_ALBUM_SIZE-") or "0").strip())
        except Exception:
            data["album_size"] = 0

        # count
        try:
            data["count"] = int((vals.get("-M_COUNT-") or "11").strip())
        except Exception:
            data["count"] = 11

        sel = vals.get("-MAT_TABLE-", [])

        if ev == "-M_UPDATE-":
            if not sel:
                sg.popup_error("S√©lectionne d'abord une ou plusieurs lignes Matrix √† mettre √† jour.")
                return True

            # ‚úÖ Mettre √† jour toutes les lignes s√©lectionn√©es
            multi_sel = len(sel) > 1

            for idx in sel:
                if 0 <= idx < len(matrix_rows):

                    # 1) Toujours : update device (c‚Äôest l‚Äôidentifiant)
                    matrix_rows[idx]["device"] = data["device"]

                    # 2) Si multi-s√©lection : NE PAS √©craser le reste
                    if multi_sel:
                        continue

                    # 3) Si s√©lection unique : update complet (comportement normal)
                    matrix_rows[idx]["system"] = data["system"]
                    matrix_rows[idx]["engine"] = data["engine"]
                    matrix_rows[idx]["album"] = data["album"]
                    matrix_rows[idx]["album2"] = data["album2"]
                    matrix_rows[idx]["platform"] = data["platform"]
                    matrix_rows[idx]["page"] = data["page"]
                    matrix_rows[idx]["page_name"] = data["page_name"]
                    matrix_rows[idx]["album_size"] = data.get("album_size", 0)
                    matrix_rows[idx]["count"] = data.get("count", 11)

            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)

            sg.popup(f"{len(sel)} ligne(s) Matrix mise(s) √† jour.")
            return True

    # ======================================================================
    # üî• 3) Suppression d'une ou plusieurs lignes MATRIX
    # ======================================================================
    if ev == "-M_DEL-":
        sel = vals.get("-MAT_TABLE-", [])

        if not sel:
            sg.popup_error("S√©lectionne au moins une ligne Matrix.")
            return True

        if sg.popup_yes_no(
                f"Supprimer {len(sel)} ligne(s) s√©lectionn√©e(s) ?"
        ) != "Yes":
            return True

        # üî• supprimer du bas vers le haut (s√©curit√© index)
        for idx in sorted(sel, reverse=True):
            if 0 <= idx < len(matrix_rows):
                del matrix_rows[idx]

        save_json(MATRIX, {"rows": matrix_rows})
        refresh_matrix_table(win, matrix_rows)

        sg.popup("Ligne(s) Matrix supprim√©e(s).")
        return True

    # ======================================================================
    # üî• 3 bis) Dupliquer une ou plusieurs lignes MATRIX
    # ======================================================================
    if ev == "-M_DUP-":
        sel = vals.get("-MAT_TABLE-", [])
        if not sel:
            sg.popup_error("S√©lectionne au moins une ligne Matrix √† dupliquer.")
            return True

        target_device = (vals.get("-M_DEVICE-") or "").strip()
        if not target_device:
            sg.popup_error("Choisis d'abord un device cible dans le combo 'device'.")
            return True

        # On m√©morise l'index de d√©part AVANT ajout
        start_idx = len(matrix_rows)

        created = 0
        for idx in sel:
            if 0 <= idx < len(matrix_rows):
                new_row = copy.deepcopy(matrix_rows[idx])

                # ‚úÖ changer le device vers celui choisi
                new_row["device"] = target_device

                # ‚úÖ valeurs par d√©faut (si absentes)
                new_row.setdefault("platform", "WhatsApp")
                new_row.setdefault("page", "")
                new_row.setdefault("page_name", "")
                new_row.setdefault("album_size", 0)
                new_row.setdefault("count", 11)
                new_row.setdefault("album", "")
                new_row.setdefault("album2", "")

                matrix_rows.append(new_row)
                created += 1

        if created <= 0:
            sg.popup_error("Aucune ligne dupliqu√©e (s√©lection invalide).")
            return True

        # ‚úÖ indices des nouvelles lignes (ajout√©es en bas)
        new_indices = list(range(start_idx, start_idx + created))

        # ‚úÖ sauvegarde + refresh UNE SEULE FOIS
        save_json(MATRIX, {"rows": matrix_rows})
        refresh_matrix_table(win, matrix_rows)

        # ‚úÖ s√©lectionner automatiquement les nouvelles lignes
        try:
            win["-MAT_TABLE-"].update(select_rows=new_indices)
        except Exception:
            pass

        # ‚úÖ scroller vers la premi√®re nouvelle ligne
        try:
            win["-MAT_TABLE-"].Widget.see(new_indices[0])
        except Exception:
            pass

        # ‚úÖ charger la 1√®re nouvelle ligne dans les champs du bas
        try:
            r = matrix_rows[new_indices[0]]
            win["-M_DEVICE-"].update(r.get("device", ""))
            win["-M_SYSTEM-"].update(r.get("system", ""))
            win["-M_ENGINE-"].update(r.get("engine", ""))
            win["-M_ALBUM-"].update(r.get("album", ""))
            win["-M_ALBUM2-"].update(r.get("album2", ""))
            win["-M_ALBUM_SIZE-"].update(str(r.get("album_size", 0)))
            win["-M_COUNT-"].update(str(r.get("count", 11)))
            win["-M_PLATFORM-"].update(r.get("platform", "WhatsApp"))
            win["-M_PAGE-"].update(r.get("page", ""))
            win["-M_PNAME-"].update(r.get("page_name", ""))
        except Exception:
            pass

        # ‚úÖ s√©lectionner automatiquement les nouvelles lignes
        try:
            win["-MAT_TABLE-"].update(select_rows=new_indices)
        except Exception:
            pass

        # ‚úÖ forcer le focus (sinon Tk ignore parfois le scroll)
        try:
            win["-MAT_TABLE-"].set_focus()
        except Exception:
            pass

        # ‚úÖ scroller vraiment vers la 1√®re nouvelle ligne (robuste)
        try:
            table_widget = win["-MAT_TABLE-"].Widget
            total = len(matrix_rows)
            if total > 0:
                first = new_indices[0]
                # position entre 0.0 et 1.0
                frac = max(0.0, min(1.0, first / max(1, total - 1)))
                table_widget.yview_moveto(frac)  # üî• scroll ‚Äúdur‚Äù
                table_widget.see(first)  # s√©curit√© : s‚Äôassurer qu‚Äôelle est visible
        except Exception:
            pass

        # ‚úÖ forcer un refresh UI (aide √©norm√©ment)
        try:
            win.refresh()
        except Exception:
            pass

        sg.popup(f"{created} ligne(s) dupliqu√©e(s) sur le device '{target_device}'.")
        return True

    # ======================================================================
    # üî• 4) Rafra√Æchissement complet (Albums ‚Üí Matrix sync)
    # ======================================================================
    if ev == "-M_REFRESH-":

        # Synchroniser tous les albums multi vers Matrix
        for name, cfg in albums_dict.items():
            if cfg.get("kind") == "multi":
                count = cfg.get("count_per_post", 0)

                for r in matrix_rows:
                    if r.get("album2") == name:
                        r["count"] = count

        save_json(MATRIX, {"rows": matrix_rows})
        refresh_matrix_table(win, matrix_rows)

        sg.popup("Matrix synchronis√©e depuis Albums.")
        return True

    # ======================================================================
    # Aucun √©v√©nement Matrix
    # ======================================================================
    return False


============================================================================================================================================
FILE: pages_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\pages_admin.py
============================================================================================================================================
# ui/ui_admin/pages_admin.py
# -*- coding: utf-8 -*-

import json
from pathlib import Path
import PySimpleGUI as sg

from ui.tabs.ui_tabs_admin import refresh_pages_table, PAGES_FILE, _load_pages_from_json


# -----------------------------------------------------------
#  üî• Rafra√Æchir les combos Pays / Page dans toute l'application
# -----------------------------------------------------------
def _refresh_country_page_combos(win):
    """Met √† jour les combos Pays/Page dans Launcher et Matrix."""
    pages = _load_pages_from_json()
    countries = sorted({p.get("country", "") for p in pages if p.get("country")})
    names     = sorted({p.get("name", "")    for p in pages if p.get("name")})

    # Launcher
    try:
        win["-PAGE-"].update(values=countries)
        win["-PAGE_NAME-"].update(values=names)
    except Exception:
        pass

    # Matrix
    try:
        win["-M_PAGE-"].update(values=countries)
        win["-M_PNAME-"].update(values=names)
    except Exception:
        pass



# -----------------------------------------------------------
#  üî• Sauvegarde des pages
# -----------------------------------------------------------
def _save_pages(pages):
    """Sauvegarde la liste des pages dans pages.json."""
    PAGES_FILE.parent.mkdir(parents=True, exist_ok=True)
    with PAGES_FILE.open("w", encoding="utf-8") as f:
        json.dump({"pages": pages}, f, ensure_ascii=False, indent=2)



# -----------------------------------------------------------
#  üî• Gestion des √©v√©nements Pages (Add / Update / Delete)
# -----------------------------------------------------------
def handle_pages_events(ev, vals, win):
    """
    G√àRE 100% DE LA LOGIQUE PAGES :

        -PG_TABLE-
        -PG_ADD-
        -PG_UPDATE-
        -PG_DEL-
    """

    pages = _load_pages_from_json()

    # ------------------------------------------------------
    # 1) S√©lection dans la table
    # ------------------------------------------------------
    if ev == "-PG_TABLE-":
        sel = vals.get("-PG_TABLE-", [])
        if sel:
            idx = sel[0]
            if 0 <= idx < len(pages):
                row = pages[idx]
                win["-PG_COUNTRY-"].update(row.get("country", ""))
                win["-PG_NAME-"].update(row.get("name", ""))
        return True


    # ------------------------------------------------------
    # 2) Ajouter
    # ------------------------------------------------------
    if ev == "-PG_ADD-":
        country = (vals.get("-PG_COUNTRY-") or "").strip()
        name    = (vals.get("-PG_NAME-") or "").strip()

        if not country or not name:
            sg.popup_error("Pays et Page sont obligatoires.")
            return True

        for p in pages:
            if p.get("country") == country and p.get("name") == name:
                sg.popup_error("Cette combinaison existe d√©j√†.")
                return True

        pages.append({"country": country, "name": name})
        _save_pages(pages)
        refresh_pages_table(win)
        _refresh_country_page_combos(win)

        sg.popup("Page ajout√©e.")
        return True



    # ------------------------------------------------------
    # 3) Mettre √† jour
    # ------------------------------------------------------
    if ev == "-PG_UPDATE-":
        sel = vals.get("-PG_TABLE-", [])
        if not sel:
            sg.popup_error("S√©lectionne une ligne d'abord.")
            return True

        idx = sel[0]
        if not (0 <= idx < len(pages)):
            return True

        country = (vals.get("-PG_COUNTRY-") or "").strip()
        name    = (vals.get("-PG_NAME-") or "").strip()

        if not country or not name:
            sg.popup_error("Pays et Page sont obligatoires.")
            return True

        pages[idx] = {"country": country, "name": name}
        _save_pages(pages)
        refresh_pages_table(win)
        _refresh_country_page_combos(win)

        sg.popup("Page mise √† jour.")
        return True



    # ------------------------------------------------------
    # 4) Supprimer
    # ------------------------------------------------------
    if ev == "-PG_DEL-":
        sel = vals.get("-PG_TABLE-", [])
        if not sel:
            sg.popup_error("S√©lectionne une ligne √† supprimer.")
            return True

        idx = sel[0]
        if not (0 <= idx < len(pages)):
            return True

        row = pages[idx]
        if sg.popup_yes_no(
            f"Supprimer la page '{row.get('name')}' ({row.get('country')}) ?"
        ) != "Yes":
            return True

        del pages[idx]
        _save_pages(pages)
        refresh_pages_table(win)
        _refresh_country_page_combos(win)

        win["-PG_COUNTRY-"].update("")
        win["-PG_NAME-"].update("")

        sg.popup("Page supprim√©e.")
        return True


    return False


============================================================================================================================================
FILE: profiles_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\profiles_admin.py
============================================================================================================================================
# ui/ui_admin/profiles_admin.py
# -*- coding: utf-8 -*-

import PySimpleGUI as sg
from ui.ui_paths_helpers import PROFILES, save_json, build_devices_map_from_profiles
from ui.tabs.ui_tabs_admin import refresh_profiles_table

PROF_SORT_KEY = "name"
PROF_SORT_ASC = True
PROF_VIEW_NAMES = []   # <- mapping index table -> profile name

def _profile_sort_value(name: str, cfg: dict, counts: dict, sort_key: str):
    if sort_key == "enabled":
        return 1 if cfg.get("enabled", True) else 0
    if sort_key == "name":
        return name.lower()
    if sort_key == "rows":
        return int(counts.get(name, 0))
    # autres champs ‚Äúcfg‚Äù
    v = cfg.get(sort_key, "")
    # ports / offset -> int si possible
    if sort_key in ("tcpip_port", "offset_minutes"):
        try: return int(v)
        except Exception: return 0
    return str(v).lower()

def handle_profiles_events(ev, vals, win, profiles, matrix_rows):
    """
    G√àRE 100% DE LA LOGIQUE 'PROFILES' provenant du app.py ORIGINAL :

    -PROF_TABLE-
    -P_SAVE-
    -P_DEL-
    -P_DUP-
    -P_REFRESH-
    -P_PASTE_SERIAL-

    Aucun widget n‚Äôest cr√©√© ici.
    Ce module ne contient QUE la logique.
    """

    # ======================================================================
    # üî• 1) S√©lection d'un profil dans la table
    # ======================================================================
    if ev == "-PROF_TABLE-":
        sel = vals.get("-PROF_TABLE-")
        if not sel:
            return True

        idx = sel[0]
        names = getattr(win, "_prof_view_names", None) or sorted(profiles.keys())
        if idx >= len(names):
            return True

        name = names[idx]

        cfg = profiles.get(name, {})

        win["-P_NAME-"].update(name)
        win["-P_NAME_ORIG-"].update(name)
        win["-P_DEVICE-"].update(cfg.get("device_id", ""))
        win["-P_ADB_SERIAL-"].update(cfg.get("adb_serial", ""))
        win["-P_TCPIP_IP-"].update(cfg.get("tcpip_ip", ""))
        win["-P_TCPIP_PORT-"].update(str(cfg.get("tcpip_port", "")))
        win["-P_PVER-"].update(cfg.get("platform_version", ""))
        win["-P_OFFSET-"].update(str(cfg.get("offset_minutes", 0)))
        win["-P_ENABLED-"].update(bool(cfg.get("enabled", True)))

        # ‚úÖ appium_overrides affich√© en JSON dans l'UI
        app_ov = cfg.get("appium_overrides", {})
        try:
            import json
            win["-P_APPIUM_OVERRIDES-"].update(json.dumps(app_ov, ensure_ascii=False, indent=2))
        except Exception:
            win["-P_APPIUM_OVERRIDES-"].update("")

        gal = cfg.get("gallery", {}) or {}
        win["-P_GALLERY_PKG-"].update(gal.get("appPackage", "com.sec.android.gallery3d"))
        win["-P_GALLERY_ACT-"].update(gal.get("appActivity", "com.sec.android.gallery3d.app.GalleryActivity"))

        return True

    # ======================================================================
    # üî• 1 bis) Sort d'un profil dans la table
    # ======================================================================

    if ev == "-P_SORT-":
        global PROF_SORT_KEY, PROF_SORT_ASC, PROF_VIEW_NAMES

        PROF_SORT_KEY = vals.get("-P_SORT_KEY-", "name")
        PROF_SORT_ASC = bool(vals.get("-P_SORT_ASC-", True))

        # compter rows (colonne "rows" = nb de lignes Matrix par profil)
        from collections import Counter
        counts = Counter()
        for r in matrix_rows or []:
            dev = r.get("device")
            if dev:
                counts[dev] += 1

        names = list(profiles.keys())
        names.sort(
            key=lambda n: _profile_sort_value(n, profiles.get(n, {}), counts, PROF_SORT_KEY),
            reverse=not PROF_SORT_ASC,
        )

        # ‚úÖ stocker le mapping dans la window
        win._prof_view_names = names

        refresh_profiles_table(win, profiles, matrix_rows)
        return True

    # ======================================================================
    # üî• 2) Ajouter ou mettre √† jour un profil
    # ======================================================================
    if ev == "-P_SAVE-":
        import copy

        # Nouveau nom (champ visible)
        new_name = (vals.get("-P_NAME-") or "").strip()
        if not new_name:
            sg.popup_error("Le champ 'name' est obligatoire.")
            return True

        # Ancien nom (champ cach√©, d√©fini quand on clique une ligne)
        old_name = (vals.get("-P_NAME_ORIG-") or "").strip()
        if not old_name:
            old_name = new_name  # cr√©ation ou update simple

        is_rename = (old_name != new_name)

        # Si rename, v√©rifier collision
        if is_rename and new_name in profiles:
            sg.popup_error("Ce nom existe d√©j√†.")
            return True

        # ‚úÖ On part TOUJOURS de l‚Äôancien profil s√©lectionn√© si rename
        base_cfg = profiles.get(old_name, {}) if old_name in profiles else profiles.get(new_name, {})
        cfg = copy.deepcopy(base_cfg) if isinstance(base_cfg, dict) else {}

        # Ancienne config pour propagation √©ventuelle
        prev_cfg = cfg.copy()
        old_device_id = prev_cfg.get("device_id")
        old_adb_serial = prev_cfg.get("adb_serial")

        # ‚úÖ enabled
        cfg["enabled"] = bool(vals.get("-P_ENABLED-", True))

        # Champs standard
        device_id = (vals.get("-P_DEVICE-") or "").strip()
        adb_serial = (vals.get("-P_ADB_SERIAL-") or "").strip()
        tcpip_ip = (vals.get("-P_TCPIP_IP-") or "").strip()
        tcpip_port_raw = (vals.get("-P_TCPIP_PORT-") or "").strip()
        pver = (vals.get("-P_PVER-") or "").strip()

        try:
            tcpip_port = int(tcpip_port_raw) if tcpip_port_raw else None
        except Exception:
            tcpip_port = None

        try:
            offset_minutes = int((vals.get("-P_OFFSET-") or "0").strip())
        except Exception:
            offset_minutes = 0

        cfg.update({
            "device_id": device_id,
            "platform_version": pver,
            "offset_minutes": offset_minutes,
        })

        if adb_serial:
            cfg["adb_serial"] = adb_serial
        else:
            cfg.pop("adb_serial", None)

        if tcpip_ip:
            cfg["tcpip_ip"] = tcpip_ip
        else:
            cfg.pop("tcpip_ip", None)

        if tcpip_port is not None:
            cfg["tcpip_port"] = tcpip_port
        else:
            cfg.pop("tcpip_port", None)

        # ‚úÖ appium_overrides vient du FRONT (multiline JSON)
        raw_ov = (vals.get("-P_APPIUM_OVERRIDES-") or "").strip()
        if raw_ov:
            try:
                import json
                parsed = json.loads(raw_ov)
                if not isinstance(parsed, dict):
                    sg.popup_error("appium_overrides doit √™tre un JSON objet (cl√©/valeur).")
                    return True
                cfg["appium_overrides"] = parsed
            except Exception:
                sg.popup_error("appium_overrides invalide : JSON incorrect.")
                return True
        else:
            cfg.pop("appium_overrides", None)

        # ‚úÖ gallery
        pkg = (vals.get("-P_GALLERY_PKG-") or "").strip()
        act = (vals.get("-P_GALLERY_ACT-") or "").strip()

        if pkg or act:
            cfg["gallery"] = {
                "appPackage": pkg or "com.sec.android.gallery3d",
                "appActivity": act or "com.sec.android.gallery3d.app.GalleryActivity",
            }
        else:
            cfg.pop("gallery", None)

        # ‚úÖ √©crire sous le nouveau nom
        profiles[new_name] = cfg

        # ‚úÖ si rename : supprimer l'ancien
        if is_rename:
            profiles.pop(old_name, None)

            # ‚úÖ (recommand√©) Propager dans Matrix.device pour ne pas casser les jobs
            for r in (matrix_rows or []):
                if r.get("device") == old_name:
                    r["device"] = new_name

        # ==========================================================
        # üîÅ PROPAGATION : device_id / tcpip_ip / tcpip_port
        # ==========================================================
        if old_device_id and device_id and device_id != old_device_id:
            for other_name, other_cfg in profiles.items():
                if other_name == new_name:
                    continue

                if other_cfg.get("device_id") == old_device_id:
                    other_cfg["device_id"] = device_id

                    if tcpip_ip:
                        other_cfg["tcpip_ip"] = tcpip_ip
                    if tcpip_port is not None:
                        other_cfg["tcpip_port"] = tcpip_port

        # ==========================================================
        # üîÅ PROPAGATION : adb_serial
        # ==========================================================
        if vals.get("-P_PROP_SERIAL-", False):
            if old_adb_serial and adb_serial and adb_serial != old_adb_serial:
                for other_name, other_cfg in profiles.items():
                    if other_name == new_name:
                        continue
                    if other_cfg.get("adb_serial") == old_adb_serial:
                        other_cfg["adb_serial"] = adb_serial

        # Sauvegarder JSON
        save_json(PROFILES, {"profiles": profiles})

        refresh_profiles_table(win, profiles, matrix_rows)

        win["-P_NAME_ORIG-"].update(new_name)

        if "-M_DEVICE-" in win.AllKeysDict:
            win["-M_DEVICE-"].update(values=sorted(profiles.keys()))

        # garder s√©lection
        names = getattr(win, "_prof_view_names", None) or sorted(profiles.keys())
        try:
            idx = names.index(new_name)
        except ValueError:
            idx = None

        if idx is not None:
            try:
                win["-PROF_TABLE-"].update(select_rows=[idx])
                win["-PROF_TABLE-"].Widget.see(idx)
                win["-PROF_TABLE-"].set_focus()
                win.refresh()
            except Exception:
                pass

        # Rafra√Æchir la Combo -PROFILE-
        win["-PROFILE-"].update(values=sorted(profiles.keys()), value=new_name)

        # Mise √† jour map devices pour d'autres modules
        build_devices_map_from_profiles(profiles)

        sg.popup("Profil enregistr√©.")
        return True

    # ======================================================================
    # üî• 3) SUPPRESSION d'un profil
    # ======================================================================
    if ev == "-P_DEL-":
        name = (vals.get("-P_NAME-") or "").strip()

        if not name or name not in profiles:
            sg.popup_error("S√©lectionne un profil existant.")
            return True

        if sg.popup_yes_no(f"Supprimer le profil '{name}' ?") != "Yes":
            return True

        profiles.pop(name, None)

        save_json(PROFILES, {"profiles": profiles})
        refresh_profiles_table(win, profiles, matrix_rows)
        win["-PROFILE-"].update(values=list(profiles.keys()))
        win["-M_DEVICE-"].update(values=sorted(profiles.keys()))

        # Reset UI
        win["-P_NAME-"].update("")
        win["-P_DEVICE-"].update("")
        win["-P_ADB_SERIAL-"].update("")
        win["-P_TCPIP_IP-"].update("")
        win["-P_TCPIP_PORT-"].update("")
        win["-P_PVER-"].update("")
        win["-P_OFFSET-"].update("0")
        win["-P_ENABLED-"].update(True)
        win["-P_APPIUM_OVERRIDES-"].update("")
        win["-P_GALLERY_PKG-"].update("")
        win["-P_GALLERY_ACT-"].update("")

        return True

    # ======================================================================
    # üî• 4) DUPLICATION d‚Äôun profil
    # ======================================================================
    if ev == "-P_DUP-":
        sel = vals.get("-PROF_TABLE-", [])

        if not sel:
            sg.popup_error("S√©lectionne d'abord un profil √† dupliquer.")
            return True

        idx = sel[0]

        # ‚úÖ ordre affich√© (tri actif) sinon fallback
        names = getattr(win, "_prof_view_names", None) or sorted(profiles.keys())

        if idx >= len(names):
            return True

        import copy
        base_name = names[idx]
        base_cfg = copy.deepcopy(profiles.get(base_name, {}))

        new_name = sg.popup_get_text(
            f"Nouveau profil (copie de {base_name}):",
            default_text=f"{base_name}_copy"
        )

        if not new_name:
            return True

        new_name = new_name.strip()

        if not new_name:
            return True

        if new_name in profiles:
            sg.popup_error("Ce nom existe d√©j√†.")
            return True

        # ‚úÖ cr√©er la copie
        profiles[new_name] = base_cfg

        # ‚úÖ persister
        save_json(PROFILES, {"profiles": profiles})

        # ‚úÖ refresh table
        refresh_profiles_table(win, profiles, matrix_rows)

        # ‚úÖ refresh combo profiles (si tu veux garder tri alpha)
        win["-PROFILE-"].update(values=sorted(profiles.keys()), value=new_name)

        # ‚úÖ recalculer l'ordre affich√© (apr√®s refresh, car le tri peut d√©placer la ligne)
        names = getattr(win, "_prof_view_names", None) or sorted(profiles.keys())

        # ‚úÖ trouver index r√©el du nouveau profil dans l'ordre affich√©
        try:
            new_idx = names.index(new_name)
        except ValueError:
            new_idx = None

        # ‚úÖ s√©lectionner + scroll + focus (comme Matrix)
        if new_idx is not None:
            try:
                win["-PROF_TABLE-"].update(select_rows=[new_idx])
            except Exception:
                pass
            try:
                win["-PROF_TABLE-"].Widget.see(new_idx)
            except Exception:
                pass
            try:
                win["-PROF_TABLE-"].set_focus()
            except Exception:
                pass
            try:
                win.refresh()
            except Exception:
                pass

        # ‚úÖ remplir la fiche en bas avec la config du nouveau profil (pas base_cfg ‚Äú√† l‚Äôaveugle‚Äù)
        cfg = profiles.get(new_name, {}) or {}
        gal = cfg.get("gallery", {}) or {}
        app_ov = cfg.get("appium_overrides", {}) or {}

        try:
            import json
            win["-P_APPIUM_OVERRIDES-"].update(json.dumps(app_ov, ensure_ascii=False, indent=2))
        except Exception:
            win["-P_APPIUM_OVERRIDES-"].update("")

        win["-P_GALLERY_PKG-"].update(gal.get("appPackage", "com.sec.android.gallery3d"))
        win["-P_GALLERY_ACT-"].update(gal.get("appActivity", "com.sec.android.gallery3d.app.GalleryActivity"))

        sg.popup(f"Profil dupliqu√© sous '{new_name}'.")
        return True

    # ======================================================================
    # üî• 5) Coller un serial depuis le presse-papiers
    # ======================================================================
    if ev == "-P_PASTE_SERIAL-":
        try:
            clip = sg.clipboard_get() or ""
        except Exception:
            clip = ""

        serial = clip.strip()
        if not serial:
            sg.popup_error("Aucun serial trouv√© dans le presse-papiers.")
        else:
            win["-P_ADB_SERIAL-"].update(serial)

        return True

    # ======================================================================
    # üî• 6) Rafra√Æchir la table Profiles
    # ======================================================================
    if ev == "-P_REFRESH-":
        refresh_profiles_table(win, profiles, matrix_rows)
        return True

    # ======================================================================
    # Aucun √©v√©nement profile
    # ======================================================================
    return False


============================================================================================================================================
FILE: systems_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\systems_admin.py
============================================================================================================================================
# ui/ui_admin/systems_admin.py
# -*- coding: utf-8 -*-

import PySimpleGUI as sg
from ui.ui_paths_helpers import SYSTEMS, MATRIX, save_json
from ui.tabs.ui_tabs_admin import refresh_systems_table, refresh_matrix_table

def handle_systems_events(ev, vals, win, systems, matrix_rows):

    """
    G√àRE 100% DE LA LOGIQUE 'SYSTEMS' provenant de app.py :

    -SYS_TABLE-
    -S_SAVE-
    -S_DEL-

    ‚ö†Ô∏è Aucun affichage n'est cr√©√© ici.
    ‚ö†Ô∏è Ce module fait UNIQUEMENT la logique.
    """

    # ======================================================================
    # üî• 1) S√©lection dans la table Systems
    # ======================================================================
    if ev == "-SYS_TABLE-":
        sel = vals["-SYS_TABLE-"]
        if sel:
            idx = sel[0]
            keys = [k for k, _ in sorted(systems.items())]

            if idx < len(keys):
                key = keys[idx]
                val = systems[key]

                # On r√©cup√®re les times
                if isinstance(val, list):
                    times = val
                else:
                    # Cas rare (ancienne structure dict)
                    times = val.get("times", [])

                win["-S_KEY-"].update(key)
                win["-S_TIMES-"].update(",".join(times))
                win["-S_KEY_ORIG-"].update(key)  # üëà on m√©morise l‚Äôancien nom

        return True

    # ======================================================================
    # üî• 2) S_ADD : ajouter un NOUVEAU system
    # ======================================================================
    if ev == "-S_ADD-":
        key = (vals.get("-S_KEY-") or "").strip()

        if not key:
            sg.popup_error("Le champ 'key' est obligatoire.")
            return True

        if key in systems:
            sg.popup_error(f"Le system '{key}' existe d√©j√†. Utilise 'Update' pour le modifier.")
            return True

        raw = (vals.get("-S_TIMES-") or "").strip()
        times = [t.strip() for t in raw.split(",") if t.strip()]

        systems[key] = times

        save_json(SYSTEMS, {"systems": systems})
        refresh_systems_table(win, systems)

        sg.popup(f"System '{key}' ajout√©.")
        return True

    # ======================================================================
    # üî• 3) S_UPDATE : renommer / modifier un system existant
    # ======================================================================
    if ev == "-S_UPDATE-":
        new_key = (vals.get("-S_KEY-") or "").strip()
        old_key = (vals.get("-S_KEY_ORIG-") or "").strip()

        if not old_key:
            sg.popup_error("S√©lectionne d'abord un system dans la liste.")
            return True

        if not new_key:
            sg.popup_error("Le champ 'key' est obligatoire.")
            return True

        raw = (vals.get("-S_TIMES-") or "").strip()
        times = [t.strip() for t in raw.split(",") if t.strip()]

        # ---- Cas 1 : m√™me cl√© ‚Üí on ne fait que mettre √† jour les heures
        if new_key == old_key:
            systems[old_key] = times

        else:
            # ---- Cas 2 : renommage de la cl√©
            # Optionnel : protection si new_key existe d√©j√†
            if new_key in systems and new_key != old_key:
                if sg.popup_yes_no(
                    f"Le system '{new_key}' existe d√©j√†. Le remplacer ?"
                ) != "Yes":
                    return True

            # 1) Mise √† jour du dict systems
            systems.pop(old_key, None)
            systems[new_key] = times

            # 2) Propagation dans MATRIX : renommer toutes les lignes
            for r in matrix_rows:
                if r.get("system") == old_key:
                    r["system"] = new_key

            # Sauvegarder Matrix + refresh
            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)

        # 3) Sauvegarde des systems + refresh de l'onglet Systems (+ combos Albums/Matrix)
        save_json(SYSTEMS, {"systems": systems})
        refresh_systems_table(win, systems)

        # Mettre √† jour la valeur d'origine pour un prochain rename
        win["-S_KEY_ORIG-"].update(new_key)

        sg.popup(f"System '{old_key}' mis √† jour.")
        return True

    # ======================================================================
    # üî• 4) S_DEL : supprimer un system + ses lignes Matrix
    # ======================================================================
    if ev == "-S_DEL-":
        key = (vals.get("-S_KEY-") or "").strip()

        if not key or key not in systems:
            sg.popup_error("S√©lectionne un system existant.")
            return True

        if sg.popup_yes_no(
            f"Supprimer le system '{key}' ET toutes les lignes Matrix associ√©es ?"
        ) != "Yes":
            return True

        # 1) Supprimer dans systems
        systems.pop(key, None)
        save_json(SYSTEMS, {"systems": systems})
        refresh_systems_table(win, systems)

        # 2) Supprimer les lignes Matrix qui utilisent ce system
        new_rows = [r for r in matrix_rows if r.get("system") != key]
        if len(new_rows) != len(matrix_rows):
            matrix_rows[:] = new_rows
            save_json(MATRIX, {"rows": matrix_rows})
            refresh_matrix_table(win, matrix_rows)

        # 3) Nettoyage des champs
        win["-S_KEY-"].update("")
        win["-S_KEY_ORIG-"].update("")
        win["-S_TIMES-"].update("")

        sg.popup("System et lignes Matrix associ√©es supprim√©s.")
        return True


============================================================================================================================================
FILE: ui_admin.py
PATH: C:\Users\Dropbox\Jerry Kamgang\Softwares\Scripts\Jk_Scripts\JK_Stories\StoryFx\ui\ui_admin\ui_admin.py
============================================================================================================================================
# ui/ui_admin/ui_admin.py
# -*- coding: utf-8 -*-

"""
Routeur ADMIN COMPLET
=====================

Ce fichier remplace 1500 lignes de logique dans app.py.
Il redistribue intelligemment chaque √©v√©nement Admin vers :

    - Profiles Admin       (PROF_TABLE, P_SAVE, P_DEL, P_DUP, etc.)
    - Albums Admin         (ALB_TABLE, ALB_SAVE, ALB_DEL, ALB_SYNC)
    - Systems Admin        (SYS_TABLE, S_SAVE, S_DEL)
    - Matrix Admin         (MAT_TABLE, M_SAVE, M_DEL, M_REFRESH)
    - Locators Admin       (LOC_LOAD, LOC_SAVE)

Il est 100% fid√®le √† ton app originale (:contentReference[oaicite:7]{index=7}).
Il ne fait AUCUNE logique lui-m√™me.
Il redirige proprement.
"""

from .profiles_admin import handle_profiles_events
from .albums_admin import handle_albums_events
from .systems_admin import handle_systems_events
from .matrix_admin import handle_matrix_events
from .locators_admin import handle_locators_events
from .pages_admin import handle_pages_events



def handle_admin_events(ev, vals, win, profiles, systems, matrix_rows, albums_dict):
    """
    Route automatiquement tous les √©v√©nements ADMIN vers les bons modules.

    Retourne :
        True  ‚Üí √©v√©nement trait√©
        False ‚Üí non g√©r√© (retour √† app.py / autres modules)
    """

    # ----------------------------------------------------------------------
    # üî• 1) LOCATORS
    # ----------------------------------------------------------------------
    if ev.startswith("-LOC_"):
        return handle_locators_events(ev, vals, win)

    # ----------------------------------------------------------------------
    # üî• 2) ALBUMS
    # ----------------------------------------------------------------------
    if ev.startswith("-ALB_") or ev == "-ALB_TABLE-":
        return handle_albums_events(ev, vals, win, albums_dict, matrix_rows, profiles)

    # ----------------------------------------------------------------------
    # üî• 3) PROFILES
    # ----------------------------------------------------------------------
    if ev.startswith("-P_") or ev == "-PROF_TABLE-":
        return handle_profiles_events(ev, vals, win, profiles, matrix_rows)

    # ----------------------------------------------------------------------
    # üî• 4) SYSTEMS
    # ----------------------------------------------------------------------
    if ev.startswith("-S_") or ev == "-SYS_TABLE-":
        return handle_systems_events(ev, vals, win, systems, matrix_rows)

    # ----------------------------------------------------------------------
    # üî• 5) MATRIX
    # ----------------------------------------------------------------------
    if ev.startswith("-M_") or ev == "-MAT_TABLE-":
        return handle_matrix_events(ev, vals, win, matrix_rows, albums_dict)

    # ----------------------------------------------------------------------
    # üî• 6) PAGES
    # ----------------------------------------------------------------------
    if ev.startswith("-PG_") or ev == "-PG_TABLE-":
        return handle_pages_events(ev, vals, win)

    # ----------------------------------------------------------------------
    # Aucun √©v√©nement admin
    # ----------------------------------------------------------------------
    return False



